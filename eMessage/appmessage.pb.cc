// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "appmessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace isafetec {

namespace {

const ::google::protobuf::Descriptor* CPUInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CPUInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CPUInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CPUInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* BIOSInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BIOSInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* BIOSInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BIOSInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CDRomDriveInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CDRomDriveInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CDRomDriveInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CDRomDriveInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputerSystemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputerSystemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputerSystemInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputerSystemInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputerSystemProductInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputerSystemProductInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputerSystemProductInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputerSystemProductInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* DiskPartitionInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DiskPartitionInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DiskPartitionInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DiskPartitionInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisplayConfigurationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisplayConfigurationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisplayConfigurationInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisplayConfigurationInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* IDEControllerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IDEControllerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* IDEControllerInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IDEControllerInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* InstalledSofteware_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InstalledSofteware_reflection_ = NULL;
const ::google::protobuf::Descriptor* InstalledSoftewareList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InstalledSoftewareList_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyboardInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyboardInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyboardInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyboardInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalDiskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalDiskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogicalDiskInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogicalDiskInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MainBoardInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MainBoardInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MainBoardInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MainBoardInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemoryDeviceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemoryDeviceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemoryDeviceInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemoryDeviceInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemoryInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemoryInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemoryInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemoryInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MouseInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MouseInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MouseInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MouseInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetWorkAdapterInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetWorkAdapterInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetWorkAdapterInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetWorkAdapterInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhysicalDiskDriversInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhysicalDiskDriversInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhysicalDiskDriversInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhysicalDiskDriversInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhysicalMediaInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhysicalMediaInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhysicalMediaInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhysicalMediaInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* USBControllerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  USBControllerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* USBControllerInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  USBControllerInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* VideoDisplayDeviceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VideoDisplayDeviceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* VideoDisplayDeviceInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VideoDisplayDeviceInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltServiceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltServiceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltServiceList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltServiceList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltProcessInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltProcessInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltProcessList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltProcessList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltUser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltUser_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltUserList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltUserList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltGroupList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltGroupList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltShareInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltShareInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltShareList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltShareList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltStartItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltStartItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltStartList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltStartList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltDiskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltDiskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CltDiskList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CltDiskList_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceControlInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceControlInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceControlClassInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceControlClassInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeviceControlClassList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeviceControlClassList_reflection_ = NULL;
const ::google::protobuf::Descriptor* FireWallInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FireWallInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataBaseInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataBaseInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataBaseInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataBaseInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ODBCSourceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ODBCSourceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ODBCSourceInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ODBCSourceInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ODBCDriverInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ODBCDriverInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ODBCDriverInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ODBCDriverInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AntiVirusSoftWareInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AntiVirusSoftWareInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* AntiVirusSoftWareInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AntiVirusSoftWareInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisposeSoftInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisposeSoftInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisposeSoftInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisposeSoftInfoList_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_appmessage_2eproto() {
  protobuf_AddDesc_appmessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "appmessage.proto");
  GOOGLE_CHECK(file != NULL);
  CPUInfo_descriptor_ = file->message_type(0);
  static const int CPUInfo_offsets_[33] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, architecture_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, currentclockspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, currentvoltage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, datawidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, extclock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, family_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, l2cachespeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, l3cachesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, l3cachespeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, maxclockspeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, loadpercentage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, processortype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, l2cachesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, addresswidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, processorid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, role_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, socketdesignation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, stepping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, buyname_),
  };
  CPUInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CPUInfo_descriptor_,
      CPUInfo::default_instance_,
      CPUInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CPUInfo));
  CPUInfoList_descriptor_ = file->message_type(1);
  static const int CPUInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfoList, winuser_),
  };
  CPUInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CPUInfoList_descriptor_,
      CPUInfoList::default_instance_,
      CPUInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CPUInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CPUInfoList));
  BIOSInfo_descriptor_ = file->message_type(2);
  static const int BIOSInfo_offsets_[28] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, targetoperatingsystem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, softwareelementstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, primarybios_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, smbiospresent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, buildnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, codeset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, currentlanguage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, identificationcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, languageedition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, othertargetos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, smbiosbiosversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, softwareelementid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, smbiosmajorversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, smbiosminorversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, buyname_),
  };
  BIOSInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BIOSInfo_descriptor_,
      BIOSInfo::default_instance_,
      BIOSInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BIOSInfo));
  BIOSInfoList_descriptor_ = file->message_type(3);
  static const int BIOSInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfoList, winuser_),
  };
  BIOSInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BIOSInfoList_descriptor_,
      BIOSInfoList::default_instance_,
      BIOSInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BIOSInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BIOSInfoList));
  CDRomDriveInfo_descriptor_ = file->message_type(4);
  static const int CDRomDriveInfo_offsets_[37] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, filesystemflagsex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, maxblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, maximumcomponentlength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, maxmediasize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, minblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, numberofmediasupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, scsibus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, scsilogicalunit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, scsiport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, scsitargetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, transferrate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, driveintegrity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, medialoaded_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, needscleaning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, compressionmethod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, drive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, mediatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, revisionlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, volumename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, volumeserialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, defaultblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, buyname_),
  };
  CDRomDriveInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CDRomDriveInfo_descriptor_,
      CDRomDriveInfo::default_instance_,
      CDRomDriveInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CDRomDriveInfo));
  CDRomDriveInfoList_descriptor_ = file->message_type(5);
  static const int CDRomDriveInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfoList, winuser_),
  };
  CDRomDriveInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CDRomDriveInfoList_descriptor_,
      CDRomDriveInfoList::default_instance_,
      CDRomDriveInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CDRomDriveInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CDRomDriveInfoList));
  ComputerSystemInfo_descriptor_ = file->message_type(6);
  static const int ComputerSystemInfo_offsets_[42] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, domainrole_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, frontpanelresetstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, keyboardpasswordstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, poweronpasswordstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, powerstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, powersupplystate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, resetcapability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, systemstartupdelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, thermalstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, wakeuptype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, currenttimezone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, resetcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, resetlimit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, numberofprocessors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, totalphysicalmemory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, pauseafterreset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, automaticresetbootoption_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, automaticresetcapability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, bootromsupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, enabledaylightsavingstime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, infraredsupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, networkservermodeenabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, partofdomain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, systemstartupsetting_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, bootupstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, dnshostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, domain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, primaryownername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, roles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, systemstartupoptions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, systemtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, adminpasswordstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, chassisbootupstate_),
  };
  ComputerSystemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ComputerSystemInfo_descriptor_,
      ComputerSystemInfo::default_instance_,
      ComputerSystemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ComputerSystemInfo));
  ComputerSystemInfoList_descriptor_ = file->message_type(7);
  static const int ComputerSystemInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfoList, winuser_),
  };
  ComputerSystemInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ComputerSystemInfoList_descriptor_,
      ComputerSystemInfoList::default_instance_,
      ComputerSystemInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ComputerSystemInfoList));
  ComputerSystemProductInfo_descriptor_ = file->message_type(8);
  static const int ComputerSystemProductInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, identifyingnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, vendor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, description_),
  };
  ComputerSystemProductInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ComputerSystemProductInfo_descriptor_,
      ComputerSystemProductInfo::default_instance_,
      ComputerSystemProductInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ComputerSystemProductInfo));
  ComputerSystemProductInfoList_descriptor_ = file->message_type(9);
  static const int ComputerSystemProductInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfoList, winuser_),
  };
  ComputerSystemProductInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ComputerSystemProductInfoList_descriptor_,
      ComputerSystemProductInfoList::default_instance_,
      ComputerSystemProductInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputerSystemProductInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ComputerSystemProductInfoList));
  DiskPartitionInfo_descriptor_ = file->message_type(10);
  static const int DiskPartitionInfo_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, blocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, numberofblocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, startingoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, diskindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, buyname_),
  };
  DiskPartitionInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DiskPartitionInfo_descriptor_,
      DiskPartitionInfo::default_instance_,
      DiskPartitionInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DiskPartitionInfo));
  DiskPartitionInfoList_descriptor_ = file->message_type(11);
  static const int DiskPartitionInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfoList, winuser_),
  };
  DiskPartitionInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DiskPartitionInfoList_descriptor_,
      DiskPartitionInfoList::default_instance_,
      DiskPartitionInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiskPartitionInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DiskPartitionInfoList));
  DisplayConfigurationInfo_descriptor_ = file->message_type(12);
  static const int DisplayConfigurationInfo_offsets_[22] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, displayfrequency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, dithertype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, icmintent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, icmmethod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, logpixels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, pelsheight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, pelswidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, specificationversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, devicename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, driverversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, bitsperperl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, displayflags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, buyname_),
  };
  DisplayConfigurationInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DisplayConfigurationInfo_descriptor_,
      DisplayConfigurationInfo::default_instance_,
      DisplayConfigurationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DisplayConfigurationInfo));
  DisplayConfigurationInfoList_descriptor_ = file->message_type(13);
  static const int DisplayConfigurationInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfoList, winuser_),
  };
  DisplayConfigurationInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DisplayConfigurationInfoList_descriptor_,
      DisplayConfigurationInfoList::default_instance_,
      DisplayConfigurationInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisplayConfigurationInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DisplayConfigurationInfoList));
  IDEControllerInfo_descriptor_ = file->message_type(14);
  static const int IDEControllerInfo_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, maxnumbercontrolled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, protocolsupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, buyname_),
  };
  IDEControllerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IDEControllerInfo_descriptor_,
      IDEControllerInfo::default_instance_,
      IDEControllerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IDEControllerInfo));
  IDEControllerInfoList_descriptor_ = file->message_type(15);
  static const int IDEControllerInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfoList, winuser_),
  };
  IDEControllerInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IDEControllerInfoList_descriptor_,
      IDEControllerInfoList::default_instance_,
      IDEControllerInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IDEControllerInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IDEControllerInfoList));
  InstalledSofteware_descriptor_ = file->message_type(16);
  static const int InstalledSofteware_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, installed_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, installed_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, help_link_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, description_),
  };
  InstalledSofteware_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InstalledSofteware_descriptor_,
      InstalledSofteware::default_instance_,
      InstalledSofteware_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSofteware, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InstalledSofteware));
  InstalledSoftewareList_descriptor_ = file->message_type(17);
  static const int InstalledSoftewareList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSoftewareList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSoftewareList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSoftewareList, winuser_),
  };
  InstalledSoftewareList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InstalledSoftewareList_descriptor_,
      InstalledSoftewareList::default_instance_,
      InstalledSoftewareList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSoftewareList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstalledSoftewareList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InstalledSoftewareList));
  KeyboardInfo_descriptor_ = file->message_type(18);
  static const int KeyboardInfo_offsets_[18] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, password_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, islocked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, layout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, numberoffunctionkeys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, buyname_),
  };
  KeyboardInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyboardInfo_descriptor_,
      KeyboardInfo::default_instance_,
      KeyboardInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyboardInfo));
  KeyboardInfoList_descriptor_ = file->message_type(19);
  static const int KeyboardInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfoList, winuser_),
  };
  KeyboardInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyboardInfoList_descriptor_,
      KeyboardInfoList::default_instance_,
      KeyboardInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyboardInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyboardInfoList));
  LogicalDiskInfo_descriptor_ = file->message_type(20);
  static const int LogicalDiskInfo_offsets_[24] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, mediatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, freespace_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, quotasdisabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, quotasincomplete_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, quotasrebuilding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, supportsdiskquotas_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, supportsfilebasedcompression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, filesystem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, volumename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, volumeserialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, drivetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, maximumcomponentlength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, buyname_),
  };
  LogicalDiskInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalDiskInfo_descriptor_,
      LogicalDiskInfo::default_instance_,
      LogicalDiskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalDiskInfo));
  LogicalDiskInfoList_descriptor_ = file->message_type(21);
  static const int LogicalDiskInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfoList, winuser_),
  };
  LogicalDiskInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogicalDiskInfoList_descriptor_,
      LogicalDiskInfoList::default_instance_,
      LogicalDiskInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogicalDiskInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogicalDiskInfoList));
  MainBoardInfo_descriptor_ = file->message_type(22);
  static const int MainBoardInfo_offsets_[22] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, otheridentifyinginfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, partnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, product_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, requirementsdescription_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, sku_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, slotlayout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, buyname_),
  };
  MainBoardInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MainBoardInfo_descriptor_,
      MainBoardInfo::default_instance_,
      MainBoardInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MainBoardInfo));
  MainBoardInfoList_descriptor_ = file->message_type(23);
  static const int MainBoardInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfoList, winuser_),
  };
  MainBoardInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MainBoardInfoList_descriptor_,
      MainBoardInfoList::default_instance_,
      MainBoardInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MainBoardInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MainBoardInfoList));
  MemoryDeviceInfo_descriptor_ = file->message_type(24);
  static const int MemoryDeviceInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, endingaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, startingaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, buyname_),
  };
  MemoryDeviceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemoryDeviceInfo_descriptor_,
      MemoryDeviceInfo::default_instance_,
      MemoryDeviceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemoryDeviceInfo));
  MemoryDeviceInfoList_descriptor_ = file->message_type(25);
  static const int MemoryDeviceInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfoList, winuser_),
  };
  MemoryDeviceInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemoryDeviceInfoList_descriptor_,
      MemoryDeviceInfoList::default_instance_,
      MemoryDeviceInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryDeviceInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemoryDeviceInfoList));
  MemoryInfo_descriptor_ = file->message_type(26);
  static const int MemoryInfo_offsets_[32] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, formfactor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, interleavedatadepth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, interleaveposition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, memorytype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, positioninrow_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, totalwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, typedetail_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, poweredon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, banklabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, devicelocator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, otheridentifyinginfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, partnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, sku_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, datawidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, buyname_),
  };
  MemoryInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemoryInfo_descriptor_,
      MemoryInfo::default_instance_,
      MemoryInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemoryInfo));
  MemoryInfoList_descriptor_ = file->message_type(27);
  static const int MemoryInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfoList, winuser_),
  };
  MemoryInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemoryInfoList_descriptor_,
      MemoryInfoList::default_instance_,
      MemoryInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemoryInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemoryInfoList));
  MouseInfo_descriptor_ = file->message_type(28);
  static const int MouseInfo_offsets_[28] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, doublespeedthreshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, handedness_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, numberofbuttons_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, pointingtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, quadspeedthreshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, resolution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, samplerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, synch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, islocked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, hardwaretype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, inffilename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, infsection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, deviceinterface_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, buyname_),
  };
  MouseInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MouseInfo_descriptor_,
      MouseInfo::default_instance_,
      MouseInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MouseInfo));
  MouseInfoList_descriptor_ = file->message_type(29);
  static const int MouseInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfoList, winuser_),
  };
  MouseInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MouseInfoList_descriptor_,
      MouseInfoList::default_instance_,
      MouseInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MouseInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MouseInfoList));
  NetWorkAdapterInfo_descriptor_ = file->message_type(30);
  static const int NetWorkAdapterInfo_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, maxnumbercontrolled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, adaptertype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, macaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, productname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, servicename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, adaptertypeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, buyname_),
  };
  NetWorkAdapterInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetWorkAdapterInfo_descriptor_,
      NetWorkAdapterInfo::default_instance_,
      NetWorkAdapterInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetWorkAdapterInfo));
  NetWorkAdapterInfoList_descriptor_ = file->message_type(31);
  static const int NetWorkAdapterInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfoList, winuser_),
  };
  NetWorkAdapterInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetWorkAdapterInfoList_descriptor_,
      NetWorkAdapterInfoList::default_instance_,
      NetWorkAdapterInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetWorkAdapterInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetWorkAdapterInfoList));
  PhysicalDiskDriversInfo_descriptor_ = file->message_type(32);
  static const int PhysicalDiskDriversInfo_offsets_[43] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, defaultblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, maxblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, maxmediasize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, minblocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, numberofmediasupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, partitions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, scsibus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, scsilogicalunit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, scsiport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, scsitargetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, sectorspertrack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, totalcylinders_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, totalheads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, totalsectors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, totaltracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, trackspercylinder_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, medialoaded_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, needscleaning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, compressionmethod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, firmwarerevision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, interfacetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, mediatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, bytespersector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, buyname_),
  };
  PhysicalDiskDriversInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhysicalDiskDriversInfo_descriptor_,
      PhysicalDiskDriversInfo::default_instance_,
      PhysicalDiskDriversInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhysicalDiskDriversInfo));
  PhysicalDiskDriversInfoList_descriptor_ = file->message_type(33);
  static const int PhysicalDiskDriversInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfoList, winuser_),
  };
  PhysicalDiskDriversInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhysicalDiskDriversInfoList_descriptor_,
      PhysicalDiskDriversInfoList::default_instance_,
      PhysicalDiskDriversInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalDiskDriversInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhysicalDiskDriversInfoList));
  PhysicalMediaInfo_descriptor_ = file->message_type(34);
  static const int PhysicalMediaInfo_offsets_[28] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, cleanermedia_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, hotswappable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, poweredon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, removable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, replaceable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, writeprotecton_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, mediadescription_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, otheridentifyinginfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, partnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, sku_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, serialnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, mediatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, buyname_),
  };
  PhysicalMediaInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhysicalMediaInfo_descriptor_,
      PhysicalMediaInfo::default_instance_,
      PhysicalMediaInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhysicalMediaInfo));
  PhysicalMediaInfoList_descriptor_ = file->message_type(35);
  static const int PhysicalMediaInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfoList, winuser_),
  };
  PhysicalMediaInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhysicalMediaInfoList_descriptor_,
      PhysicalMediaInfoList::default_instance_,
      PhysicalMediaInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhysicalMediaInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhysicalMediaInfoList));
  USBControllerInfo_descriptor_ = file->message_type(36);
  static const int USBControllerInfo_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, protocolsupported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, maxnumbercontrolled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, buyname_),
  };
  USBControllerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      USBControllerInfo_descriptor_,
      USBControllerInfo::default_instance_,
      USBControllerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(USBControllerInfo));
  USBControllerInfoList_descriptor_ = file->message_type(37);
  static const int USBControllerInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfoList, winuser_),
  };
  USBControllerInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      USBControllerInfoList_descriptor_,
      USBControllerInfoList::default_instance_,
      USBControllerInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(USBControllerInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(USBControllerInfoList));
  VideoDisplayDeviceInfo_descriptor_ = file->message_type(38);
  static const int VideoDisplayDeviceInfo_offsets_[23] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, displaytype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, pixelsperxlogicalinch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, pixelsperylogicalinch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, screenheight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, screenwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, islocked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, monitormanufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, monitortype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, pnpdeviceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, availability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, bandwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, buytime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, buyprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, dchecktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, otherinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, buyname_),
  };
  VideoDisplayDeviceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VideoDisplayDeviceInfo_descriptor_,
      VideoDisplayDeviceInfo::default_instance_,
      VideoDisplayDeviceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VideoDisplayDeviceInfo));
  VideoDisplayDeviceInfoList_descriptor_ = file->message_type(39);
  static const int VideoDisplayDeviceInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfoList, winuser_),
  };
  VideoDisplayDeviceInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VideoDisplayDeviceInfoList_descriptor_,
      VideoDisplayDeviceInfoList::default_instance_,
      VideoDisplayDeviceInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VideoDisplayDeviceInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VideoDisplayDeviceInfoList));
  CltServiceInfo_descriptor_ = file->message_type(40);
  static const int CltServiceInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, service_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, dispaly_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, binary_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, discription_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, service_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, start_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, controls_accepted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, error_control_),
  };
  CltServiceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltServiceInfo_descriptor_,
      CltServiceInfo::default_instance_,
      CltServiceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltServiceInfo));
  CltServiceList_descriptor_ = file->message_type(41);
  static const int CltServiceList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceList, list_),
  };
  CltServiceList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltServiceList_descriptor_,
      CltServiceList::default_instance_,
      CltServiceList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltServiceList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltServiceList));
  CltProcessInfo_descriptor_ = file->message_type(42);
  static const int CltProcessInfo_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, process_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, session_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, process_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, win_user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, thread_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, priority_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, uprate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, downrate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, upcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, downcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, contcount_),
  };
  CltProcessInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltProcessInfo_descriptor_,
      CltProcessInfo::default_instance_,
      CltProcessInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltProcessInfo));
  CltProcessList_descriptor_ = file->message_type(43);
  static const int CltProcessList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessList, list_),
  };
  CltProcessList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltProcessList_descriptor_,
      CltProcessList::default_instance_,
      CltProcessList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltProcessList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltProcessList));
  CltUser_descriptor_ = file->message_type(44);
  static const int CltUser_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, full_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, profile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, lock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, disable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, userpsw_),
  };
  CltUser_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltUser_descriptor_,
      CltUser::default_instance_,
      CltUser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUser, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltUser));
  CltUserList_descriptor_ = file->message_type(45);
  static const int CltUserList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUserList, list_),
  };
  CltUserList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltUserList_descriptor_,
      CltUserList::default_instance_,
      CltUserList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUserList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltUserList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltUserList));
  CltGroup_descriptor_ = file->message_type(46);
  static const int CltGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroup, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroup, desc_),
  };
  CltGroup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltGroup_descriptor_,
      CltGroup::default_instance_,
      CltGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltGroup));
  CltGroupList_descriptor_ = file->message_type(47);
  static const int CltGroupList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroupList, list_),
  };
  CltGroupList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltGroupList_descriptor_,
      CltGroupList::default_instance_,
      CltGroupList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroupList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltGroupList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltGroupList));
  CltShareInfo_descriptor_ = file->message_type(48);
  static const int CltShareInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, netname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, remark_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, current_uses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, path_),
  };
  CltShareInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltShareInfo_descriptor_,
      CltShareInfo::default_instance_,
      CltShareInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltShareInfo));
  CltShareList_descriptor_ = file->message_type(49);
  static const int CltShareList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareList, list_),
  };
  CltShareList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltShareList_descriptor_,
      CltShareList::default_instance_,
      CltShareList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltShareList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltShareList));
  CltStartItem_descriptor_ = file->message_type(50);
  static const int CltStartItem_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartItem, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartItem, val_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartItem, path_),
  };
  CltStartItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltStartItem_descriptor_,
      CltStartItem::default_instance_,
      CltStartItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltStartItem));
  CltStartList_descriptor_ = file->message_type(51);
  static const int CltStartList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartList, list_),
  };
  CltStartList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltStartList_descriptor_,
      CltStartList::default_instance_,
      CltStartList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltStartList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltStartList));
  CltDiskInfo_descriptor_ = file->message_type(52);
  static const int CltDiskInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, total_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, free_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, vol_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, file_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, file_sno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, file_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, file_flag_),
  };
  CltDiskInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltDiskInfo_descriptor_,
      CltDiskInfo::default_instance_,
      CltDiskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltDiskInfo));
  CltDiskList_descriptor_ = file->message_type(53);
  static const int CltDiskList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskList, list_),
  };
  CltDiskList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CltDiskList_descriptor_,
      CltDiskList::default_instance_,
      CltDiskList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CltDiskList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CltDiskList));
  DeviceControlInfo_descriptor_ = file->message_type(54);
  static const int DeviceControlInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, devicedesc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, status_),
  };
  DeviceControlInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceControlInfo_descriptor_,
      DeviceControlInfo::default_instance_,
      DeviceControlInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceControlInfo));
  DeviceControlClassInfo_descriptor_ = file->message_type(55);
  static const int DeviceControlClassInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, classname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, guid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, imageindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, deviceinfolist_),
  };
  DeviceControlClassInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceControlClassInfo_descriptor_,
      DeviceControlClassInfo::default_instance_,
      DeviceControlClassInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceControlClassInfo));
  DeviceControlClassList_descriptor_ = file->message_type(56);
  static const int DeviceControlClassList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassList, computername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassList, deviceclasslist_),
  };
  DeviceControlClassList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeviceControlClassList_descriptor_,
      DeviceControlClassList::default_instance_,
      DeviceControlClassList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeviceControlClassList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DeviceControlClassList));
  FireWallInfo_descriptor_ = file->message_type(57);
  static const int FireWallInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FireWallInfo, enabled_),
  };
  FireWallInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FireWallInfo_descriptor_,
      FireWallInfo::default_instance_,
      FireWallInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FireWallInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FireWallInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FireWallInfo));
  DataBaseInfo_descriptor_ = file->message_type(58);
  static const int DataBaseInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, version_),
  };
  DataBaseInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataBaseInfo_descriptor_,
      DataBaseInfo::default_instance_,
      DataBaseInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataBaseInfo));
  DataBaseInfoList_descriptor_ = file->message_type(59);
  static const int DataBaseInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfoList, winuser_),
  };
  DataBaseInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataBaseInfoList_descriptor_,
      DataBaseInfoList::default_instance_,
      DataBaseInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataBaseInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataBaseInfoList));
  ODBCSourceInfo_descriptor_ = file->message_type(60);
  static const int ODBCSourceInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, addtime_),
  };
  ODBCSourceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ODBCSourceInfo_descriptor_,
      ODBCSourceInfo::default_instance_,
      ODBCSourceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ODBCSourceInfo));
  ODBCSourceInfoList_descriptor_ = file->message_type(61);
  static const int ODBCSourceInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfoList, winuser_),
  };
  ODBCSourceInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ODBCSourceInfoList_descriptor_,
      ODBCSourceInfoList::default_instance_,
      ODBCSourceInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCSourceInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ODBCSourceInfoList));
  ODBCDriverInfo_descriptor_ = file->message_type(62);
  static const int ODBCDriverInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, addtime_),
  };
  ODBCDriverInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ODBCDriverInfo_descriptor_,
      ODBCDriverInfo::default_instance_,
      ODBCDriverInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ODBCDriverInfo));
  ODBCDriverInfoList_descriptor_ = file->message_type(63);
  static const int ODBCDriverInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfoList, winuser_),
  };
  ODBCDriverInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ODBCDriverInfoList_descriptor_,
      ODBCDriverInfoList::default_instance_,
      ODBCDriverInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ODBCDriverInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ODBCDriverInfoList));
  AntiVirusSoftWareInfo_descriptor_ = file->message_type(64);
  static const int AntiVirusSoftWareInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, package_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, checktype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, scan_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, addtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, versionnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, status_),
  };
  AntiVirusSoftWareInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AntiVirusSoftWareInfo_descriptor_,
      AntiVirusSoftWareInfo::default_instance_,
      AntiVirusSoftWareInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AntiVirusSoftWareInfo));
  AntiVirusSoftWareInfoList_descriptor_ = file->message_type(65);
  static const int AntiVirusSoftWareInfoList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfoList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfoList, alarmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfoList, winuser_),
  };
  AntiVirusSoftWareInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AntiVirusSoftWareInfoList_descriptor_,
      AntiVirusSoftWareInfoList::default_instance_,
      AntiVirusSoftWareInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AntiVirusSoftWareInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AntiVirusSoftWareInfoList));
  DisposeSoftInfo_descriptor_ = file->message_type(66);
  static const int DisposeSoftInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, zippackname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, unzippath_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, runfilename_),
  };
  DisposeSoftInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DisposeSoftInfo_descriptor_,
      DisposeSoftInfo::default_instance_,
      DisposeSoftInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DisposeSoftInfo));
  DisposeSoftInfoList_descriptor_ = file->message_type(67);
  static const int DisposeSoftInfoList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfoList, list_),
  };
  DisposeSoftInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DisposeSoftInfoList_descriptor_,
      DisposeSoftInfoList::default_instance_,
      DisposeSoftInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisposeSoftInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DisposeSoftInfoList));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_appmessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CPUInfo_descriptor_, &CPUInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CPUInfoList_descriptor_, &CPUInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BIOSInfo_descriptor_, &BIOSInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BIOSInfoList_descriptor_, &BIOSInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CDRomDriveInfo_descriptor_, &CDRomDriveInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CDRomDriveInfoList_descriptor_, &CDRomDriveInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ComputerSystemInfo_descriptor_, &ComputerSystemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ComputerSystemInfoList_descriptor_, &ComputerSystemInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ComputerSystemProductInfo_descriptor_, &ComputerSystemProductInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ComputerSystemProductInfoList_descriptor_, &ComputerSystemProductInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DiskPartitionInfo_descriptor_, &DiskPartitionInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DiskPartitionInfoList_descriptor_, &DiskPartitionInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DisplayConfigurationInfo_descriptor_, &DisplayConfigurationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DisplayConfigurationInfoList_descriptor_, &DisplayConfigurationInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IDEControllerInfo_descriptor_, &IDEControllerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IDEControllerInfoList_descriptor_, &IDEControllerInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InstalledSofteware_descriptor_, &InstalledSofteware::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InstalledSoftewareList_descriptor_, &InstalledSoftewareList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyboardInfo_descriptor_, &KeyboardInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyboardInfoList_descriptor_, &KeyboardInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalDiskInfo_descriptor_, &LogicalDiskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogicalDiskInfoList_descriptor_, &LogicalDiskInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MainBoardInfo_descriptor_, &MainBoardInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MainBoardInfoList_descriptor_, &MainBoardInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemoryDeviceInfo_descriptor_, &MemoryDeviceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemoryDeviceInfoList_descriptor_, &MemoryDeviceInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemoryInfo_descriptor_, &MemoryInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemoryInfoList_descriptor_, &MemoryInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MouseInfo_descriptor_, &MouseInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MouseInfoList_descriptor_, &MouseInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetWorkAdapterInfo_descriptor_, &NetWorkAdapterInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetWorkAdapterInfoList_descriptor_, &NetWorkAdapterInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhysicalDiskDriversInfo_descriptor_, &PhysicalDiskDriversInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhysicalDiskDriversInfoList_descriptor_, &PhysicalDiskDriversInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhysicalMediaInfo_descriptor_, &PhysicalMediaInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhysicalMediaInfoList_descriptor_, &PhysicalMediaInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    USBControllerInfo_descriptor_, &USBControllerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    USBControllerInfoList_descriptor_, &USBControllerInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VideoDisplayDeviceInfo_descriptor_, &VideoDisplayDeviceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VideoDisplayDeviceInfoList_descriptor_, &VideoDisplayDeviceInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltServiceInfo_descriptor_, &CltServiceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltServiceList_descriptor_, &CltServiceList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltProcessInfo_descriptor_, &CltProcessInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltProcessList_descriptor_, &CltProcessList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltUser_descriptor_, &CltUser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltUserList_descriptor_, &CltUserList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltGroup_descriptor_, &CltGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltGroupList_descriptor_, &CltGroupList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltShareInfo_descriptor_, &CltShareInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltShareList_descriptor_, &CltShareList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltStartItem_descriptor_, &CltStartItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltStartList_descriptor_, &CltStartList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltDiskInfo_descriptor_, &CltDiskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CltDiskList_descriptor_, &CltDiskList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceControlInfo_descriptor_, &DeviceControlInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceControlClassInfo_descriptor_, &DeviceControlClassInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeviceControlClassList_descriptor_, &DeviceControlClassList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FireWallInfo_descriptor_, &FireWallInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataBaseInfo_descriptor_, &DataBaseInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataBaseInfoList_descriptor_, &DataBaseInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ODBCSourceInfo_descriptor_, &ODBCSourceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ODBCSourceInfoList_descriptor_, &ODBCSourceInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ODBCDriverInfo_descriptor_, &ODBCDriverInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ODBCDriverInfoList_descriptor_, &ODBCDriverInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AntiVirusSoftWareInfo_descriptor_, &AntiVirusSoftWareInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AntiVirusSoftWareInfoList_descriptor_, &AntiVirusSoftWareInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DisposeSoftInfo_descriptor_, &DisposeSoftInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DisposeSoftInfoList_descriptor_, &DisposeSoftInfoList::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_appmessage_2eproto() {
  delete CPUInfo::default_instance_;
  delete CPUInfo_reflection_;
  delete CPUInfoList::default_instance_;
  delete CPUInfoList_reflection_;
  delete BIOSInfo::default_instance_;
  delete BIOSInfo_reflection_;
  delete BIOSInfoList::default_instance_;
  delete BIOSInfoList_reflection_;
  delete CDRomDriveInfo::default_instance_;
  delete CDRomDriveInfo_reflection_;
  delete CDRomDriveInfoList::default_instance_;
  delete CDRomDriveInfoList_reflection_;
  delete ComputerSystemInfo::default_instance_;
  delete ComputerSystemInfo_reflection_;
  delete ComputerSystemInfoList::default_instance_;
  delete ComputerSystemInfoList_reflection_;
  delete ComputerSystemProductInfo::default_instance_;
  delete ComputerSystemProductInfo_reflection_;
  delete ComputerSystemProductInfoList::default_instance_;
  delete ComputerSystemProductInfoList_reflection_;
  delete DiskPartitionInfo::default_instance_;
  delete DiskPartitionInfo_reflection_;
  delete DiskPartitionInfoList::default_instance_;
  delete DiskPartitionInfoList_reflection_;
  delete DisplayConfigurationInfo::default_instance_;
  delete DisplayConfigurationInfo_reflection_;
  delete DisplayConfigurationInfoList::default_instance_;
  delete DisplayConfigurationInfoList_reflection_;
  delete IDEControllerInfo::default_instance_;
  delete IDEControllerInfo_reflection_;
  delete IDEControllerInfoList::default_instance_;
  delete IDEControllerInfoList_reflection_;
  delete InstalledSofteware::default_instance_;
  delete InstalledSofteware_reflection_;
  delete InstalledSoftewareList::default_instance_;
  delete InstalledSoftewareList_reflection_;
  delete KeyboardInfo::default_instance_;
  delete KeyboardInfo_reflection_;
  delete KeyboardInfoList::default_instance_;
  delete KeyboardInfoList_reflection_;
  delete LogicalDiskInfo::default_instance_;
  delete LogicalDiskInfo_reflection_;
  delete LogicalDiskInfoList::default_instance_;
  delete LogicalDiskInfoList_reflection_;
  delete MainBoardInfo::default_instance_;
  delete MainBoardInfo_reflection_;
  delete MainBoardInfoList::default_instance_;
  delete MainBoardInfoList_reflection_;
  delete MemoryDeviceInfo::default_instance_;
  delete MemoryDeviceInfo_reflection_;
  delete MemoryDeviceInfoList::default_instance_;
  delete MemoryDeviceInfoList_reflection_;
  delete MemoryInfo::default_instance_;
  delete MemoryInfo_reflection_;
  delete MemoryInfoList::default_instance_;
  delete MemoryInfoList_reflection_;
  delete MouseInfo::default_instance_;
  delete MouseInfo_reflection_;
  delete MouseInfoList::default_instance_;
  delete MouseInfoList_reflection_;
  delete NetWorkAdapterInfo::default_instance_;
  delete NetWorkAdapterInfo_reflection_;
  delete NetWorkAdapterInfoList::default_instance_;
  delete NetWorkAdapterInfoList_reflection_;
  delete PhysicalDiskDriversInfo::default_instance_;
  delete PhysicalDiskDriversInfo_reflection_;
  delete PhysicalDiskDriversInfoList::default_instance_;
  delete PhysicalDiskDriversInfoList_reflection_;
  delete PhysicalMediaInfo::default_instance_;
  delete PhysicalMediaInfo_reflection_;
  delete PhysicalMediaInfoList::default_instance_;
  delete PhysicalMediaInfoList_reflection_;
  delete USBControllerInfo::default_instance_;
  delete USBControllerInfo_reflection_;
  delete USBControllerInfoList::default_instance_;
  delete USBControllerInfoList_reflection_;
  delete VideoDisplayDeviceInfo::default_instance_;
  delete VideoDisplayDeviceInfo_reflection_;
  delete VideoDisplayDeviceInfoList::default_instance_;
  delete VideoDisplayDeviceInfoList_reflection_;
  delete CltServiceInfo::default_instance_;
  delete CltServiceInfo_reflection_;
  delete CltServiceList::default_instance_;
  delete CltServiceList_reflection_;
  delete CltProcessInfo::default_instance_;
  delete CltProcessInfo_reflection_;
  delete CltProcessList::default_instance_;
  delete CltProcessList_reflection_;
  delete CltUser::default_instance_;
  delete CltUser_reflection_;
  delete CltUserList::default_instance_;
  delete CltUserList_reflection_;
  delete CltGroup::default_instance_;
  delete CltGroup_reflection_;
  delete CltGroupList::default_instance_;
  delete CltGroupList_reflection_;
  delete CltShareInfo::default_instance_;
  delete CltShareInfo_reflection_;
  delete CltShareList::default_instance_;
  delete CltShareList_reflection_;
  delete CltStartItem::default_instance_;
  delete CltStartItem_reflection_;
  delete CltStartList::default_instance_;
  delete CltStartList_reflection_;
  delete CltDiskInfo::default_instance_;
  delete CltDiskInfo_reflection_;
  delete CltDiskList::default_instance_;
  delete CltDiskList_reflection_;
  delete DeviceControlInfo::default_instance_;
  delete DeviceControlInfo_reflection_;
  delete DeviceControlClassInfo::default_instance_;
  delete DeviceControlClassInfo_reflection_;
  delete DeviceControlClassList::default_instance_;
  delete DeviceControlClassList_reflection_;
  delete FireWallInfo::default_instance_;
  delete FireWallInfo_reflection_;
  delete DataBaseInfo::default_instance_;
  delete DataBaseInfo_reflection_;
  delete DataBaseInfoList::default_instance_;
  delete DataBaseInfoList_reflection_;
  delete ODBCSourceInfo::default_instance_;
  delete ODBCSourceInfo_reflection_;
  delete ODBCSourceInfoList::default_instance_;
  delete ODBCSourceInfoList_reflection_;
  delete ODBCDriverInfo::default_instance_;
  delete ODBCDriverInfo_reflection_;
  delete ODBCDriverInfoList::default_instance_;
  delete ODBCDriverInfoList_reflection_;
  delete AntiVirusSoftWareInfo::default_instance_;
  delete AntiVirusSoftWareInfo_reflection_;
  delete AntiVirusSoftWareInfoList::default_instance_;
  delete AntiVirusSoftWareInfoList_reflection_;
  delete DisposeSoftInfo::default_instance_;
  delete DisposeSoftInfo_reflection_;
  delete DisposeSoftInfoList::default_instance_;
  delete DisposeSoftInfoList_reflection_;
}

void protobuf_AddDesc_appmessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020appmessage.proto\022\010isafetec\"\241\005\n\007CPUInfo"
    "\022\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001("
    "\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\024\n"
    "\014Architecture\030\004 \001(\005\022\024\n\014Availability\030\005 \001("
    "\005\022\031\n\021CurrentClockSpeed\030\006 \001(\005\022\026\n\016CurrentV"
    "oltage\030\007 \001(\005\022\021\n\tDataWidth\030\010 \001(\005\022\020\n\010ExtCl"
    "ock\030\t \001(\005\022\016\n\006Family\030\n \001(\005\022\024\n\014L2CacheSpee"
    "d\030\013 \001(\005\022\023\n\013L3CacheSize\030\014 \001(\005\022\024\n\014L3CacheS"
    "peed\030\r \001(\005\022\025\n\rMaxClockSpeed\030\016 \001(\005\022\026\n\016Loa"
    "dPercentage\030\017 \001(\005\022\025\n\rProcessorType\030\020 \001(\005"
    "\022\023\n\013L2CacheSize\030\021 \001(\005\022\017\n\007Version\030\022 \001(\t\022\023"
    "\n\013Description\030\023 \001(\t\022\024\n\014AddressWidth\030\024 \001("
    "\005\022\024\n\014Manufacturer\030\025 \001(\t\022\014\n\004Name\030\026 \001(\t\022\023\n"
    "\013ProcessorId\030\027 \001(\t\022\014\n\004Role\030\030 \001(\t\022\031\n\021Sock"
    "etDesignation\030\031 \001(\t\022\016\n\006Status\030\032 \001(\t\022\020\n\010S"
    "tepping\030\033 \001(\t\022\017\n\007BuyTime\030\034 \001(\001\022\020\n\010BuyPri"
    "ce\030\035 \001(\t\022\022\n\nDCheckTime\030\036 \001(\001\022\021\n\tOtherInf"
    "o\030\037 \001(\t\022\017\n\007BuyName\030  \001(\t\"P\n\013CPUInfoList\022"
    "\037\n\004list\030\001 \003(\0132\021.isafetec.CPUInfo\022\017\n\007alar"
    "med\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\366\004\n\010BIOSInfo\022"
    "\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005"
    "\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\035\n\025"
    "TargetOperatingSystem\030\004 \001(\005\022\034\n\024SoftwareE"
    "lementState\030\005 \001(\005\022\023\n\013PrimaryBIOS\030\006 \001(\005\022\025"
    "\n\rSMBIOSPresent\030\007 \001(\005\022\023\n\013BuildNumber\030\010 \001"
    "(\t\022\017\n\007CodeSet\030\t \001(\t\022\027\n\017CurrentLanguage\030\n"
    " \001(\t\022\023\n\013Description\030\013 \001(\t\022\032\n\022Identificat"
    "ionCode\030\014 \001(\t\022\027\n\017LanguageEdition\030\r \001(\t\022\024"
    "\n\014Manufacturer\030\016 \001(\t\022\025\n\rOtherTargetOS\030\017 "
    "\001(\t\022\024\n\014SerialNumber\030\020 \001(\t\022\031\n\021SMBIOSBIOSV"
    "ersion\030\021 \001(\t\022\031\n\021SoftwareElementID\030\022 \001(\t\022"
    "\016\n\006Status\030\023 \001(\t\022\017\n\007Version\030\024 \001(\t\022\032\n\022SMBI"
    "OSMajorVersion\030\025 \001(\005\022\032\n\022SMBIOSMinorVersi"
    "on\030\026 \001(\005\022\017\n\007BuyTime\030\027 \001(\001\022\020\n\010BuyPrice\030\030 "
    "\001(\t\022\022\n\nDCheckTime\030\031 \001(\001\022\021\n\tOtherInfo\030\032 \001"
    "(\t\022\017\n\007BuyName\030\033 \001(\t\"R\n\014BIOSInfoList\022 \n\004l"
    "ist\030\001 \003(\0132\022.isafetec.BIOSInfo\022\017\n\007alarmed"
    "\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\251\006\n\016CDRomDriveIn"
    "fo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002 "
    "\001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022"
    "\031\n\021FileSystemFlagsEx\030\004 \001(\005\022\024\n\014MaxBlockSi"
    "ze\030\005 \001(\004\022\036\n\026MaximumComponentLength\030\006 \001(\005"
    "\022\024\n\014MaxMediaSize\030\007 \001(\004\022\024\n\014MinBlockSize\030\010"
    " \001(\004\022\036\n\026NumberOfMediaSupported\030\t \001(\005\022\017\n\007"
    "SCSIBus\030\n \001(\005\022\027\n\017SCSILogicalUnit\030\013 \001(\005\022\020"
    "\n\010SCSIPort\030\014 \001(\005\022\024\n\014SCSITargetId\030\r \001(\005\022\024"
    "\n\014SerialNumber\030\016 \001(\005\022\014\n\004Size\030\017 \001(\004\022\024\n\014Tr"
    "ansferRate\030\021 \001(\005\022\026\n\016DriveIntegrity\030\022 \001(\005"
    "\022\023\n\013MediaLoaded\030\023 \001(\005\022\025\n\rNeedsCleaning\030\024"
    " \001(\005\022\031\n\021CompressionMethod\030\025 \001(\t\022\023\n\013Descr"
    "iption\030\026 \001(\t\022\r\n\005Drive\030\027 \001(\t\022\024\n\014Manufactu"
    "rer\030\030 \001(\t\022\021\n\tMediaType\030\031 \001(\t\022\023\n\013PNPDevic"
    "eID\030\032 \001(\t\022\025\n\rRevisionLevel\030\033 \001(\t\022\016\n\006Stat"
    "us\030\034 \001(\t\022\022\n\nVolumeName\030\035 \001(\t\022\032\n\022VolumeSe"
    "rialNumber\030\036 \001(\t\022\024\n\014Availability\030\037 \001(\005\022\030"
    "\n\020DefaultBlockSize\030  \001(\005\022\017\n\007BuyTime\030! \001("
    "\001\022\020\n\010BuyPrice\030\" \001(\t\022\022\n\nDCheckTime\030# \001(\001\022"
    "\021\n\tOtherInfo\030$ \001(\t\022\017\n\007BuyName\030% \001(\t\"^\n\022C"
    "DRomDriveInfoList\022&\n\004list\030\001 \003(\0132\030.isafet"
    "ec.CDRomDriveInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007wi"
    "nuser\030\003 \001(\t\"\217\010\n\022ComputerSystemInfo\022\024\n\014pa"
    "ckage_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\ts"
    "can_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\022\n\nDomai"
    "nRole\030\004 \001(\005\022\035\n\025FrontPanelResetStatus\030\005 \001"
    "(\005\022\036\n\026KeyboardPasswordStatus\030\006 \001(\005\022\035\n\025Po"
    "werOnPasswordStatus\030\007 \001(\005\022\022\n\nPowerState\030"
    "\010 \001(\005\022\030\n\020PowerSupplyState\030\t \001(\005\022\027\n\017Reset"
    "Capability\030\n \001(\005\022\032\n\022SystemStartupDelay\030\013"
    " \001(\005\022\024\n\014ThermalState\030\014 \001(\005\022\022\n\nWakeUpType"
    "\030\r \001(\005\022\027\n\017CurrentTimeZone\030\016 \001(\005\022\022\n\nReset"
    "Count\030\017 \001(\005\022\022\n\nResetLimit\030\020 \001(\005\022\032\n\022Numbe"
    "rOfProcessors\030\021 \001(\005\022\033\n\023TotalPhysicalMemo"
    "ry\030\022 \001(\004\022\027\n\017PauseAfterReset\030\023 \001(\003\022 \n\030Aut"
    "omaticResetBootOption\030\024 \001(\005\022 \n\030Automatic"
    "ResetCapability\030\025 \001(\005\022\030\n\020BootROMSupporte"
    "d\030\026 \001(\005\022!\n\031EnableDaylightSavingsTime\030\027 \001"
    "(\005\022\031\n\021InfraredSupported\030\030 \001(\005\022 \n\030Network"
    "ServerModeEnabled\030\031 \001(\005\022\024\n\014PartOfDomain\030"
    "\032 \001(\005\022\034\n\024SystemStartupSetting\030\033 \001(\005\022\023\n\013B"
    "ootupState\030\034 \001(\t\022\023\n\013Description\030\036 \001(\t\022\023\n"
    "\013DNSHostName\030\037 \001(\t\022\016\n\006Domain\030! \001(\t\022\024\n\014Ma"
    "nufacturer\030\" \001(\t\022\r\n\005Model\030# \001(\t\022\030\n\020Prima"
    "ryOwnerName\030$ \001(\t\022\r\n\005Roles\030% \001(\t\022\016\n\006Stat"
    "us\030& \001(\t\022\034\n\024SystemStartupOptions\030\' \001(\t\022\022"
    "\n\nSystemType\030( \001(\t\022\020\n\010UserName\030) \001(\t\022\033\n\023"
    "AdminPasswordStatus\030* \001(\005\022\032\n\022ChassisBoot"
    "upState\030+ \001(\005\"f\n\026ComputerSystemInfoList\022"
    "*\n\004list\030\001 \003(\0132\034.isafetec.ComputerSystemI"
    "nfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\307\001"
    "\n\031ComputerSystemProductInfo\022\024\n\014package_c"
    "ode\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_tim"
    "e\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\031\n\021IdentifyingN"
    "umber\030\004 \001(\t\022\014\n\004Name\030\005 \001(\t\022\016\n\006Vendor\030\006 \001("
    "\t\022\017\n\007Version\030\007 \001(\t\022\023\n\013Description\030\010 \001(\t\""
    "t\n\035ComputerSystemProductInfoList\0221\n\004list"
    "\030\001 \003(\0132#.isafetec.ComputerSystemProductI"
    "nfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\321\002"
    "\n\021DiskPartitionInfo\022\024\n\014package_code\030\001 \001("
    "\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022"
    "\017\n\007addtime\0302 \001(\001\022\021\n\tBlockSize\030\004 \001(\004\022\026\n\016N"
    "umberOfBlocks\030\005 \001(\004\022\014\n\004Size\030\006 \001(\004\022\026\n\016Sta"
    "rtingOffset\030\007 \001(\004\022\023\n\013Description\030\n \001(\t\022\014"
    "\n\004Name\030\013 \001(\t\022\021\n\tDiskIndex\030\014 \001(\005\022\r\n\005Index"
    "\030\r \001(\005\022\017\n\007BuyTime\030\016 \001(\001\022\020\n\010BuyPrice\030\017 \001("
    "\t\022\022\n\nDCheckTime\030\020 \001(\001\022\021\n\tOtherInfo\030\021 \001(\t"
    "\022\017\n\007BuyName\030\022 \001(\t\"d\n\025DiskPartitionInfoLi"
    "st\022)\n\004list\030\001 \003(\0132\033.isafetec.DiskPartitio"
    "nInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\""
    "\331\003\n\030DisplayConfigurationInfo\022\024\n\014package_"
    "code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_ti"
    "me\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\030\n\020DisplayFreq"
    "uency\030\004 \001(\005\022\022\n\nDitherType\030\005 \001(\005\022\021\n\tICMIn"
    "tent\030\006 \001(\005\022\021\n\tICMMethod\030\007 \001(\005\022\021\n\tLogPixe"
    "ls\030\010 \001(\005\022\022\n\nPelsHeight\030\t \001(\005\022\021\n\tPelsWidt"
    "h\030\n \001(\005\022\034\n\024SpecificationVersion\030\013 \001(\005\022\023\n"
    "\013Description\030\r \001(\t\022\022\n\nDeviceName\030\016 \001(\t\022\025"
    "\n\rDriverVersion\030\017 \001(\t\022\023\n\013BitsPerPerl\030\020 \001"
    "(\005\022\024\n\014DisplayFlags\030\021 \001(\005\022\017\n\007BuyTime\030\022 \001("
    "\001\022\020\n\010BuyPrice\030\023 \001(\t\022\022\n\nDCheckTime\030\024 \001(\001\022"
    "\021\n\tOtherInfo\030\025 \001(\t\022\017\n\007BuyName\030\026 \001(\t\"r\n\034D"
    "isplayConfigurationInfoList\0220\n\004list\030\001 \003("
    "\0132\".isafetec.DisplayConfigurationInfo\022\017\n"
    "\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\347\002\n\021IDEC"
    "ontrollerInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tc"
    "hecktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007add"
    "time\0302 \001(\001\022\033\n\023MaxNumberControlled\030\007 \001(\005\022"
    "\023\n\013Description\030\n \001(\t\022\024\n\014Manufacturer\030\014 \001"
    "(\t\022\014\n\004Name\030\r \001(\t\022\023\n\013PNPDeviceID\030\016 \001(\t\022\016\n"
    "\006Status\030\017 \001(\t\022\024\n\014Availability\030\020 \001(\005\022\031\n\021P"
    "rotocolSupported\030\021 \001(\005\022\017\n\007BuyTime\030\022 \001(\001\022"
    "\020\n\010BuyPrice\030\023 \001(\t\022\022\n\nDCheckTime\030\024 \001(\001\022\021\n"
    "\tOtherInfo\030\025 \001(\t\022\017\n\007BuyName\030\026 \001(\t\"d\n\025IDE"
    "ControllerInfoList\022)\n\004list\030\001 \003(\0132\033.isafe"
    "tec.IDEControllerInfo\022\017\n\007alarmed\030\002 \001(\005\022\017"
    "\n\007winuser\030\003 \001(\t\"\356\001\n\022InstalledSofteware\022\024"
    "\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022"
    "\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\024\n\014m"
    "anufacturer\030\004 \001(\t\022\026\n\016installed_path\030\005 \001("
    "\t\022\017\n\007version\030\006 \001(\t\022\026\n\016installed_time\030\007 \001"
    "(\t\022\021\n\thelp_link\030\010 \001(\t\022\014\n\004name\030\t \001(\t\022\023\n\013d"
    "escription\030\n \001(\t\"f\n\026InstalledSoftewareLi"
    "st\022*\n\004list\030\001 \003(\0132\034.isafetec.InstalledSof"
    "teware\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t"
    "\"\346\002\n\014KeyboardInfo\022\024\n\014package_code\030\001 \001(\t\022"
    "\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n"
    "\007addtime\0302 \001(\001\022\020\n\010Password\030\004 \001(\005\022\020\n\010IsLo"
    "cked\030\006 \001(\005\022\023\n\013Description\030\007 \001(\t\022\016\n\006Layou"
    "t\030\010 \001(\t\022\014\n\004Name\030\t \001(\t\022\023\n\013PNPDeviceID\030\n \001"
    "(\t\022\016\n\006Status\030\013 \001(\t\022\024\n\014Availability\030\014 \001(\005"
    "\022\034\n\024NumberOfFunctionKeys\030\r \001(\005\022\017\n\007BuyTim"
    "e\030\016 \001(\001\022\020\n\010BuyPrice\030\017 \001(\t\022\022\n\nDCheckTime\030"
    "\020 \001(\001\022\021\n\tOtherInfo\030\021 \001(\t\022\017\n\007BuyName\030\022 \001("
    "\t\"Z\n\020KeyboardInfoList\022$\n\004list\030\001 \003(\0132\026.is"
    "afetec.KeyboardInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007"
    "winuser\030\003 \001(\t\"\225\004\n\017LogicalDiskInfo\022\024\n\014pac"
    "kage_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tsc"
    "an_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\021\n\tMediaT"
    "ype\030\004 \001(\005\022\021\n\tFreeSpace\030\005 \001(\004\022\014\n\004Size\030\006 \001"
    "(\004\022\026\n\016QuotasDisabled\030\007 \001(\005\022\030\n\020QuotasInco"
    "mplete\030\010 \001(\005\022\030\n\020QuotasRebuilding\030\t \001(\005\022\032"
    "\n\022SupportsDiskQuotas\030\n \001(\005\022$\n\034SupportsFi"
    "leBasedCompression\030\013 \001(\005\022\023\n\013Description\030"
    "\016 \001(\t\022\022\n\nFileSystem\030\017 \001(\t\022\014\n\004Name\030\020 \001(\t\022"
    "\022\n\nVolumeName\030\023 \001(\t\022\032\n\022VolumeSerialNumbe"
    "r\030\024 \001(\t\022\021\n\tDriveType\030\025 \001(\005\022\036\n\026MaximumCom"
    "ponentLength\030\026 \001(\005\022\017\n\007BuyTime\030\027 \001(\001\022\020\n\010B"
    "uyPrice\030\030 \001(\t\022\022\n\nDCheckTime\030\031 \001(\001\022\021\n\tOth"
    "erInfo\030\032 \001(\t\022\017\n\007BuyName\030\033 \001(\t\"`\n\023Logical"
    "DiskInfoList\022\'\n\004list\030\001 \003(\0132\031.isafetec.Lo"
    "gicalDiskInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuse"
    "r\030\003 \001(\t\"\273\003\n\rMainBoardInfo\022\024\n\014package_cod"
    "e\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_time\030"
    "\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\r\n\005Model\030\004 \001(\t\022\034\n"
    "\024OtherIdentifyingInfo\030\005 \001(\t\022\022\n\nPartNumbe"
    "r\030\006 \001(\t\022\017\n\007Product\030\007 \001(\t\022\037\n\027Requirements"
    "Description\030\010 \001(\t\022\024\n\014SerialNumber\030\t \001(\t\022"
    "\013\n\003SKU\030\n \001(\t\022\022\n\nSlotLayout\030\013 \001(\t\022\016\n\006Stat"
    "us\030\014 \001(\t\022\017\n\007Version\030\r \001(\t\022\014\n\004Name\030\016 \001(\t\022"
    "\023\n\013Description\030\017 \001(\t\022\024\n\014Manufacturer\030\020 \001"
    "(\t\022\017\n\007BuyTime\030\021 \001(\001\022\020\n\010BuyPrice\030\022 \001(\t\022\022\n"
    "\nDCheckTime\030\023 \001(\001\022\021\n\tOtherInfo\030\024 \001(\t\022\017\n\007"
    "BuyName\030\025 \001(\t\"\\\n\021MainBoardInfoList\022%\n\004li"
    "st\030\001 \003(\0132\027.isafetec.MainBoardInfo\022\017\n\007ala"
    "rmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\215\002\n\020MemoryDe"
    "viceInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tcheckt"
    "ype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\030"
    "2 \001(\001\022\025\n\rEndingAddress\030\004 \001(\004\022\027\n\017Starting"
    "Address\030\005 \001(\004\022\023\n\013Description\030\006 \001(\t\022\014\n\004Na"
    "me\030\007 \001(\t\022\017\n\007BuyTime\030\010 \001(\001\022\020\n\010BuyPrice\030\t "
    "\001(\t\022\022\n\nDCheckTime\030\n \001(\001\022\021\n\tOtherInfo\030\013 \001"
    "(\t\022\017\n\007BuyName\030\014 \001(\t\"b\n\024MemoryDeviceInfoL"
    "ist\022(\n\004list\030\001 \003(\0132\032.isafetec.MemoryDevic"
    "eInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\""
    "\203\005\n\nMemoryInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\t"
    "checktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007ad"
    "dtime\0302 \001(\001\022\022\n\nFormFactor\030\004 \001(\005\022\033\n\023Inter"
    "leaveDataDepth\030\005 \001(\005\022\032\n\022InterleavePositi"
    "on\030\006 \001(\005\022\022\n\nMemoryType\030\007 \001(\005\022\025\n\rPosition"
    "InRow\030\010 \001(\005\022\r\n\005Speed\030\t \001(\005\022\022\n\nTotalWidth"
    "\030\n \001(\005\022\022\n\nTypeDetail\030\013 \001(\005\022\021\n\tPoweredOn\030"
    "\014 \001(\005\022\021\n\tBankLabel\030\r \001(\t\022\023\n\013Description\030"
    "\016 \001(\t\022\025\n\rDeviceLocator\030\017 \001(\t\022\024\n\014Manufact"
    "urer\030\020 \001(\t\022\r\n\005Model\030\021 \001(\t\022\014\n\004Name\030\022 \001(\t\022"
    "\034\n\024OtherIdentifyingInfo\030\023 \001(\t\022\022\n\nPartNum"
    "ber\030\024 \001(\t\022\024\n\014SerialNumber\030\025 \001(\t\022\013\n\003SKU\030\026"
    " \001(\t\022\016\n\006Status\030\027 \001(\t\022\017\n\007Version\030\030 \001(\t\022\020\n"
    "\010Capacity\030\031 \001(\004\022\021\n\tDataWidth\030\032 \001(\005\022\017\n\007Bu"
    "yTime\030\033 \001(\001\022\020\n\010BuyPrice\030\034 \001(\t\022\022\n\nDCheckT"
    "ime\030\035 \001(\001\022\021\n\tOtherInfo\030\036 \001(\t\022\017\n\007BuyName\030"
    "\037 \001(\t\"V\n\016MemoryInfoList\022\"\n\004list\030\001 \003(\0132\024."
    "isafetec.MemoryInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007"
    "winuser\030\003 \001(\t\"\305\004\n\tMouseInfo\022\024\n\014package_c"
    "ode\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_tim"
    "e\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\034\n\024DoubleSpeedT"
    "hreshold\030\004 \001(\005\022\022\n\nHandedness\030\005 \001(\005\022\027\n\017Nu"
    "mberOfButtons\030\006 \001(\005\022\024\n\014PointingType\030\007 \001("
    "\005\022\032\n\022QuadSpeedThreshold\030\010 \001(\005\022\022\n\nResolut"
    "ion\030\t \001(\005\022\022\n\nSampleRate\030\n \001(\005\022\r\n\005Synch\030\014"
    " \001(\005\022\020\n\010IsLocked\030\r \001(\005\022\023\n\013Description\030\016 "
    "\001(\t\022\024\n\014HardwareType\030\020 \001(\t\022\023\n\013InfFileName"
    "\030\021 \001(\t\022\022\n\nInfSection\030\022 \001(\t\022\024\n\014Manufactur"
    "er\030\023 \001(\t\022\014\n\004Name\030\024 \001(\t\022\023\n\013PNPDeviceID\030\025 "
    "\001(\t\022\016\n\006Status\030\026 \001(\t\022\024\n\014Availability\030\027 \001("
    "\005\022\027\n\017DeviceInterface\030\030 \001(\005\022\017\n\007BuyTime\030\031 "
    "\001(\001\022\020\n\010BuyPrice\030\032 \001(\t\022\022\n\nDCheckTime\030\033 \001("
    "\001\022\021\n\tOtherInfo\030\034 \001(\t\022\017\n\007BuyName\030\035 \001(\t\"T\n"
    "\rMouseInfoList\022!\n\004list\030\001 \003(\0132\023.isafetec."
    "MouseInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 "
    "\001(\t\"\212\003\n\022NetWorkAdapterInfo\022\024\n\014package_co"
    "de\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_time"
    "\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\033\n\023MaxNumberCont"
    "rolled\030\004 \001(\005\022\023\n\013AdapterType\030\005 \001(\t\022\023\n\013Des"
    "cription\030\007 \001(\t\022\014\n\004Name\030\010 \001(\t\022\022\n\nMACAddre"
    "ss\030\n \001(\t\022\023\n\013ProductName\030\013 \001(\t\022\023\n\013Service"
    "Name\030\014 \001(\t\022\023\n\013PNPDeviceID\030\017 \001(\t\022\025\n\rAdapt"
    "erTypeID\030\020 \001(\005\022\r\n\005Index\030\021 \001(\005\022\017\n\007BuyTime"
    "\030\022 \001(\001\022\020\n\010BuyPrice\030\023 \001(\t\022\022\n\nDCheckTime\030\024"
    " \001(\001\022\021\n\tOtherInfo\030\025 \001(\t\022\017\n\007BuyName\030\026 \001(\t"
    "\"f\n\026NetWorkAdapterInfoList\022*\n\004list\030\001 \003(\013"
    "2\034.isafetec.NetWorkAdapterInfo\022\017\n\007alarme"
    "d\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\232\007\n\027PhysicalDis"
    "kDriversInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tch"
    "ecktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addt"
    "ime\0302 \001(\001\022\030\n\020DefaultBlockSize\030\004 \001(\004\022\r\n\005I"
    "ndex\030\005 \001(\005\022\024\n\014MaxBlockSize\030\006 \001(\004\022\024\n\014MaxM"
    "ediaSize\030\007 \001(\004\022\024\n\014MinBlockSize\030\010 \001(\004\022\036\n\026"
    "NumberOfMediaSupported\030\t \001(\005\022\022\n\nPartitio"
    "ns\030\n \001(\005\022\017\n\007SCSIBus\030\013 \001(\005\022\027\n\017SCSILogical"
    "Unit\030\014 \001(\005\022\020\n\010SCSIPort\030\r \001(\005\022\024\n\014SCSITarg"
    "etId\030\016 \001(\005\022\027\n\017SectorsPerTrack\030\017 \001(\005\022\021\n\tS"
    "ignature\030\020 \001(\005\022\014\n\004Size\030\021 \001(\004\022\026\n\016TotalCyl"
    "inders\030\023 \001(\004\022\022\n\nTotalHeads\030\024 \001(\005\022\024\n\014Tota"
    "lSectors\030\025 \001(\004\022\023\n\013TotalTracks\030\026 \001(\004\022\031\n\021T"
    "racksPerCylinder\030\027 \001(\r\022\023\n\013MediaLoaded\030\030 "
    "\001(\r\022\025\n\rNeedsCleaning\030\031 \001(\005\022\031\n\021Compressio"
    "nMethod\030\032 \001(\t\022\023\n\013Description\030\033 \001(\t\022\030\n\020Fi"
    "rmwareRevision\030\034 \001(\t\022\025\n\rInterfaceType\030\035 "
    "\001(\t\022\024\n\014Manufacturer\030\036 \001(\t\022\021\n\tMediaType\030\037"
    " \001(\t\022\r\n\005Model\030  \001(\t\022\014\n\004Name\030! \001(\t\022\023\n\013PNP"
    "DeviceID\030\" \001(\t\022\024\n\014SerialNumber\030# \001(\t\022\016\n\006"
    "Status\030$ \001(\t\022\024\n\014Availability\030% \001(\005\022\026\n\016By"
    "tesPerSector\030& \001(\005\022\017\n\007BuyTime\030\' \001(\001\022\020\n\010B"
    "uyPrice\030( \001(\t\022\022\n\nDCheckTime\030) \001(\001\022\021\n\tOth"
    "erInfo\030* \001(\t\022\017\n\007BuyName\030+ \001(\t\"p\n\033Physica"
    "lDiskDriversInfoList\022/\n\004list\030\001 \003(\0132!.isa"
    "fetec.PhysicalDiskDriversInfo\022\017\n\007alarmed"
    "\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"\267\004\n\021PhysicalMedi"
    "aInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype"
    "\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001"
    "(\001\022\024\n\014CleanerMedia\030\004 \001(\005\022\024\n\014HotSwappable"
    "\030\005 \001(\005\022\021\n\tPoweredOn\030\006 \001(\005\022\021\n\tRemovable\030\007"
    " \001(\005\022\023\n\013Replaceable\030\010 \001(\005\022\026\n\016WriteProtec"
    "tOn\030\t \001(\005\022\023\n\013Description\030\n \001(\t\022\024\n\014Manufa"
    "cturer\030\013 \001(\t\022\030\n\020MediaDescription\030\014 \001(\t\022\r"
    "\n\005Model\030\r \001(\t\022\014\n\004Name\030\016 \001(\t\022\034\n\024OtherIden"
    "tifyingInfo\030\017 \001(\t\022\022\n\nPartNumber\030\020 \001(\t\022\013\n"
    "\003SKU\030\021 \001(\t\022\016\n\006Status\030\022 \001(\t\022\017\n\007Version\030\023 "
    "\001(\t\022\024\n\014SerialNumber\030\024 \001(\t\022\020\n\010Capacity\030\025 "
    "\001(\005\022\021\n\tMediaType\030\026 \001(\005\022\017\n\007BuyTime\030\027 \001(\001\022"
    "\020\n\010BuyPrice\030\030 \001(\t\022\022\n\nDCheckTime\030\031 \001(\001\022\021\n"
    "\tOtherInfo\030\032 \001(\t\022\017\n\007BuyName\030\033 \001(\t\"d\n\025Phy"
    "sicalMediaInfoList\022)\n\004list\030\001 \003(\0132\033.isafe"
    "tec.PhysicalMediaInfo\022\017\n\007alarmed\030\002 \001(\005\022\017"
    "\n\007winuser\030\003 \001(\t\"\347\002\n\021USBControllerInfo\022\024\n"
    "\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021"
    "\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\024\n\014Av"
    "ailability\030\004 \001(\005\022\031\n\021ProtocolSupported\030\005 "
    "\001(\005\022\033\n\023MaxNumberControlled\030\007 \001(\005\022\023\n\013Desc"
    "ription\030\n \001(\t\022\024\n\014Manufacturer\030\013 \001(\t\022\014\n\004N"
    "ame\030\014 \001(\t\022\023\n\013PNPDeviceID\030\r \001(\t\022\016\n\006Status"
    "\030\016 \001(\t\022\017\n\007BuyTime\030\017 \001(\001\022\020\n\010BuyPrice\030\020 \001("
    "\t\022\022\n\nDCheckTime\030\021 \001(\001\022\021\n\tOtherInfo\030\022 \001(\t"
    "\022\017\n\007BuyName\030\023 \001(\t\"d\n\025USBControllerInfoLi"
    "st\022)\n\004list\030\001 \003(\0132\033.isafetec.USBControlle"
    "rInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\""
    "\363\003\n\026VideoDisplayDeviceInfo\022\024\n\014package_co"
    "de\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tscan_time"
    "\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\023\n\013DisplayType\030\004"
    " \001(\005\022\035\n\025PixelsPerXLogicalInch\030\005 \001(\005\022\035\n\025P"
    "ixelsPerYLogicalInch\030\006 \001(\005\022\024\n\014ScreenHeig"
    "ht\030\007 \001(\005\022\023\n\013ScreenWidth\030\010 \001(\005\022\020\n\010IsLocke"
    "d\030\n \001(\005\022\023\n\013Description\030\013 \001(\t\022\033\n\023MonitorM"
    "anufacturer\030\014 \001(\t\022\023\n\013MonitorType\030\r \001(\t\022\014"
    "\n\004Name\030\016 \001(\t\022\023\n\013PNPDeviceID\030\017 \001(\t\022\016\n\006Sta"
    "tus\030\020 \001(\t\022\024\n\014Availability\030\021 \001(\005\022\021\n\tBandw"
    "idth\030\022 \001(\005\022\017\n\007BuyTime\030\023 \001(\001\022\020\n\010BuyPrice\030"
    "\024 \001(\t\022\022\n\nDCheckTime\030\025 \001(\001\022\021\n\tOtherInfo\030\026"
    " \001(\t\022\017\n\007BuyName\030\027 \001(\t\"n\n\032VideoDisplayDev"
    "iceInfoList\022.\n\004list\030\001 \003(\0132 .isafetec.Vid"
    "eoDisplayDeviceInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007"
    "winuser\030\003 \001(\t\"\321\001\n\016CltServiceInfo\022\024\n\014serv"
    "ice_name\030\001 \001(\t\022\024\n\014dispaly_name\030\002 \001(\t\022\023\n\013"
    "binary_Path\030\003 \001(\t\022\023\n\013discription\030\004 \001(\t\022\024"
    "\n\014service_type\030\005 \001(\r\022\r\n\005state\030\006 \001(\r\022\022\n\ns"
    "tart_type\030\007 \001(\r\022\031\n\021controls_accepted\030\010 \001"
    "(\r\022\025\n\rerror_control\030\t \001(\r\"8\n\016CltServiceL"
    "ist\022&\n\004list\030\001 \003(\0132\030.isafetec.CltServiceI"
    "nfo\"\337\001\n\016CltProcessInfo\022\022\n\nprocess_id\030\001 \001"
    "(\005\022\022\n\nsession_id\030\002 \001(\005\022\024\n\014process_path\030\003"
    " \001(\t\022\020\n\010win_user\030\004 \001(\t\022\022\n\nthread_num\030\005 \001"
    "(\005\022\020\n\010priority\030\006 \001(\005\022\016\n\006upRate\030\007 \001(\005\022\020\n\010"
    "downRate\030\010 \001(\005\022\017\n\007upCount\030\t \001(\005\022\021\n\tdownC"
    "ount\030\n \001(\005\022\021\n\tcontCount\030\013 \001(\005\"8\n\016CltProc"
    "essList\022&\n\004list\030\001 \003(\0132\030.isafetec.CltProc"
    "essInfo\"\210\001\n\007CltUser\022\014\n\004name\030\001 \001(\t\022\014\n\004des"
    "c\030\002 \001(\t\022\021\n\tfull_name\030\003 \001(\t\022\017\n\007profile\030\004 "
    "\001(\t\022\r\n\005group\030\005 \001(\t\022\014\n\004lock\030\006 \001(\005\022\017\n\007disa"
    "ble\030\007 \001(\005\022\017\n\007userpsw\030\010 \001(\t\".\n\013CltUserLis"
    "t\022\037\n\004list\030\001 \003(\0132\021.isafetec.CltUser\"&\n\010Cl"
    "tGroup\022\014\n\004name\030\001 \001(\t\022\014\n\004desc\030\002 \001(\t\"0\n\014Cl"
    "tGroupList\022 \n\004list\030\001 \003(\0132\022.isafetec.CltG"
    "roup\"a\n\014CltShareInfo\022\017\n\007netname\030\001 \001(\t\022\014\n"
    "\004type\030\002 \001(\005\022\016\n\006remark\030\003 \001(\t\022\024\n\014current_u"
    "ses\030\004 \001(\005\022\014\n\004path\030\005 \001(\t\"4\n\014CltShareList\022"
    "$\n\004list\030\001 \003(\0132\026.isafetec.CltShareInfo\"7\n"
    "\014CltStartItem\022\014\n\004name\030\001 \001(\t\022\013\n\003val\030\002 \001(\t"
    "\022\014\n\004path\030\003 \001(\t\"4\n\014CltStartList\022$\n\004list\030\001"
    " \003(\0132\026.isafetec.CltStartItem\"\254\001\n\013CltDisk"
    "Info\022\014\n\004name\030\001 \001(\t\022\022\n\ntotal_size\030\002 \001(\t\022\021"
    "\n\tfree_size\030\003 \001(\t\022\014\n\004type\030\004 \001(\r\022\020\n\010vol_n"
    "ame\030\005 \001(\t\022\021\n\tfile_type\030\006 \001(\t\022\020\n\010file_sno"
    "\030\007 \001(\r\022\020\n\010file_max\030\010 \001(\r\022\021\n\tfile_flag\030\t "
    "\001(\r\"2\n\013CltDiskList\022#\n\004list\030\001 \003(\0132\025.isafe"
    "tec.CltDiskInfo\"W\n\021DeviceControlInfo\022\r\n\005"
    "index\030\001 \001(\005\022\017\n\007enabled\030\002 \001(\005\022\022\n\ndeviceDe"
    "sc\030\003 \001(\t\022\016\n\006status\030\004 \001(\005\"\202\001\n\026DeviceContr"
    "olClassInfo\022\021\n\tclassName\030\001 \001(\t\022\014\n\004guid\030\002"
    " \001(\t\022\022\n\nimageIndex\030\003 \001(\005\0223\n\016DeviceInfoli"
    "st\030\004 \003(\0132\033.isafetec.DeviceControlInfo\"i\n"
    "\026DeviceControlClassList\022\024\n\014computerName\030"
    "\001 \001(\t\0229\n\017DeviceClasslist\030\002 \003(\0132 .isafete"
    "c.DeviceControlClassInfo\"\037\n\014FireWallInfo"
    "\022\017\n\007enabled\030\001 \001(\005\"|\n\014DataBaseInfo\022\024\n\014pac"
    "kage_code\030\001 \001(\t\022\021\n\tchecktype\030\002 \001(\005\022\021\n\tsc"
    "an_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001\022\016\n\006status"
    "\030\004 \001(\t\022\017\n\007version\030\005 \001(\t\"Z\n\020DataBaseInfoL"
    "ist\022$\n\004list\030\001 \003(\0132\026.isafetec.DataBaseInf"
    "o\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"]\n\016O"
    "DBCSourceInfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tc"
    "hecktype\030\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007add"
    "time\0302 \001(\001\"^\n\022ODBCSourceInfoList\022&\n\004list"
    "\030\001 \003(\0132\030.isafetec.ODBCSourceInfo\022\017\n\007alar"
    "med\030\002 \001(\005\022\017\n\007winuser\030\003 \001(\t\"]\n\016ODBCDriver"
    "Info\022\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030"
    "\002 \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001("
    "\001\"^\n\022ODBCDriverInfoList\022&\n\004list\030\001 \003(\0132\030."
    "isafetec.ODBCDriverInfo\022\017\n\007alarmed\030\002 \001(\005"
    "\022\017\n\007winuser\030\003 \001(\t\"\231\001\n\025AntiVirusSoftWareI"
    "nfo\022\024\n\014package_code\030\001 \001(\t\022\021\n\tchecktype\030\002"
    " \001(\005\022\021\n\tscan_time\030\003 \001(\001\022\017\n\007addtime\0302 \001(\001"
    "\022\025\n\rversionNumber\030\004 \001(\t\022\014\n\004path\030\005 \001(\t\022\016\n"
    "\006status\030\006 \001(\005\"l\n\031AntiVirusSoftWareInfoLi"
    "st\022-\n\004list\030\001 \003(\0132\037.isafetec.AntiVirusSof"
    "tWareInfo\022\017\n\007alarmed\030\002 \001(\005\022\017\n\007winuser\030\003 "
    "\001(\t\"Z\n\017DisposeSoftInfo\022\n\n\002id\030\001 \001(\005\022\023\n\013zi"
    "pPackname\030\002 \001(\t\022\021\n\tunzipPath\030\003 \001(\t\022\023\n\013ru"
    "nFileName\030\004 \001(\t\">\n\023DisposeSoftInfoList\022\'"
    "\n\004list\030\001 \003(\0132\031.isafetec.DisposeSoftInfo", 15119);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "appmessage.proto", &protobuf_RegisterTypes);
  CPUInfo::default_instance_ = new CPUInfo();
  CPUInfoList::default_instance_ = new CPUInfoList();
  BIOSInfo::default_instance_ = new BIOSInfo();
  BIOSInfoList::default_instance_ = new BIOSInfoList();
  CDRomDriveInfo::default_instance_ = new CDRomDriveInfo();
  CDRomDriveInfoList::default_instance_ = new CDRomDriveInfoList();
  ComputerSystemInfo::default_instance_ = new ComputerSystemInfo();
  ComputerSystemInfoList::default_instance_ = new ComputerSystemInfoList();
  ComputerSystemProductInfo::default_instance_ = new ComputerSystemProductInfo();
  ComputerSystemProductInfoList::default_instance_ = new ComputerSystemProductInfoList();
  DiskPartitionInfo::default_instance_ = new DiskPartitionInfo();
  DiskPartitionInfoList::default_instance_ = new DiskPartitionInfoList();
  DisplayConfigurationInfo::default_instance_ = new DisplayConfigurationInfo();
  DisplayConfigurationInfoList::default_instance_ = new DisplayConfigurationInfoList();
  IDEControllerInfo::default_instance_ = new IDEControllerInfo();
  IDEControllerInfoList::default_instance_ = new IDEControllerInfoList();
  InstalledSofteware::default_instance_ = new InstalledSofteware();
  InstalledSoftewareList::default_instance_ = new InstalledSoftewareList();
  KeyboardInfo::default_instance_ = new KeyboardInfo();
  KeyboardInfoList::default_instance_ = new KeyboardInfoList();
  LogicalDiskInfo::default_instance_ = new LogicalDiskInfo();
  LogicalDiskInfoList::default_instance_ = new LogicalDiskInfoList();
  MainBoardInfo::default_instance_ = new MainBoardInfo();
  MainBoardInfoList::default_instance_ = new MainBoardInfoList();
  MemoryDeviceInfo::default_instance_ = new MemoryDeviceInfo();
  MemoryDeviceInfoList::default_instance_ = new MemoryDeviceInfoList();
  MemoryInfo::default_instance_ = new MemoryInfo();
  MemoryInfoList::default_instance_ = new MemoryInfoList();
  MouseInfo::default_instance_ = new MouseInfo();
  MouseInfoList::default_instance_ = new MouseInfoList();
  NetWorkAdapterInfo::default_instance_ = new NetWorkAdapterInfo();
  NetWorkAdapterInfoList::default_instance_ = new NetWorkAdapterInfoList();
  PhysicalDiskDriversInfo::default_instance_ = new PhysicalDiskDriversInfo();
  PhysicalDiskDriversInfoList::default_instance_ = new PhysicalDiskDriversInfoList();
  PhysicalMediaInfo::default_instance_ = new PhysicalMediaInfo();
  PhysicalMediaInfoList::default_instance_ = new PhysicalMediaInfoList();
  USBControllerInfo::default_instance_ = new USBControllerInfo();
  USBControllerInfoList::default_instance_ = new USBControllerInfoList();
  VideoDisplayDeviceInfo::default_instance_ = new VideoDisplayDeviceInfo();
  VideoDisplayDeviceInfoList::default_instance_ = new VideoDisplayDeviceInfoList();
  CltServiceInfo::default_instance_ = new CltServiceInfo();
  CltServiceList::default_instance_ = new CltServiceList();
  CltProcessInfo::default_instance_ = new CltProcessInfo();
  CltProcessList::default_instance_ = new CltProcessList();
  CltUser::default_instance_ = new CltUser();
  CltUserList::default_instance_ = new CltUserList();
  CltGroup::default_instance_ = new CltGroup();
  CltGroupList::default_instance_ = new CltGroupList();
  CltShareInfo::default_instance_ = new CltShareInfo();
  CltShareList::default_instance_ = new CltShareList();
  CltStartItem::default_instance_ = new CltStartItem();
  CltStartList::default_instance_ = new CltStartList();
  CltDiskInfo::default_instance_ = new CltDiskInfo();
  CltDiskList::default_instance_ = new CltDiskList();
  DeviceControlInfo::default_instance_ = new DeviceControlInfo();
  DeviceControlClassInfo::default_instance_ = new DeviceControlClassInfo();
  DeviceControlClassList::default_instance_ = new DeviceControlClassList();
  FireWallInfo::default_instance_ = new FireWallInfo();
  DataBaseInfo::default_instance_ = new DataBaseInfo();
  DataBaseInfoList::default_instance_ = new DataBaseInfoList();
  ODBCSourceInfo::default_instance_ = new ODBCSourceInfo();
  ODBCSourceInfoList::default_instance_ = new ODBCSourceInfoList();
  ODBCDriverInfo::default_instance_ = new ODBCDriverInfo();
  ODBCDriverInfoList::default_instance_ = new ODBCDriverInfoList();
  AntiVirusSoftWareInfo::default_instance_ = new AntiVirusSoftWareInfo();
  AntiVirusSoftWareInfoList::default_instance_ = new AntiVirusSoftWareInfoList();
  DisposeSoftInfo::default_instance_ = new DisposeSoftInfo();
  DisposeSoftInfoList::default_instance_ = new DisposeSoftInfoList();
  CPUInfo::default_instance_->InitAsDefaultInstance();
  CPUInfoList::default_instance_->InitAsDefaultInstance();
  BIOSInfo::default_instance_->InitAsDefaultInstance();
  BIOSInfoList::default_instance_->InitAsDefaultInstance();
  CDRomDriveInfo::default_instance_->InitAsDefaultInstance();
  CDRomDriveInfoList::default_instance_->InitAsDefaultInstance();
  ComputerSystemInfo::default_instance_->InitAsDefaultInstance();
  ComputerSystemInfoList::default_instance_->InitAsDefaultInstance();
  ComputerSystemProductInfo::default_instance_->InitAsDefaultInstance();
  ComputerSystemProductInfoList::default_instance_->InitAsDefaultInstance();
  DiskPartitionInfo::default_instance_->InitAsDefaultInstance();
  DiskPartitionInfoList::default_instance_->InitAsDefaultInstance();
  DisplayConfigurationInfo::default_instance_->InitAsDefaultInstance();
  DisplayConfigurationInfoList::default_instance_->InitAsDefaultInstance();
  IDEControllerInfo::default_instance_->InitAsDefaultInstance();
  IDEControllerInfoList::default_instance_->InitAsDefaultInstance();
  InstalledSofteware::default_instance_->InitAsDefaultInstance();
  InstalledSoftewareList::default_instance_->InitAsDefaultInstance();
  KeyboardInfo::default_instance_->InitAsDefaultInstance();
  KeyboardInfoList::default_instance_->InitAsDefaultInstance();
  LogicalDiskInfo::default_instance_->InitAsDefaultInstance();
  LogicalDiskInfoList::default_instance_->InitAsDefaultInstance();
  MainBoardInfo::default_instance_->InitAsDefaultInstance();
  MainBoardInfoList::default_instance_->InitAsDefaultInstance();
  MemoryDeviceInfo::default_instance_->InitAsDefaultInstance();
  MemoryDeviceInfoList::default_instance_->InitAsDefaultInstance();
  MemoryInfo::default_instance_->InitAsDefaultInstance();
  MemoryInfoList::default_instance_->InitAsDefaultInstance();
  MouseInfo::default_instance_->InitAsDefaultInstance();
  MouseInfoList::default_instance_->InitAsDefaultInstance();
  NetWorkAdapterInfo::default_instance_->InitAsDefaultInstance();
  NetWorkAdapterInfoList::default_instance_->InitAsDefaultInstance();
  PhysicalDiskDriversInfo::default_instance_->InitAsDefaultInstance();
  PhysicalDiskDriversInfoList::default_instance_->InitAsDefaultInstance();
  PhysicalMediaInfo::default_instance_->InitAsDefaultInstance();
  PhysicalMediaInfoList::default_instance_->InitAsDefaultInstance();
  USBControllerInfo::default_instance_->InitAsDefaultInstance();
  USBControllerInfoList::default_instance_->InitAsDefaultInstance();
  VideoDisplayDeviceInfo::default_instance_->InitAsDefaultInstance();
  VideoDisplayDeviceInfoList::default_instance_->InitAsDefaultInstance();
  CltServiceInfo::default_instance_->InitAsDefaultInstance();
  CltServiceList::default_instance_->InitAsDefaultInstance();
  CltProcessInfo::default_instance_->InitAsDefaultInstance();
  CltProcessList::default_instance_->InitAsDefaultInstance();
  CltUser::default_instance_->InitAsDefaultInstance();
  CltUserList::default_instance_->InitAsDefaultInstance();
  CltGroup::default_instance_->InitAsDefaultInstance();
  CltGroupList::default_instance_->InitAsDefaultInstance();
  CltShareInfo::default_instance_->InitAsDefaultInstance();
  CltShareList::default_instance_->InitAsDefaultInstance();
  CltStartItem::default_instance_->InitAsDefaultInstance();
  CltStartList::default_instance_->InitAsDefaultInstance();
  CltDiskInfo::default_instance_->InitAsDefaultInstance();
  CltDiskList::default_instance_->InitAsDefaultInstance();
  DeviceControlInfo::default_instance_->InitAsDefaultInstance();
  DeviceControlClassInfo::default_instance_->InitAsDefaultInstance();
  DeviceControlClassList::default_instance_->InitAsDefaultInstance();
  FireWallInfo::default_instance_->InitAsDefaultInstance();
  DataBaseInfo::default_instance_->InitAsDefaultInstance();
  DataBaseInfoList::default_instance_->InitAsDefaultInstance();
  ODBCSourceInfo::default_instance_->InitAsDefaultInstance();
  ODBCSourceInfoList::default_instance_->InitAsDefaultInstance();
  ODBCDriverInfo::default_instance_->InitAsDefaultInstance();
  ODBCDriverInfoList::default_instance_->InitAsDefaultInstance();
  AntiVirusSoftWareInfo::default_instance_->InitAsDefaultInstance();
  AntiVirusSoftWareInfoList::default_instance_->InitAsDefaultInstance();
  DisposeSoftInfo::default_instance_->InitAsDefaultInstance();
  DisposeSoftInfoList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_appmessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_appmessage_2eproto {
  StaticDescriptorInitializer_appmessage_2eproto() {
    protobuf_AddDesc_appmessage_2eproto();
  }
} static_descriptor_initializer_appmessage_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int CPUInfo::kPackageCodeFieldNumber;
const int CPUInfo::kChecktypeFieldNumber;
const int CPUInfo::kScanTimeFieldNumber;
const int CPUInfo::kAddtimeFieldNumber;
const int CPUInfo::kArchitectureFieldNumber;
const int CPUInfo::kAvailabilityFieldNumber;
const int CPUInfo::kCurrentClockSpeedFieldNumber;
const int CPUInfo::kCurrentVoltageFieldNumber;
const int CPUInfo::kDataWidthFieldNumber;
const int CPUInfo::kExtClockFieldNumber;
const int CPUInfo::kFamilyFieldNumber;
const int CPUInfo::kL2CacheSpeedFieldNumber;
const int CPUInfo::kL3CacheSizeFieldNumber;
const int CPUInfo::kL3CacheSpeedFieldNumber;
const int CPUInfo::kMaxClockSpeedFieldNumber;
const int CPUInfo::kLoadPercentageFieldNumber;
const int CPUInfo::kProcessorTypeFieldNumber;
const int CPUInfo::kL2CacheSizeFieldNumber;
const int CPUInfo::kVersionFieldNumber;
const int CPUInfo::kDescriptionFieldNumber;
const int CPUInfo::kAddressWidthFieldNumber;
const int CPUInfo::kManufacturerFieldNumber;
const int CPUInfo::kNameFieldNumber;
const int CPUInfo::kProcessorIdFieldNumber;
const int CPUInfo::kRoleFieldNumber;
const int CPUInfo::kSocketDesignationFieldNumber;
const int CPUInfo::kStatusFieldNumber;
const int CPUInfo::kSteppingFieldNumber;
const int CPUInfo::kBuyTimeFieldNumber;
const int CPUInfo::kBuyPriceFieldNumber;
const int CPUInfo::kDCheckTimeFieldNumber;
const int CPUInfo::kOtherInfoFieldNumber;
const int CPUInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

CPUInfo::CPUInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CPUInfo::InitAsDefaultInstance() {
}

CPUInfo::CPUInfo(const CPUInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CPUInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  architecture_ = 0;
  availability_ = 0;
  currentclockspeed_ = 0;
  currentvoltage_ = 0;
  datawidth_ = 0;
  extclock_ = 0;
  family_ = 0;
  l2cachespeed_ = 0;
  l3cachesize_ = 0;
  l3cachespeed_ = 0;
  maxclockspeed_ = 0;
  loadpercentage_ = 0;
  processortype_ = 0;
  l2cachesize_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  addresswidth_ = 0;
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  processorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  socketdesignation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  stepping_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CPUInfo::~CPUInfo() {
  SharedDtor();
}

void CPUInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (processorid_ != &::google::protobuf::internal::kEmptyString) {
    delete processorid_;
  }
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    delete role_;
  }
  if (socketdesignation_ != &::google::protobuf::internal::kEmptyString) {
    delete socketdesignation_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (stepping_ != &::google::protobuf::internal::kEmptyString) {
    delete stepping_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void CPUInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CPUInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CPUInfo_descriptor_;
}

const CPUInfo& CPUInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CPUInfo* CPUInfo::default_instance_ = NULL;

CPUInfo* CPUInfo::New() const {
  return new CPUInfo;
}

void CPUInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    architecture_ = 0;
    availability_ = 0;
    currentclockspeed_ = 0;
    currentvoltage_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    datawidth_ = 0;
    extclock_ = 0;
    family_ = 0;
    l2cachespeed_ = 0;
    l3cachesize_ = 0;
    l3cachespeed_ = 0;
    maxclockspeed_ = 0;
    loadpercentage_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    processortype_ = 0;
    l2cachesize_ = 0;
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    addresswidth_ = 0;
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_processorid()) {
      if (processorid_ != &::google::protobuf::internal::kEmptyString) {
        processorid_->clear();
      }
    }
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_role()) {
      if (role_ != &::google::protobuf::internal::kEmptyString) {
        role_->clear();
      }
    }
    if (has_socketdesignation()) {
      if (socketdesignation_ != &::google::protobuf::internal::kEmptyString) {
        socketdesignation_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_stepping()) {
      if (stepping_ != &::google::protobuf::internal::kEmptyString) {
        stepping_->clear();
      }
    }
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CPUInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Architecture;
        break;
      }
      
      // optional int32 Architecture = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Architecture:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &architecture_)));
          set_has_architecture();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_CurrentClockSpeed;
        break;
      }
      
      // optional int32 CurrentClockSpeed = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentClockSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentclockspeed_)));
          set_has_currentclockspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_CurrentVoltage;
        break;
      }
      
      // optional int32 CurrentVoltage = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentVoltage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentvoltage_)));
          set_has_currentvoltage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_DataWidth;
        break;
      }
      
      // optional int32 DataWidth = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DataWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datawidth_)));
          set_has_datawidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_ExtClock;
        break;
      }
      
      // optional int32 ExtClock = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ExtClock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &extclock_)));
          set_has_extclock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_Family;
        break;
      }
      
      // optional int32 Family = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Family:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &family_)));
          set_has_family();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_L2CacheSpeed;
        break;
      }
      
      // optional int32 L2CacheSpeed = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_L2CacheSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &l2cachespeed_)));
          set_has_l2cachespeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_L3CacheSize;
        break;
      }
      
      // optional int32 L3CacheSize = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_L3CacheSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &l3cachesize_)));
          set_has_l3cachesize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_L3CacheSpeed;
        break;
      }
      
      // optional int32 L3CacheSpeed = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_L3CacheSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &l3cachespeed_)));
          set_has_l3cachespeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_MaxClockSpeed;
        break;
      }
      
      // optional int32 MaxClockSpeed = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxClockSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxclockspeed_)));
          set_has_maxclockspeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_LoadPercentage;
        break;
      }
      
      // optional int32 LoadPercentage = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_LoadPercentage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loadpercentage_)));
          set_has_loadpercentage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_ProcessorType;
        break;
      }
      
      // optional int32 ProcessorType = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ProcessorType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &processortype_)));
          set_has_processortype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_L2CacheSize;
        break;
      }
      
      // optional int32 L2CacheSize = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_L2CacheSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &l2cachesize_)));
          set_has_l2cachesize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_Version;
        break;
      }
      
      // optional string Version = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_Description;
        break;
      }
      
      // optional string Description = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_AddressWidth;
        break;
      }
      
      // optional int32 AddressWidth = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AddressWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &addresswidth_)));
          set_has_addresswidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_Name;
        break;
      }
      
      // optional string Name = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_ProcessorId;
        break;
      }
      
      // optional string ProcessorId = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ProcessorId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_processorid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->processorid().data(), this->processorid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_Role;
        break;
      }
      
      // optional string Role = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(202)) goto parse_SocketDesignation;
        break;
      }
      
      // optional string SocketDesignation = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SocketDesignation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_socketdesignation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->socketdesignation().data(), this->socketdesignation().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_Status;
        break;
      }
      
      // optional string Status = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_Stepping;
        break;
      }
      
      // optional string Stepping = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Stepping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_stepping()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->stepping().data(), this->stepping().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(225)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(241)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(258)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CPUInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 Architecture = 4;
  if (has_architecture()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->architecture(), output);
  }
  
  // optional int32 Availability = 5;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->availability(), output);
  }
  
  // optional int32 CurrentClockSpeed = 6;
  if (has_currentclockspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->currentclockspeed(), output);
  }
  
  // optional int32 CurrentVoltage = 7;
  if (has_currentvoltage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->currentvoltage(), output);
  }
  
  // optional int32 DataWidth = 8;
  if (has_datawidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->datawidth(), output);
  }
  
  // optional int32 ExtClock = 9;
  if (has_extclock()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->extclock(), output);
  }
  
  // optional int32 Family = 10;
  if (has_family()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->family(), output);
  }
  
  // optional int32 L2CacheSpeed = 11;
  if (has_l2cachespeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->l2cachespeed(), output);
  }
  
  // optional int32 L3CacheSize = 12;
  if (has_l3cachesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->l3cachesize(), output);
  }
  
  // optional int32 L3CacheSpeed = 13;
  if (has_l3cachespeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->l3cachespeed(), output);
  }
  
  // optional int32 MaxClockSpeed = 14;
  if (has_maxclockspeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->maxclockspeed(), output);
  }
  
  // optional int32 LoadPercentage = 15;
  if (has_loadpercentage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->loadpercentage(), output);
  }
  
  // optional int32 ProcessorType = 16;
  if (has_processortype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->processortype(), output);
  }
  
  // optional int32 L2CacheSize = 17;
  if (has_l2cachesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->l2cachesize(), output);
  }
  
  // optional string Version = 18;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->version(), output);
  }
  
  // optional string Description = 19;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->description(), output);
  }
  
  // optional int32 AddressWidth = 20;
  if (has_addresswidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(20, this->addresswidth(), output);
  }
  
  // optional string Manufacturer = 21;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->manufacturer(), output);
  }
  
  // optional string Name = 22;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->name(), output);
  }
  
  // optional string ProcessorId = 23;
  if (has_processorid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->processorid().data(), this->processorid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      23, this->processorid(), output);
  }
  
  // optional string Role = 24;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->role(), output);
  }
  
  // optional string SocketDesignation = 25;
  if (has_socketdesignation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->socketdesignation().data(), this->socketdesignation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      25, this->socketdesignation(), output);
  }
  
  // optional string Status = 26;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->status(), output);
  }
  
  // optional string Stepping = 27;
  if (has_stepping()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->stepping().data(), this->stepping().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->stepping(), output);
  }
  
  // optional double BuyTime = 28;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->buytime(), output);
  }
  
  // optional string BuyPrice = 29;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      29, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 30;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(30, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 31;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      31, this->otherinfo(), output);
  }
  
  // optional string BuyName = 32;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      32, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CPUInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 Architecture = 4;
  if (has_architecture()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->architecture(), target);
  }
  
  // optional int32 Availability = 5;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->availability(), target);
  }
  
  // optional int32 CurrentClockSpeed = 6;
  if (has_currentclockspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->currentclockspeed(), target);
  }
  
  // optional int32 CurrentVoltage = 7;
  if (has_currentvoltage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->currentvoltage(), target);
  }
  
  // optional int32 DataWidth = 8;
  if (has_datawidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->datawidth(), target);
  }
  
  // optional int32 ExtClock = 9;
  if (has_extclock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->extclock(), target);
  }
  
  // optional int32 Family = 10;
  if (has_family()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->family(), target);
  }
  
  // optional int32 L2CacheSpeed = 11;
  if (has_l2cachespeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->l2cachespeed(), target);
  }
  
  // optional int32 L3CacheSize = 12;
  if (has_l3cachesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->l3cachesize(), target);
  }
  
  // optional int32 L3CacheSpeed = 13;
  if (has_l3cachespeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->l3cachespeed(), target);
  }
  
  // optional int32 MaxClockSpeed = 14;
  if (has_maxclockspeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->maxclockspeed(), target);
  }
  
  // optional int32 LoadPercentage = 15;
  if (has_loadpercentage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->loadpercentage(), target);
  }
  
  // optional int32 ProcessorType = 16;
  if (has_processortype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->processortype(), target);
  }
  
  // optional int32 L2CacheSize = 17;
  if (has_l2cachesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->l2cachesize(), target);
  }
  
  // optional string Version = 18;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->version(), target);
  }
  
  // optional string Description = 19;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->description(), target);
  }
  
  // optional int32 AddressWidth = 20;
  if (has_addresswidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(20, this->addresswidth(), target);
  }
  
  // optional string Manufacturer = 21;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->manufacturer(), target);
  }
  
  // optional string Name = 22;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->name(), target);
  }
  
  // optional string ProcessorId = 23;
  if (has_processorid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->processorid().data(), this->processorid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        23, this->processorid(), target);
  }
  
  // optional string Role = 24;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->role(), target);
  }
  
  // optional string SocketDesignation = 25;
  if (has_socketdesignation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->socketdesignation().data(), this->socketdesignation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        25, this->socketdesignation(), target);
  }
  
  // optional string Status = 26;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->status(), target);
  }
  
  // optional string Stepping = 27;
  if (has_stepping()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->stepping().data(), this->stepping().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->stepping(), target);
  }
  
  // optional double BuyTime = 28;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->buytime(), target);
  }
  
  // optional string BuyPrice = 29;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        29, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 30;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(30, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 31;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        31, this->otherinfo(), target);
  }
  
  // optional string BuyName = 32;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        32, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CPUInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 Architecture = 4;
    if (has_architecture()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->architecture());
    }
    
    // optional int32 Availability = 5;
    if (has_availability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 CurrentClockSpeed = 6;
    if (has_currentclockspeed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentclockspeed());
    }
    
    // optional int32 CurrentVoltage = 7;
    if (has_currentvoltage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentvoltage());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 DataWidth = 8;
    if (has_datawidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datawidth());
    }
    
    // optional int32 ExtClock = 9;
    if (has_extclock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->extclock());
    }
    
    // optional int32 Family = 10;
    if (has_family()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->family());
    }
    
    // optional int32 L2CacheSpeed = 11;
    if (has_l2cachespeed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->l2cachespeed());
    }
    
    // optional int32 L3CacheSize = 12;
    if (has_l3cachesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->l3cachesize());
    }
    
    // optional int32 L3CacheSpeed = 13;
    if (has_l3cachespeed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->l3cachespeed());
    }
    
    // optional int32 MaxClockSpeed = 14;
    if (has_maxclockspeed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxclockspeed());
    }
    
    // optional int32 LoadPercentage = 15;
    if (has_loadpercentage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loadpercentage());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 ProcessorType = 16;
    if (has_processortype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->processortype());
    }
    
    // optional int32 L2CacheSize = 17;
    if (has_l2cachesize()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->l2cachesize());
    }
    
    // optional string Version = 18;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional string Description = 19;
    if (has_description()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional int32 AddressWidth = 20;
    if (has_addresswidth()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->addresswidth());
    }
    
    // optional string Manufacturer = 21;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Name = 22;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string ProcessorId = 23;
    if (has_processorid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->processorid());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string Role = 24;
    if (has_role()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }
    
    // optional string SocketDesignation = 25;
    if (has_socketdesignation()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->socketdesignation());
    }
    
    // optional string Status = 26;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string Stepping = 27;
    if (has_stepping()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->stepping());
    }
    
    // optional double BuyTime = 28;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 29;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 30;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 31;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional string BuyName = 32;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CPUInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CPUInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CPUInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CPUInfo::MergeFrom(const CPUInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_architecture()) {
      set_architecture(from.architecture());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_currentclockspeed()) {
      set_currentclockspeed(from.currentclockspeed());
    }
    if (from.has_currentvoltage()) {
      set_currentvoltage(from.currentvoltage());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_datawidth()) {
      set_datawidth(from.datawidth());
    }
    if (from.has_extclock()) {
      set_extclock(from.extclock());
    }
    if (from.has_family()) {
      set_family(from.family());
    }
    if (from.has_l2cachespeed()) {
      set_l2cachespeed(from.l2cachespeed());
    }
    if (from.has_l3cachesize()) {
      set_l3cachesize(from.l3cachesize());
    }
    if (from.has_l3cachespeed()) {
      set_l3cachespeed(from.l3cachespeed());
    }
    if (from.has_maxclockspeed()) {
      set_maxclockspeed(from.maxclockspeed());
    }
    if (from.has_loadpercentage()) {
      set_loadpercentage(from.loadpercentage());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_processortype()) {
      set_processortype(from.processortype());
    }
    if (from.has_l2cachesize()) {
      set_l2cachesize(from.l2cachesize());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_addresswidth()) {
      set_addresswidth(from.addresswidth());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_processorid()) {
      set_processorid(from.processorid());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_role()) {
      set_role(from.role());
    }
    if (from.has_socketdesignation()) {
      set_socketdesignation(from.socketdesignation());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_stepping()) {
      set_stepping(from.stepping());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CPUInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CPUInfo::CopyFrom(const CPUInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPUInfo::IsInitialized() const {
  
  return true;
}

void CPUInfo::Swap(CPUInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(architecture_, other->architecture_);
    std::swap(availability_, other->availability_);
    std::swap(currentclockspeed_, other->currentclockspeed_);
    std::swap(currentvoltage_, other->currentvoltage_);
    std::swap(datawidth_, other->datawidth_);
    std::swap(extclock_, other->extclock_);
    std::swap(family_, other->family_);
    std::swap(l2cachespeed_, other->l2cachespeed_);
    std::swap(l3cachesize_, other->l3cachesize_);
    std::swap(l3cachespeed_, other->l3cachespeed_);
    std::swap(maxclockspeed_, other->maxclockspeed_);
    std::swap(loadpercentage_, other->loadpercentage_);
    std::swap(processortype_, other->processortype_);
    std::swap(l2cachesize_, other->l2cachesize_);
    std::swap(version_, other->version_);
    std::swap(description_, other->description_);
    std::swap(addresswidth_, other->addresswidth_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(name_, other->name_);
    std::swap(processorid_, other->processorid_);
    std::swap(role_, other->role_);
    std::swap(socketdesignation_, other->socketdesignation_);
    std::swap(status_, other->status_);
    std::swap(stepping_, other->stepping_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CPUInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CPUInfo_descriptor_;
  metadata.reflection = CPUInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CPUInfoList::kListFieldNumber;
const int CPUInfoList::kAlarmedFieldNumber;
const int CPUInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

CPUInfoList::CPUInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CPUInfoList::InitAsDefaultInstance() {
}

CPUInfoList::CPUInfoList(const CPUInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CPUInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CPUInfoList::~CPUInfoList() {
  SharedDtor();
}

void CPUInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void CPUInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CPUInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CPUInfoList_descriptor_;
}

const CPUInfoList& CPUInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CPUInfoList* CPUInfoList::default_instance_ = NULL;

CPUInfoList* CPUInfoList::New() const {
  return new CPUInfoList;
}

void CPUInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CPUInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CPUInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CPUInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CPUInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CPUInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CPUInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CPUInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.CPUInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CPUInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CPUInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CPUInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CPUInfoList::MergeFrom(const CPUInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CPUInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CPUInfoList::CopyFrom(const CPUInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPUInfoList::IsInitialized() const {
  
  return true;
}

void CPUInfoList::Swap(CPUInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CPUInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CPUInfoList_descriptor_;
  metadata.reflection = CPUInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BIOSInfo::kPackageCodeFieldNumber;
const int BIOSInfo::kChecktypeFieldNumber;
const int BIOSInfo::kScanTimeFieldNumber;
const int BIOSInfo::kAddtimeFieldNumber;
const int BIOSInfo::kTargetOperatingSystemFieldNumber;
const int BIOSInfo::kSoftwareElementStateFieldNumber;
const int BIOSInfo::kPrimaryBIOSFieldNumber;
const int BIOSInfo::kSMBIOSPresentFieldNumber;
const int BIOSInfo::kBuildNumberFieldNumber;
const int BIOSInfo::kCodeSetFieldNumber;
const int BIOSInfo::kCurrentLanguageFieldNumber;
const int BIOSInfo::kDescriptionFieldNumber;
const int BIOSInfo::kIdentificationCodeFieldNumber;
const int BIOSInfo::kLanguageEditionFieldNumber;
const int BIOSInfo::kManufacturerFieldNumber;
const int BIOSInfo::kOtherTargetOSFieldNumber;
const int BIOSInfo::kSerialNumberFieldNumber;
const int BIOSInfo::kSMBIOSBIOSVersionFieldNumber;
const int BIOSInfo::kSoftwareElementIDFieldNumber;
const int BIOSInfo::kStatusFieldNumber;
const int BIOSInfo::kVersionFieldNumber;
const int BIOSInfo::kSMBIOSMajorVersionFieldNumber;
const int BIOSInfo::kSMBIOSMinorVersionFieldNumber;
const int BIOSInfo::kBuyTimeFieldNumber;
const int BIOSInfo::kBuyPriceFieldNumber;
const int BIOSInfo::kDCheckTimeFieldNumber;
const int BIOSInfo::kOtherInfoFieldNumber;
const int BIOSInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

BIOSInfo::BIOSInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BIOSInfo::InitAsDefaultInstance() {
}

BIOSInfo::BIOSInfo(const BIOSInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BIOSInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  targetoperatingsystem_ = 0;
  softwareelementstate_ = 0;
  primarybios_ = 0;
  smbiospresent_ = 0;
  buildnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  codeset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  currentlanguage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  identificationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  languageedition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  othertargetos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  smbiosbiosversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  softwareelementid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  smbiosmajorversion_ = 0;
  smbiosminorversion_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BIOSInfo::~BIOSInfo() {
  SharedDtor();
}

void BIOSInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (buildnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete buildnumber_;
  }
  if (codeset_ != &::google::protobuf::internal::kEmptyString) {
    delete codeset_;
  }
  if (currentlanguage_ != &::google::protobuf::internal::kEmptyString) {
    delete currentlanguage_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (identificationcode_ != &::google::protobuf::internal::kEmptyString) {
    delete identificationcode_;
  }
  if (languageedition_ != &::google::protobuf::internal::kEmptyString) {
    delete languageedition_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (othertargetos_ != &::google::protobuf::internal::kEmptyString) {
    delete othertargetos_;
  }
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (smbiosbiosversion_ != &::google::protobuf::internal::kEmptyString) {
    delete smbiosbiosversion_;
  }
  if (softwareelementid_ != &::google::protobuf::internal::kEmptyString) {
    delete softwareelementid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void BIOSInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BIOSInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BIOSInfo_descriptor_;
}

const BIOSInfo& BIOSInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

BIOSInfo* BIOSInfo::default_instance_ = NULL;

BIOSInfo* BIOSInfo::New() const {
  return new BIOSInfo;
}

void BIOSInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    targetoperatingsystem_ = 0;
    softwareelementstate_ = 0;
    primarybios_ = 0;
    smbiospresent_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_buildnumber()) {
      if (buildnumber_ != &::google::protobuf::internal::kEmptyString) {
        buildnumber_->clear();
      }
    }
    if (has_codeset()) {
      if (codeset_ != &::google::protobuf::internal::kEmptyString) {
        codeset_->clear();
      }
    }
    if (has_currentlanguage()) {
      if (currentlanguage_ != &::google::protobuf::internal::kEmptyString) {
        currentlanguage_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_identificationcode()) {
      if (identificationcode_ != &::google::protobuf::internal::kEmptyString) {
        identificationcode_->clear();
      }
    }
    if (has_languageedition()) {
      if (languageedition_ != &::google::protobuf::internal::kEmptyString) {
        languageedition_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_othertargetos()) {
      if (othertargetos_ != &::google::protobuf::internal::kEmptyString) {
        othertargetos_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_serialnumber()) {
      if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
        serialnumber_->clear();
      }
    }
    if (has_smbiosbiosversion()) {
      if (smbiosbiosversion_ != &::google::protobuf::internal::kEmptyString) {
        smbiosbiosversion_->clear();
      }
    }
    if (has_softwareelementid()) {
      if (softwareelementid_ != &::google::protobuf::internal::kEmptyString) {
        softwareelementid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    smbiosmajorversion_ = 0;
    smbiosminorversion_ = 0;
    buytime_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BIOSInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_TargetOperatingSystem;
        break;
      }
      
      // optional int32 TargetOperatingSystem = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TargetOperatingSystem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &targetoperatingsystem_)));
          set_has_targetoperatingsystem();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_SoftwareElementState;
        break;
      }
      
      // optional int32 SoftwareElementState = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SoftwareElementState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &softwareelementstate_)));
          set_has_softwareelementstate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_PrimaryBIOS;
        break;
      }
      
      // optional int32 PrimaryBIOS = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PrimaryBIOS:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &primarybios_)));
          set_has_primarybios();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_SMBIOSPresent;
        break;
      }
      
      // optional int32 SMBIOSPresent = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SMBIOSPresent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &smbiospresent_)));
          set_has_smbiospresent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_BuildNumber;
        break;
      }
      
      // optional string BuildNumber = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuildNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buildnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buildnumber().data(), this->buildnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_CodeSet;
        break;
      }
      
      // optional string CodeSet = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CodeSet:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_codeset()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->codeset().data(), this->codeset().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_CurrentLanguage;
        break;
      }
      
      // optional string CurrentLanguage = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CurrentLanguage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_currentlanguage()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->currentlanguage().data(), this->currentlanguage().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Description;
        break;
      }
      
      // optional string Description = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_IdentificationCode;
        break;
      }
      
      // optional string IdentificationCode = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_IdentificationCode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_identificationcode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->identificationcode().data(), this->identificationcode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_LanguageEdition;
        break;
      }
      
      // optional string LanguageEdition = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_LanguageEdition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_languageedition()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->languageedition().data(), this->languageedition().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_OtherTargetOS;
        break;
      }
      
      // optional string OtherTargetOS = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherTargetOS:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_othertargetos()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->othertargetos().data(), this->othertargetos().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_SerialNumber;
        break;
      }
      
      // optional string SerialNumber = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serialnumber().data(), this->serialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_SMBIOSBIOSVersion;
        break;
      }
      
      // optional string SMBIOSBIOSVersion = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SMBIOSBIOSVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_smbiosbiosversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->smbiosbiosversion().data(), this->smbiosbiosversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_SoftwareElementID;
        break;
      }
      
      // optional string SoftwareElementID = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SoftwareElementID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_softwareelementid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->softwareelementid().data(), this->softwareelementid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_Status;
        break;
      }
      
      // optional string Status = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_Version;
        break;
      }
      
      // optional string Version = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_SMBIOSMajorVersion;
        break;
      }
      
      // optional int32 SMBIOSMajorVersion = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SMBIOSMajorVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &smbiosmajorversion_)));
          set_has_smbiosmajorversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_SMBIOSMinorVersion;
        break;
      }
      
      // optional int32 SMBIOSMinorVersion = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SMBIOSMinorVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &smbiosminorversion_)));
          set_has_smbiosminorversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(185)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(201)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BIOSInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 TargetOperatingSystem = 4;
  if (has_targetoperatingsystem()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->targetoperatingsystem(), output);
  }
  
  // optional int32 SoftwareElementState = 5;
  if (has_softwareelementstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->softwareelementstate(), output);
  }
  
  // optional int32 PrimaryBIOS = 6;
  if (has_primarybios()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->primarybios(), output);
  }
  
  // optional int32 SMBIOSPresent = 7;
  if (has_smbiospresent()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->smbiospresent(), output);
  }
  
  // optional string BuildNumber = 8;
  if (has_buildnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buildnumber().data(), this->buildnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->buildnumber(), output);
  }
  
  // optional string CodeSet = 9;
  if (has_codeset()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->codeset().data(), this->codeset().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->codeset(), output);
  }
  
  // optional string CurrentLanguage = 10;
  if (has_currentlanguage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->currentlanguage().data(), this->currentlanguage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->currentlanguage(), output);
  }
  
  // optional string Description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->description(), output);
  }
  
  // optional string IdentificationCode = 12;
  if (has_identificationcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identificationcode().data(), this->identificationcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->identificationcode(), output);
  }
  
  // optional string LanguageEdition = 13;
  if (has_languageedition()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->languageedition().data(), this->languageedition().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->languageedition(), output);
  }
  
  // optional string Manufacturer = 14;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->manufacturer(), output);
  }
  
  // optional string OtherTargetOS = 15;
  if (has_othertargetos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->othertargetos().data(), this->othertargetos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->othertargetos(), output);
  }
  
  // optional string SerialNumber = 16;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->serialnumber(), output);
  }
  
  // optional string SMBIOSBIOSVersion = 17;
  if (has_smbiosbiosversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->smbiosbiosversion().data(), this->smbiosbiosversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->smbiosbiosversion(), output);
  }
  
  // optional string SoftwareElementID = 18;
  if (has_softwareelementid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->softwareelementid().data(), this->softwareelementid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->softwareelementid(), output);
  }
  
  // optional string Status = 19;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->status(), output);
  }
  
  // optional string Version = 20;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->version(), output);
  }
  
  // optional int32 SMBIOSMajorVersion = 21;
  if (has_smbiosmajorversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(21, this->smbiosmajorversion(), output);
  }
  
  // optional int32 SMBIOSMinorVersion = 22;
  if (has_smbiosminorversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->smbiosminorversion(), output);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->buytime(), output);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->otherinfo(), output);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BIOSInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 TargetOperatingSystem = 4;
  if (has_targetoperatingsystem()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->targetoperatingsystem(), target);
  }
  
  // optional int32 SoftwareElementState = 5;
  if (has_softwareelementstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->softwareelementstate(), target);
  }
  
  // optional int32 PrimaryBIOS = 6;
  if (has_primarybios()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->primarybios(), target);
  }
  
  // optional int32 SMBIOSPresent = 7;
  if (has_smbiospresent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->smbiospresent(), target);
  }
  
  // optional string BuildNumber = 8;
  if (has_buildnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buildnumber().data(), this->buildnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->buildnumber(), target);
  }
  
  // optional string CodeSet = 9;
  if (has_codeset()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->codeset().data(), this->codeset().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->codeset(), target);
  }
  
  // optional string CurrentLanguage = 10;
  if (has_currentlanguage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->currentlanguage().data(), this->currentlanguage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->currentlanguage(), target);
  }
  
  // optional string Description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->description(), target);
  }
  
  // optional string IdentificationCode = 12;
  if (has_identificationcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identificationcode().data(), this->identificationcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->identificationcode(), target);
  }
  
  // optional string LanguageEdition = 13;
  if (has_languageedition()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->languageedition().data(), this->languageedition().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->languageedition(), target);
  }
  
  // optional string Manufacturer = 14;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->manufacturer(), target);
  }
  
  // optional string OtherTargetOS = 15;
  if (has_othertargetos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->othertargetos().data(), this->othertargetos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->othertargetos(), target);
  }
  
  // optional string SerialNumber = 16;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->serialnumber(), target);
  }
  
  // optional string SMBIOSBIOSVersion = 17;
  if (has_smbiosbiosversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->smbiosbiosversion().data(), this->smbiosbiosversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->smbiosbiosversion(), target);
  }
  
  // optional string SoftwareElementID = 18;
  if (has_softwareelementid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->softwareelementid().data(), this->softwareelementid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->softwareelementid(), target);
  }
  
  // optional string Status = 19;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->status(), target);
  }
  
  // optional string Version = 20;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->version(), target);
  }
  
  // optional int32 SMBIOSMajorVersion = 21;
  if (has_smbiosmajorversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(21, this->smbiosmajorversion(), target);
  }
  
  // optional int32 SMBIOSMinorVersion = 22;
  if (has_smbiosminorversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->smbiosminorversion(), target);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->buytime(), target);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->otherinfo(), target);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BIOSInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 TargetOperatingSystem = 4;
    if (has_targetoperatingsystem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->targetoperatingsystem());
    }
    
    // optional int32 SoftwareElementState = 5;
    if (has_softwareelementstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->softwareelementstate());
    }
    
    // optional int32 PrimaryBIOS = 6;
    if (has_primarybios()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->primarybios());
    }
    
    // optional int32 SMBIOSPresent = 7;
    if (has_smbiospresent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->smbiospresent());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string BuildNumber = 8;
    if (has_buildnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buildnumber());
    }
    
    // optional string CodeSet = 9;
    if (has_codeset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->codeset());
    }
    
    // optional string CurrentLanguage = 10;
    if (has_currentlanguage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->currentlanguage());
    }
    
    // optional string Description = 11;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string IdentificationCode = 12;
    if (has_identificationcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->identificationcode());
    }
    
    // optional string LanguageEdition = 13;
    if (has_languageedition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->languageedition());
    }
    
    // optional string Manufacturer = 14;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string OtherTargetOS = 15;
    if (has_othertargetos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->othertargetos());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string SerialNumber = 16;
    if (has_serialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serialnumber());
    }
    
    // optional string SMBIOSBIOSVersion = 17;
    if (has_smbiosbiosversion()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->smbiosbiosversion());
    }
    
    // optional string SoftwareElementID = 18;
    if (has_softwareelementid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->softwareelementid());
    }
    
    // optional string Status = 19;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string Version = 20;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional int32 SMBIOSMajorVersion = 21;
    if (has_smbiosmajorversion()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->smbiosmajorversion());
    }
    
    // optional int32 SMBIOSMinorVersion = 22;
    if (has_smbiosminorversion()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->smbiosminorversion());
    }
    
    // optional double BuyTime = 23;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string BuyPrice = 24;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 25;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 26;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 27;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BIOSInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BIOSInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BIOSInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BIOSInfo::MergeFrom(const BIOSInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_targetoperatingsystem()) {
      set_targetoperatingsystem(from.targetoperatingsystem());
    }
    if (from.has_softwareelementstate()) {
      set_softwareelementstate(from.softwareelementstate());
    }
    if (from.has_primarybios()) {
      set_primarybios(from.primarybios());
    }
    if (from.has_smbiospresent()) {
      set_smbiospresent(from.smbiospresent());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buildnumber()) {
      set_buildnumber(from.buildnumber());
    }
    if (from.has_codeset()) {
      set_codeset(from.codeset());
    }
    if (from.has_currentlanguage()) {
      set_currentlanguage(from.currentlanguage());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_identificationcode()) {
      set_identificationcode(from.identificationcode());
    }
    if (from.has_languageedition()) {
      set_languageedition(from.languageedition());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_othertargetos()) {
      set_othertargetos(from.othertargetos());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_smbiosbiosversion()) {
      set_smbiosbiosversion(from.smbiosbiosversion());
    }
    if (from.has_softwareelementid()) {
      set_softwareelementid(from.softwareelementid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_smbiosmajorversion()) {
      set_smbiosmajorversion(from.smbiosmajorversion());
    }
    if (from.has_smbiosminorversion()) {
      set_smbiosminorversion(from.smbiosminorversion());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BIOSInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BIOSInfo::CopyFrom(const BIOSInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BIOSInfo::IsInitialized() const {
  
  return true;
}

void BIOSInfo::Swap(BIOSInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(targetoperatingsystem_, other->targetoperatingsystem_);
    std::swap(softwareelementstate_, other->softwareelementstate_);
    std::swap(primarybios_, other->primarybios_);
    std::swap(smbiospresent_, other->smbiospresent_);
    std::swap(buildnumber_, other->buildnumber_);
    std::swap(codeset_, other->codeset_);
    std::swap(currentlanguage_, other->currentlanguage_);
    std::swap(description_, other->description_);
    std::swap(identificationcode_, other->identificationcode_);
    std::swap(languageedition_, other->languageedition_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(othertargetos_, other->othertargetos_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(smbiosbiosversion_, other->smbiosbiosversion_);
    std::swap(softwareelementid_, other->softwareelementid_);
    std::swap(status_, other->status_);
    std::swap(version_, other->version_);
    std::swap(smbiosmajorversion_, other->smbiosmajorversion_);
    std::swap(smbiosminorversion_, other->smbiosminorversion_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BIOSInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BIOSInfo_descriptor_;
  metadata.reflection = BIOSInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BIOSInfoList::kListFieldNumber;
const int BIOSInfoList::kAlarmedFieldNumber;
const int BIOSInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

BIOSInfoList::BIOSInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BIOSInfoList::InitAsDefaultInstance() {
}

BIOSInfoList::BIOSInfoList(const BIOSInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BIOSInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BIOSInfoList::~BIOSInfoList() {
  SharedDtor();
}

void BIOSInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void BIOSInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BIOSInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BIOSInfoList_descriptor_;
}

const BIOSInfoList& BIOSInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

BIOSInfoList* BIOSInfoList::default_instance_ = NULL;

BIOSInfoList* BIOSInfoList::New() const {
  return new BIOSInfoList;
}

void BIOSInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BIOSInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.BIOSInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BIOSInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.BIOSInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BIOSInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.BIOSInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BIOSInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.BIOSInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BIOSInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BIOSInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BIOSInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BIOSInfoList::MergeFrom(const BIOSInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BIOSInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BIOSInfoList::CopyFrom(const BIOSInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BIOSInfoList::IsInitialized() const {
  
  return true;
}

void BIOSInfoList::Swap(BIOSInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BIOSInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BIOSInfoList_descriptor_;
  metadata.reflection = BIOSInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CDRomDriveInfo::kPackageCodeFieldNumber;
const int CDRomDriveInfo::kChecktypeFieldNumber;
const int CDRomDriveInfo::kScanTimeFieldNumber;
const int CDRomDriveInfo::kAddtimeFieldNumber;
const int CDRomDriveInfo::kFileSystemFlagsExFieldNumber;
const int CDRomDriveInfo::kMaxBlockSizeFieldNumber;
const int CDRomDriveInfo::kMaximumComponentLengthFieldNumber;
const int CDRomDriveInfo::kMaxMediaSizeFieldNumber;
const int CDRomDriveInfo::kMinBlockSizeFieldNumber;
const int CDRomDriveInfo::kNumberOfMediaSupportedFieldNumber;
const int CDRomDriveInfo::kSCSIBusFieldNumber;
const int CDRomDriveInfo::kSCSILogicalUnitFieldNumber;
const int CDRomDriveInfo::kSCSIPortFieldNumber;
const int CDRomDriveInfo::kSCSITargetIdFieldNumber;
const int CDRomDriveInfo::kSerialNumberFieldNumber;
const int CDRomDriveInfo::kSizeFieldNumber;
const int CDRomDriveInfo::kTransferRateFieldNumber;
const int CDRomDriveInfo::kDriveIntegrityFieldNumber;
const int CDRomDriveInfo::kMediaLoadedFieldNumber;
const int CDRomDriveInfo::kNeedsCleaningFieldNumber;
const int CDRomDriveInfo::kCompressionMethodFieldNumber;
const int CDRomDriveInfo::kDescriptionFieldNumber;
const int CDRomDriveInfo::kDriveFieldNumber;
const int CDRomDriveInfo::kManufacturerFieldNumber;
const int CDRomDriveInfo::kMediaTypeFieldNumber;
const int CDRomDriveInfo::kPNPDeviceIDFieldNumber;
const int CDRomDriveInfo::kRevisionLevelFieldNumber;
const int CDRomDriveInfo::kStatusFieldNumber;
const int CDRomDriveInfo::kVolumeNameFieldNumber;
const int CDRomDriveInfo::kVolumeSerialNumberFieldNumber;
const int CDRomDriveInfo::kAvailabilityFieldNumber;
const int CDRomDriveInfo::kDefaultBlockSizeFieldNumber;
const int CDRomDriveInfo::kBuyTimeFieldNumber;
const int CDRomDriveInfo::kBuyPriceFieldNumber;
const int CDRomDriveInfo::kDCheckTimeFieldNumber;
const int CDRomDriveInfo::kOtherInfoFieldNumber;
const int CDRomDriveInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

CDRomDriveInfo::CDRomDriveInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CDRomDriveInfo::InitAsDefaultInstance() {
}

CDRomDriveInfo::CDRomDriveInfo(const CDRomDriveInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CDRomDriveInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  filesystemflagsex_ = 0;
  maxblocksize_ = GOOGLE_ULONGLONG(0);
  maximumcomponentlength_ = 0;
  maxmediasize_ = GOOGLE_ULONGLONG(0);
  minblocksize_ = GOOGLE_ULONGLONG(0);
  numberofmediasupported_ = 0;
  scsibus_ = 0;
  scsilogicalunit_ = 0;
  scsiport_ = 0;
  scsitargetid_ = 0;
  serialnumber_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  transferrate_ = 0;
  driveintegrity_ = 0;
  medialoaded_ = 0;
  needscleaning_ = 0;
  compressionmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  drive_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  revisionlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  volumename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  volumeserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  defaultblocksize_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CDRomDriveInfo::~CDRomDriveInfo() {
  SharedDtor();
}

void CDRomDriveInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
    delete compressionmethod_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (drive_ != &::google::protobuf::internal::kEmptyString) {
    delete drive_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    delete mediatype_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (revisionlevel_ != &::google::protobuf::internal::kEmptyString) {
    delete revisionlevel_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (volumename_ != &::google::protobuf::internal::kEmptyString) {
    delete volumename_;
  }
  if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete volumeserialnumber_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void CDRomDriveInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CDRomDriveInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CDRomDriveInfo_descriptor_;
}

const CDRomDriveInfo& CDRomDriveInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CDRomDriveInfo* CDRomDriveInfo::default_instance_ = NULL;

CDRomDriveInfo* CDRomDriveInfo::New() const {
  return new CDRomDriveInfo;
}

void CDRomDriveInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    filesystemflagsex_ = 0;
    maxblocksize_ = GOOGLE_ULONGLONG(0);
    maximumcomponentlength_ = 0;
    maxmediasize_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    minblocksize_ = GOOGLE_ULONGLONG(0);
    numberofmediasupported_ = 0;
    scsibus_ = 0;
    scsilogicalunit_ = 0;
    scsiport_ = 0;
    scsitargetid_ = 0;
    serialnumber_ = 0;
    size_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    transferrate_ = 0;
    driveintegrity_ = 0;
    medialoaded_ = 0;
    needscleaning_ = 0;
    if (has_compressionmethod()) {
      if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
        compressionmethod_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_drive()) {
      if (drive_ != &::google::protobuf::internal::kEmptyString) {
        drive_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_mediatype()) {
      if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
        mediatype_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_revisionlevel()) {
      if (revisionlevel_ != &::google::protobuf::internal::kEmptyString) {
        revisionlevel_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_volumename()) {
      if (volumename_ != &::google::protobuf::internal::kEmptyString) {
        volumename_->clear();
      }
    }
    if (has_volumeserialnumber()) {
      if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
        volumeserialnumber_->clear();
      }
    }
    availability_ = 0;
    defaultblocksize_ = 0;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CDRomDriveInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_FileSystemFlagsEx;
        break;
      }
      
      // optional int32 FileSystemFlagsEx = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_FileSystemFlagsEx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filesystemflagsex_)));
          set_has_filesystemflagsex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_MaxBlockSize;
        break;
      }
      
      // optional uint64 MaxBlockSize = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxblocksize_)));
          set_has_maxblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_MaximumComponentLength;
        break;
      }
      
      // optional int32 MaximumComponentLength = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaximumComponentLength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maximumcomponentlength_)));
          set_has_maximumcomponentlength();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_MaxMediaSize;
        break;
      }
      
      // optional uint64 MaxMediaSize = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxMediaSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxmediasize_)));
          set_has_maxmediasize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_MinBlockSize;
        break;
      }
      
      // optional uint64 MinBlockSize = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MinBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &minblocksize_)));
          set_has_minblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_NumberOfMediaSupported;
        break;
      }
      
      // optional int32 NumberOfMediaSupported = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfMediaSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberofmediasupported_)));
          set_has_numberofmediasupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_SCSIBus;
        break;
      }
      
      // optional int32 SCSIBus = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSIBus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsibus_)));
          set_has_scsibus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_SCSILogicalUnit;
        break;
      }
      
      // optional int32 SCSILogicalUnit = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSILogicalUnit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsilogicalunit_)));
          set_has_scsilogicalunit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_SCSIPort;
        break;
      }
      
      // optional int32 SCSIPort = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSIPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsiport_)));
          set_has_scsiport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_SCSITargetId;
        break;
      }
      
      // optional int32 SCSITargetId = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSITargetId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsitargetid_)));
          set_has_scsitargetid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_SerialNumber;
        break;
      }
      
      // optional int32 SerialNumber = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SerialNumber:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &serialnumber_)));
          set_has_serialnumber();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_Size;
        break;
      }
      
      // optional uint64 Size = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_TransferRate;
        break;
      }
      
      // optional int32 TransferRate = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TransferRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &transferrate_)));
          set_has_transferrate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_DriveIntegrity;
        break;
      }
      
      // optional int32 DriveIntegrity = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DriveIntegrity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &driveintegrity_)));
          set_has_driveintegrity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_MediaLoaded;
        break;
      }
      
      // optional int32 MediaLoaded = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MediaLoaded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &medialoaded_)));
          set_has_medialoaded();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_NeedsCleaning;
        break;
      }
      
      // optional int32 NeedsCleaning = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NeedsCleaning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &needscleaning_)));
          set_has_needscleaning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_CompressionMethod;
        break;
      }
      
      // optional string CompressionMethod = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CompressionMethod:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_compressionmethod()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->compressionmethod().data(), this->compressionmethod().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_Description;
        break;
      }
      
      // optional string Description = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_Drive;
        break;
      }
      
      // optional string Drive = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Drive:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_drive()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->drive().data(), this->drive().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(202)) goto parse_MediaType;
        break;
      }
      
      // optional string MediaType = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MediaType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mediatype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mediatype().data(), this->mediatype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_RevisionLevel;
        break;
      }
      
      // optional string RevisionLevel = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_RevisionLevel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_revisionlevel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->revisionlevel().data(), this->revisionlevel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_Status;
        break;
      }
      
      // optional string Status = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_VolumeName;
        break;
      }
      
      // optional string VolumeName = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_VolumeName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volumename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->volumename().data(), this->volumename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_VolumeSerialNumber;
        break;
      }
      
      // optional string VolumeSerialNumber = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_VolumeSerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volumeserialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->volumeserialnumber().data(), this->volumeserialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(248)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(256)) goto parse_DefaultBlockSize;
        break;
      }
      
      // optional int32 DefaultBlockSize = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DefaultBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &defaultblocksize_)));
          set_has_defaultblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(265)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(281)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(290)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CDRomDriveInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 FileSystemFlagsEx = 4;
  if (has_filesystemflagsex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->filesystemflagsex(), output);
  }
  
  // optional uint64 MaxBlockSize = 5;
  if (has_maxblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->maxblocksize(), output);
  }
  
  // optional int32 MaximumComponentLength = 6;
  if (has_maximumcomponentlength()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->maximumcomponentlength(), output);
  }
  
  // optional uint64 MaxMediaSize = 7;
  if (has_maxmediasize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->maxmediasize(), output);
  }
  
  // optional uint64 MinBlockSize = 8;
  if (has_minblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->minblocksize(), output);
  }
  
  // optional int32 NumberOfMediaSupported = 9;
  if (has_numberofmediasupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->numberofmediasupported(), output);
  }
  
  // optional int32 SCSIBus = 10;
  if (has_scsibus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->scsibus(), output);
  }
  
  // optional int32 SCSILogicalUnit = 11;
  if (has_scsilogicalunit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->scsilogicalunit(), output);
  }
  
  // optional int32 SCSIPort = 12;
  if (has_scsiport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->scsiport(), output);
  }
  
  // optional int32 SCSITargetId = 13;
  if (has_scsitargetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->scsitargetid(), output);
  }
  
  // optional int32 SerialNumber = 14;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->serialnumber(), output);
  }
  
  // optional uint64 Size = 15;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->size(), output);
  }
  
  // optional int32 TransferRate = 17;
  if (has_transferrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->transferrate(), output);
  }
  
  // optional int32 DriveIntegrity = 18;
  if (has_driveintegrity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(18, this->driveintegrity(), output);
  }
  
  // optional int32 MediaLoaded = 19;
  if (has_medialoaded()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(19, this->medialoaded(), output);
  }
  
  // optional int32 NeedsCleaning = 20;
  if (has_needscleaning()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(20, this->needscleaning(), output);
  }
  
  // optional string CompressionMethod = 21;
  if (has_compressionmethod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->compressionmethod().data(), this->compressionmethod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->compressionmethod(), output);
  }
  
  // optional string Description = 22;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->description(), output);
  }
  
  // optional string Drive = 23;
  if (has_drive()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->drive().data(), this->drive().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      23, this->drive(), output);
  }
  
  // optional string Manufacturer = 24;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->manufacturer(), output);
  }
  
  // optional string MediaType = 25;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediatype().data(), this->mediatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      25, this->mediatype(), output);
  }
  
  // optional string PNPDeviceID = 26;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->pnpdeviceid(), output);
  }
  
  // optional string RevisionLevel = 27;
  if (has_revisionlevel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->revisionlevel().data(), this->revisionlevel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->revisionlevel(), output);
  }
  
  // optional string Status = 28;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      28, this->status(), output);
  }
  
  // optional string VolumeName = 29;
  if (has_volumename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumename().data(), this->volumename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      29, this->volumename(), output);
  }
  
  // optional string VolumeSerialNumber = 30;
  if (has_volumeserialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumeserialnumber().data(), this->volumeserialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->volumeserialnumber(), output);
  }
  
  // optional int32 Availability = 31;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(31, this->availability(), output);
  }
  
  // optional int32 DefaultBlockSize = 32;
  if (has_defaultblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(32, this->defaultblocksize(), output);
  }
  
  // optional double BuyTime = 33;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(33, this->buytime(), output);
  }
  
  // optional string BuyPrice = 34;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      34, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 35;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(35, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 36;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      36, this->otherinfo(), output);
  }
  
  // optional string BuyName = 37;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      37, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CDRomDriveInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 FileSystemFlagsEx = 4;
  if (has_filesystemflagsex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->filesystemflagsex(), target);
  }
  
  // optional uint64 MaxBlockSize = 5;
  if (has_maxblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->maxblocksize(), target);
  }
  
  // optional int32 MaximumComponentLength = 6;
  if (has_maximumcomponentlength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->maximumcomponentlength(), target);
  }
  
  // optional uint64 MaxMediaSize = 7;
  if (has_maxmediasize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->maxmediasize(), target);
  }
  
  // optional uint64 MinBlockSize = 8;
  if (has_minblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->minblocksize(), target);
  }
  
  // optional int32 NumberOfMediaSupported = 9;
  if (has_numberofmediasupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->numberofmediasupported(), target);
  }
  
  // optional int32 SCSIBus = 10;
  if (has_scsibus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->scsibus(), target);
  }
  
  // optional int32 SCSILogicalUnit = 11;
  if (has_scsilogicalunit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->scsilogicalunit(), target);
  }
  
  // optional int32 SCSIPort = 12;
  if (has_scsiport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->scsiport(), target);
  }
  
  // optional int32 SCSITargetId = 13;
  if (has_scsitargetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->scsitargetid(), target);
  }
  
  // optional int32 SerialNumber = 14;
  if (has_serialnumber()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->serialnumber(), target);
  }
  
  // optional uint64 Size = 15;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->size(), target);
  }
  
  // optional int32 TransferRate = 17;
  if (has_transferrate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->transferrate(), target);
  }
  
  // optional int32 DriveIntegrity = 18;
  if (has_driveintegrity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(18, this->driveintegrity(), target);
  }
  
  // optional int32 MediaLoaded = 19;
  if (has_medialoaded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(19, this->medialoaded(), target);
  }
  
  // optional int32 NeedsCleaning = 20;
  if (has_needscleaning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(20, this->needscleaning(), target);
  }
  
  // optional string CompressionMethod = 21;
  if (has_compressionmethod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->compressionmethod().data(), this->compressionmethod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->compressionmethod(), target);
  }
  
  // optional string Description = 22;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->description(), target);
  }
  
  // optional string Drive = 23;
  if (has_drive()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->drive().data(), this->drive().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        23, this->drive(), target);
  }
  
  // optional string Manufacturer = 24;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->manufacturer(), target);
  }
  
  // optional string MediaType = 25;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediatype().data(), this->mediatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        25, this->mediatype(), target);
  }
  
  // optional string PNPDeviceID = 26;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->pnpdeviceid(), target);
  }
  
  // optional string RevisionLevel = 27;
  if (has_revisionlevel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->revisionlevel().data(), this->revisionlevel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->revisionlevel(), target);
  }
  
  // optional string Status = 28;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        28, this->status(), target);
  }
  
  // optional string VolumeName = 29;
  if (has_volumename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumename().data(), this->volumename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        29, this->volumename(), target);
  }
  
  // optional string VolumeSerialNumber = 30;
  if (has_volumeserialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumeserialnumber().data(), this->volumeserialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->volumeserialnumber(), target);
  }
  
  // optional int32 Availability = 31;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(31, this->availability(), target);
  }
  
  // optional int32 DefaultBlockSize = 32;
  if (has_defaultblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(32, this->defaultblocksize(), target);
  }
  
  // optional double BuyTime = 33;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(33, this->buytime(), target);
  }
  
  // optional string BuyPrice = 34;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        34, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 35;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(35, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 36;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        36, this->otherinfo(), target);
  }
  
  // optional string BuyName = 37;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        37, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CDRomDriveInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 FileSystemFlagsEx = 4;
    if (has_filesystemflagsex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filesystemflagsex());
    }
    
    // optional uint64 MaxBlockSize = 5;
    if (has_maxblocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxblocksize());
    }
    
    // optional int32 MaximumComponentLength = 6;
    if (has_maximumcomponentlength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maximumcomponentlength());
    }
    
    // optional uint64 MaxMediaSize = 7;
    if (has_maxmediasize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxmediasize());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 MinBlockSize = 8;
    if (has_minblocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->minblocksize());
    }
    
    // optional int32 NumberOfMediaSupported = 9;
    if (has_numberofmediasupported()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberofmediasupported());
    }
    
    // optional int32 SCSIBus = 10;
    if (has_scsibus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsibus());
    }
    
    // optional int32 SCSILogicalUnit = 11;
    if (has_scsilogicalunit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsilogicalunit());
    }
    
    // optional int32 SCSIPort = 12;
    if (has_scsiport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsiport());
    }
    
    // optional int32 SCSITargetId = 13;
    if (has_scsitargetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsitargetid());
    }
    
    // optional int32 SerialNumber = 14;
    if (has_serialnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->serialnumber());
    }
    
    // optional uint64 Size = 15;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 TransferRate = 17;
    if (has_transferrate()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->transferrate());
    }
    
    // optional int32 DriveIntegrity = 18;
    if (has_driveintegrity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->driveintegrity());
    }
    
    // optional int32 MediaLoaded = 19;
    if (has_medialoaded()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->medialoaded());
    }
    
    // optional int32 NeedsCleaning = 20;
    if (has_needscleaning()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->needscleaning());
    }
    
    // optional string CompressionMethod = 21;
    if (has_compressionmethod()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->compressionmethod());
    }
    
    // optional string Description = 22;
    if (has_description()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Drive = 23;
    if (has_drive()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->drive());
    }
    
    // optional string Manufacturer = 24;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string MediaType = 25;
    if (has_mediatype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mediatype());
    }
    
    // optional string PNPDeviceID = 26;
    if (has_pnpdeviceid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string RevisionLevel = 27;
    if (has_revisionlevel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->revisionlevel());
    }
    
    // optional string Status = 28;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string VolumeName = 29;
    if (has_volumename()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volumename());
    }
    
    // optional string VolumeSerialNumber = 30;
    if (has_volumeserialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volumeserialnumber());
    }
    
    // optional int32 Availability = 31;
    if (has_availability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 DefaultBlockSize = 32;
    if (has_defaultblocksize()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->defaultblocksize());
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional double BuyTime = 33;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 34;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 35;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 36;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 37;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CDRomDriveInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CDRomDriveInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CDRomDriveInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CDRomDriveInfo::MergeFrom(const CDRomDriveInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_filesystemflagsex()) {
      set_filesystemflagsex(from.filesystemflagsex());
    }
    if (from.has_maxblocksize()) {
      set_maxblocksize(from.maxblocksize());
    }
    if (from.has_maximumcomponentlength()) {
      set_maximumcomponentlength(from.maximumcomponentlength());
    }
    if (from.has_maxmediasize()) {
      set_maxmediasize(from.maxmediasize());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_minblocksize()) {
      set_minblocksize(from.minblocksize());
    }
    if (from.has_numberofmediasupported()) {
      set_numberofmediasupported(from.numberofmediasupported());
    }
    if (from.has_scsibus()) {
      set_scsibus(from.scsibus());
    }
    if (from.has_scsilogicalunit()) {
      set_scsilogicalunit(from.scsilogicalunit());
    }
    if (from.has_scsiport()) {
      set_scsiport(from.scsiport());
    }
    if (from.has_scsitargetid()) {
      set_scsitargetid(from.scsitargetid());
    }
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_transferrate()) {
      set_transferrate(from.transferrate());
    }
    if (from.has_driveintegrity()) {
      set_driveintegrity(from.driveintegrity());
    }
    if (from.has_medialoaded()) {
      set_medialoaded(from.medialoaded());
    }
    if (from.has_needscleaning()) {
      set_needscleaning(from.needscleaning());
    }
    if (from.has_compressionmethod()) {
      set_compressionmethod(from.compressionmethod());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_drive()) {
      set_drive(from.drive());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_mediatype()) {
      set_mediatype(from.mediatype());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_revisionlevel()) {
      set_revisionlevel(from.revisionlevel());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_volumename()) {
      set_volumename(from.volumename());
    }
    if (from.has_volumeserialnumber()) {
      set_volumeserialnumber(from.volumeserialnumber());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_defaultblocksize()) {
      set_defaultblocksize(from.defaultblocksize());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CDRomDriveInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDRomDriveInfo::CopyFrom(const CDRomDriveInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDRomDriveInfo::IsInitialized() const {
  
  return true;
}

void CDRomDriveInfo::Swap(CDRomDriveInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(filesystemflagsex_, other->filesystemflagsex_);
    std::swap(maxblocksize_, other->maxblocksize_);
    std::swap(maximumcomponentlength_, other->maximumcomponentlength_);
    std::swap(maxmediasize_, other->maxmediasize_);
    std::swap(minblocksize_, other->minblocksize_);
    std::swap(numberofmediasupported_, other->numberofmediasupported_);
    std::swap(scsibus_, other->scsibus_);
    std::swap(scsilogicalunit_, other->scsilogicalunit_);
    std::swap(scsiport_, other->scsiport_);
    std::swap(scsitargetid_, other->scsitargetid_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(size_, other->size_);
    std::swap(transferrate_, other->transferrate_);
    std::swap(driveintegrity_, other->driveintegrity_);
    std::swap(medialoaded_, other->medialoaded_);
    std::swap(needscleaning_, other->needscleaning_);
    std::swap(compressionmethod_, other->compressionmethod_);
    std::swap(description_, other->description_);
    std::swap(drive_, other->drive_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(mediatype_, other->mediatype_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(revisionlevel_, other->revisionlevel_);
    std::swap(status_, other->status_);
    std::swap(volumename_, other->volumename_);
    std::swap(volumeserialnumber_, other->volumeserialnumber_);
    std::swap(availability_, other->availability_);
    std::swap(defaultblocksize_, other->defaultblocksize_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CDRomDriveInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CDRomDriveInfo_descriptor_;
  metadata.reflection = CDRomDriveInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CDRomDriveInfoList::kListFieldNumber;
const int CDRomDriveInfoList::kAlarmedFieldNumber;
const int CDRomDriveInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

CDRomDriveInfoList::CDRomDriveInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CDRomDriveInfoList::InitAsDefaultInstance() {
}

CDRomDriveInfoList::CDRomDriveInfoList(const CDRomDriveInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CDRomDriveInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CDRomDriveInfoList::~CDRomDriveInfoList() {
  SharedDtor();
}

void CDRomDriveInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void CDRomDriveInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CDRomDriveInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CDRomDriveInfoList_descriptor_;
}

const CDRomDriveInfoList& CDRomDriveInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CDRomDriveInfoList* CDRomDriveInfoList::default_instance_ = NULL;

CDRomDriveInfoList* CDRomDriveInfoList::New() const {
  return new CDRomDriveInfoList;
}

void CDRomDriveInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CDRomDriveInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CDRomDriveInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CDRomDriveInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CDRomDriveInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CDRomDriveInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CDRomDriveInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CDRomDriveInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.CDRomDriveInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CDRomDriveInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CDRomDriveInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CDRomDriveInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CDRomDriveInfoList::MergeFrom(const CDRomDriveInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CDRomDriveInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDRomDriveInfoList::CopyFrom(const CDRomDriveInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDRomDriveInfoList::IsInitialized() const {
  
  return true;
}

void CDRomDriveInfoList::Swap(CDRomDriveInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CDRomDriveInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CDRomDriveInfoList_descriptor_;
  metadata.reflection = CDRomDriveInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ComputerSystemInfo::kPackageCodeFieldNumber;
const int ComputerSystemInfo::kChecktypeFieldNumber;
const int ComputerSystemInfo::kScanTimeFieldNumber;
const int ComputerSystemInfo::kAddtimeFieldNumber;
const int ComputerSystemInfo::kDomainRoleFieldNumber;
const int ComputerSystemInfo::kFrontPanelResetStatusFieldNumber;
const int ComputerSystemInfo::kKeyboardPasswordStatusFieldNumber;
const int ComputerSystemInfo::kPowerOnPasswordStatusFieldNumber;
const int ComputerSystemInfo::kPowerStateFieldNumber;
const int ComputerSystemInfo::kPowerSupplyStateFieldNumber;
const int ComputerSystemInfo::kResetCapabilityFieldNumber;
const int ComputerSystemInfo::kSystemStartupDelayFieldNumber;
const int ComputerSystemInfo::kThermalStateFieldNumber;
const int ComputerSystemInfo::kWakeUpTypeFieldNumber;
const int ComputerSystemInfo::kCurrentTimeZoneFieldNumber;
const int ComputerSystemInfo::kResetCountFieldNumber;
const int ComputerSystemInfo::kResetLimitFieldNumber;
const int ComputerSystemInfo::kNumberOfProcessorsFieldNumber;
const int ComputerSystemInfo::kTotalPhysicalMemoryFieldNumber;
const int ComputerSystemInfo::kPauseAfterResetFieldNumber;
const int ComputerSystemInfo::kAutomaticResetBootOptionFieldNumber;
const int ComputerSystemInfo::kAutomaticResetCapabilityFieldNumber;
const int ComputerSystemInfo::kBootROMSupportedFieldNumber;
const int ComputerSystemInfo::kEnableDaylightSavingsTimeFieldNumber;
const int ComputerSystemInfo::kInfraredSupportedFieldNumber;
const int ComputerSystemInfo::kNetworkServerModeEnabledFieldNumber;
const int ComputerSystemInfo::kPartOfDomainFieldNumber;
const int ComputerSystemInfo::kSystemStartupSettingFieldNumber;
const int ComputerSystemInfo::kBootupStateFieldNumber;
const int ComputerSystemInfo::kDescriptionFieldNumber;
const int ComputerSystemInfo::kDNSHostNameFieldNumber;
const int ComputerSystemInfo::kDomainFieldNumber;
const int ComputerSystemInfo::kManufacturerFieldNumber;
const int ComputerSystemInfo::kModelFieldNumber;
const int ComputerSystemInfo::kPrimaryOwnerNameFieldNumber;
const int ComputerSystemInfo::kRolesFieldNumber;
const int ComputerSystemInfo::kStatusFieldNumber;
const int ComputerSystemInfo::kSystemStartupOptionsFieldNumber;
const int ComputerSystemInfo::kSystemTypeFieldNumber;
const int ComputerSystemInfo::kUserNameFieldNumber;
const int ComputerSystemInfo::kAdminPasswordStatusFieldNumber;
const int ComputerSystemInfo::kChassisBootupStateFieldNumber;
#endif  // !_MSC_VER

ComputerSystemInfo::ComputerSystemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ComputerSystemInfo::InitAsDefaultInstance() {
}

ComputerSystemInfo::ComputerSystemInfo(const ComputerSystemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ComputerSystemInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  domainrole_ = 0;
  frontpanelresetstatus_ = 0;
  keyboardpasswordstatus_ = 0;
  poweronpasswordstatus_ = 0;
  powerstate_ = 0;
  powersupplystate_ = 0;
  resetcapability_ = 0;
  systemstartupdelay_ = 0;
  thermalstate_ = 0;
  wakeuptype_ = 0;
  currenttimezone_ = 0;
  resetcount_ = 0;
  resetlimit_ = 0;
  numberofprocessors_ = 0;
  totalphysicalmemory_ = GOOGLE_ULONGLONG(0);
  pauseafterreset_ = GOOGLE_LONGLONG(0);
  automaticresetbootoption_ = 0;
  automaticresetcapability_ = 0;
  bootromsupported_ = 0;
  enabledaylightsavingstime_ = 0;
  infraredsupported_ = 0;
  networkservermodeenabled_ = 0;
  partofdomain_ = 0;
  systemstartupsetting_ = 0;
  bootupstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dnshostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  primaryownername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  roles_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  systemstartupoptions_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  adminpasswordstatus_ = 0;
  chassisbootupstate_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputerSystemInfo::~ComputerSystemInfo() {
  SharedDtor();
}

void ComputerSystemInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (bootupstate_ != &::google::protobuf::internal::kEmptyString) {
    delete bootupstate_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (dnshostname_ != &::google::protobuf::internal::kEmptyString) {
    delete dnshostname_;
  }
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (primaryownername_ != &::google::protobuf::internal::kEmptyString) {
    delete primaryownername_;
  }
  if (roles_ != &::google::protobuf::internal::kEmptyString) {
    delete roles_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (systemstartupoptions_ != &::google::protobuf::internal::kEmptyString) {
    delete systemstartupoptions_;
  }
  if (systemtype_ != &::google::protobuf::internal::kEmptyString) {
    delete systemtype_;
  }
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (this != default_instance_) {
  }
}

void ComputerSystemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputerSystemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputerSystemInfo_descriptor_;
}

const ComputerSystemInfo& ComputerSystemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ComputerSystemInfo* ComputerSystemInfo::default_instance_ = NULL;

ComputerSystemInfo* ComputerSystemInfo::New() const {
  return new ComputerSystemInfo;
}

void ComputerSystemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    domainrole_ = 0;
    frontpanelresetstatus_ = 0;
    keyboardpasswordstatus_ = 0;
    poweronpasswordstatus_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    powerstate_ = 0;
    powersupplystate_ = 0;
    resetcapability_ = 0;
    systemstartupdelay_ = 0;
    thermalstate_ = 0;
    wakeuptype_ = 0;
    currenttimezone_ = 0;
    resetcount_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    resetlimit_ = 0;
    numberofprocessors_ = 0;
    totalphysicalmemory_ = GOOGLE_ULONGLONG(0);
    pauseafterreset_ = GOOGLE_LONGLONG(0);
    automaticresetbootoption_ = 0;
    automaticresetcapability_ = 0;
    bootromsupported_ = 0;
    enabledaylightsavingstime_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    infraredsupported_ = 0;
    networkservermodeenabled_ = 0;
    partofdomain_ = 0;
    systemstartupsetting_ = 0;
    if (has_bootupstate()) {
      if (bootupstate_ != &::google::protobuf::internal::kEmptyString) {
        bootupstate_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_dnshostname()) {
      if (dnshostname_ != &::google::protobuf::internal::kEmptyString) {
        dnshostname_->clear();
      }
    }
    if (has_domain()) {
      if (domain_ != &::google::protobuf::internal::kEmptyString) {
        domain_->clear();
      }
    }
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::kEmptyString) {
        model_->clear();
      }
    }
    if (has_primaryownername()) {
      if (primaryownername_ != &::google::protobuf::internal::kEmptyString) {
        primaryownername_->clear();
      }
    }
    if (has_roles()) {
      if (roles_ != &::google::protobuf::internal::kEmptyString) {
        roles_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_systemstartupoptions()) {
      if (systemstartupoptions_ != &::google::protobuf::internal::kEmptyString) {
        systemstartupoptions_->clear();
      }
    }
    if (has_systemtype()) {
      if (systemtype_ != &::google::protobuf::internal::kEmptyString) {
        systemtype_->clear();
      }
    }
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    adminpasswordstatus_ = 0;
    chassisbootupstate_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ComputerSystemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_DomainRole;
        break;
      }
      
      // optional int32 DomainRole = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DomainRole:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &domainrole_)));
          set_has_domainrole();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_FrontPanelResetStatus;
        break;
      }
      
      // optional int32 FrontPanelResetStatus = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_FrontPanelResetStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frontpanelresetstatus_)));
          set_has_frontpanelresetstatus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_KeyboardPasswordStatus;
        break;
      }
      
      // optional int32 KeyboardPasswordStatus = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KeyboardPasswordStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &keyboardpasswordstatus_)));
          set_has_keyboardpasswordstatus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_PowerOnPasswordStatus;
        break;
      }
      
      // optional int32 PowerOnPasswordStatus = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PowerOnPasswordStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &poweronpasswordstatus_)));
          set_has_poweronpasswordstatus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_PowerState;
        break;
      }
      
      // optional int32 PowerState = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PowerState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &powerstate_)));
          set_has_powerstate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_PowerSupplyState;
        break;
      }
      
      // optional int32 PowerSupplyState = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PowerSupplyState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &powersupplystate_)));
          set_has_powersupplystate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_ResetCapability;
        break;
      }
      
      // optional int32 ResetCapability = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ResetCapability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resetcapability_)));
          set_has_resetcapability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_SystemStartupDelay;
        break;
      }
      
      // optional int32 SystemStartupDelay = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SystemStartupDelay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &systemstartupdelay_)));
          set_has_systemstartupdelay();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_ThermalState;
        break;
      }
      
      // optional int32 ThermalState = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ThermalState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &thermalstate_)));
          set_has_thermalstate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_WakeUpType;
        break;
      }
      
      // optional int32 WakeUpType = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WakeUpType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wakeuptype_)));
          set_has_wakeuptype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_CurrentTimeZone;
        break;
      }
      
      // optional int32 CurrentTimeZone = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentTimeZone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currenttimezone_)));
          set_has_currenttimezone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_ResetCount;
        break;
      }
      
      // optional int32 ResetCount = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ResetCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resetcount_)));
          set_has_resetcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_ResetLimit;
        break;
      }
      
      // optional int32 ResetLimit = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ResetLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resetlimit_)));
          set_has_resetlimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_NumberOfProcessors;
        break;
      }
      
      // optional int32 NumberOfProcessors = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfProcessors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberofprocessors_)));
          set_has_numberofprocessors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_TotalPhysicalMemory;
        break;
      }
      
      // optional uint64 TotalPhysicalMemory = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalPhysicalMemory:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &totalphysicalmemory_)));
          set_has_totalphysicalmemory();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_PauseAfterReset;
        break;
      }
      
      // optional int64 PauseAfterReset = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PauseAfterReset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pauseafterreset_)));
          set_has_pauseafterreset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_AutomaticResetBootOption;
        break;
      }
      
      // optional int32 AutomaticResetBootOption = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AutomaticResetBootOption:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &automaticresetbootoption_)));
          set_has_automaticresetbootoption();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_AutomaticResetCapability;
        break;
      }
      
      // optional int32 AutomaticResetCapability = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AutomaticResetCapability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &automaticresetcapability_)));
          set_has_automaticresetcapability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_BootROMSupported;
        break;
      }
      
      // optional int32 BootROMSupported = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BootROMSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bootromsupported_)));
          set_has_bootromsupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_EnableDaylightSavingsTime;
        break;
      }
      
      // optional int32 EnableDaylightSavingsTime = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_EnableDaylightSavingsTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enabledaylightsavingstime_)));
          set_has_enabledaylightsavingstime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_InfraredSupported;
        break;
      }
      
      // optional int32 InfraredSupported = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_InfraredSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &infraredsupported_)));
          set_has_infraredsupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_NetworkServerModeEnabled;
        break;
      }
      
      // optional int32 NetworkServerModeEnabled = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NetworkServerModeEnabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &networkservermodeenabled_)));
          set_has_networkservermodeenabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_PartOfDomain;
        break;
      }
      
      // optional int32 PartOfDomain = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PartOfDomain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &partofdomain_)));
          set_has_partofdomain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(216)) goto parse_SystemStartupSetting;
        break;
      }
      
      // optional int32 SystemStartupSetting = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SystemStartupSetting:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &systemstartupsetting_)));
          set_has_systemstartupsetting();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_BootupState;
        break;
      }
      
      // optional string BootupState = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BootupState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bootupstate()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bootupstate().data(), this->bootupstate().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_Description;
        break;
      }
      
      // optional string Description = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_DNSHostName;
        break;
      }
      
      // optional string DNSHostName = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DNSHostName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dnshostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dnshostname().data(), this->dnshostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(266)) goto parse_Domain;
        break;
      }
      
      // optional string Domain = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Domain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_domain()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->domain().data(), this->domain().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(282)) goto parse_Model;
        break;
      }
      
      // optional string Model = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(290)) goto parse_PrimaryOwnerName;
        break;
      }
      
      // optional string PrimaryOwnerName = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PrimaryOwnerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_primaryownername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->primaryownername().data(), this->primaryownername().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_Roles;
        break;
      }
      
      // optional string Roles = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->roles().data(), this->roles().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(306)) goto parse_Status;
        break;
      }
      
      // optional string Status = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(314)) goto parse_SystemStartupOptions;
        break;
      }
      
      // optional string SystemStartupOptions = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SystemStartupOptions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_systemstartupoptions()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->systemstartupoptions().data(), this->systemstartupoptions().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_SystemType;
        break;
      }
      
      // optional string SystemType = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SystemType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_systemtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->systemtype().data(), this->systemtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_UserName;
        break;
      }
      
      // optional string UserName = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_UserName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(336)) goto parse_AdminPasswordStatus;
        break;
      }
      
      // optional int32 AdminPasswordStatus = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AdminPasswordStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &adminpasswordstatus_)));
          set_has_adminpasswordstatus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(344)) goto parse_ChassisBootupState;
        break;
      }
      
      // optional int32 ChassisBootupState = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ChassisBootupState:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chassisbootupstate_)));
          set_has_chassisbootupstate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ComputerSystemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 DomainRole = 4;
  if (has_domainrole()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->domainrole(), output);
  }
  
  // optional int32 FrontPanelResetStatus = 5;
  if (has_frontpanelresetstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->frontpanelresetstatus(), output);
  }
  
  // optional int32 KeyboardPasswordStatus = 6;
  if (has_keyboardpasswordstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->keyboardpasswordstatus(), output);
  }
  
  // optional int32 PowerOnPasswordStatus = 7;
  if (has_poweronpasswordstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->poweronpasswordstatus(), output);
  }
  
  // optional int32 PowerState = 8;
  if (has_powerstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->powerstate(), output);
  }
  
  // optional int32 PowerSupplyState = 9;
  if (has_powersupplystate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->powersupplystate(), output);
  }
  
  // optional int32 ResetCapability = 10;
  if (has_resetcapability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->resetcapability(), output);
  }
  
  // optional int32 SystemStartupDelay = 11;
  if (has_systemstartupdelay()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->systemstartupdelay(), output);
  }
  
  // optional int32 ThermalState = 12;
  if (has_thermalstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->thermalstate(), output);
  }
  
  // optional int32 WakeUpType = 13;
  if (has_wakeuptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->wakeuptype(), output);
  }
  
  // optional int32 CurrentTimeZone = 14;
  if (has_currenttimezone()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->currenttimezone(), output);
  }
  
  // optional int32 ResetCount = 15;
  if (has_resetcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->resetcount(), output);
  }
  
  // optional int32 ResetLimit = 16;
  if (has_resetlimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->resetlimit(), output);
  }
  
  // optional int32 NumberOfProcessors = 17;
  if (has_numberofprocessors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->numberofprocessors(), output);
  }
  
  // optional uint64 TotalPhysicalMemory = 18;
  if (has_totalphysicalmemory()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->totalphysicalmemory(), output);
  }
  
  // optional int64 PauseAfterReset = 19;
  if (has_pauseafterreset()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->pauseafterreset(), output);
  }
  
  // optional int32 AutomaticResetBootOption = 20;
  if (has_automaticresetbootoption()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(20, this->automaticresetbootoption(), output);
  }
  
  // optional int32 AutomaticResetCapability = 21;
  if (has_automaticresetcapability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(21, this->automaticresetcapability(), output);
  }
  
  // optional int32 BootROMSupported = 22;
  if (has_bootromsupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->bootromsupported(), output);
  }
  
  // optional int32 EnableDaylightSavingsTime = 23;
  if (has_enabledaylightsavingstime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(23, this->enabledaylightsavingstime(), output);
  }
  
  // optional int32 InfraredSupported = 24;
  if (has_infraredsupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(24, this->infraredsupported(), output);
  }
  
  // optional int32 NetworkServerModeEnabled = 25;
  if (has_networkservermodeenabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(25, this->networkservermodeenabled(), output);
  }
  
  // optional int32 PartOfDomain = 26;
  if (has_partofdomain()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(26, this->partofdomain(), output);
  }
  
  // optional int32 SystemStartupSetting = 27;
  if (has_systemstartupsetting()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(27, this->systemstartupsetting(), output);
  }
  
  // optional string BootupState = 28;
  if (has_bootupstate()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bootupstate().data(), this->bootupstate().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      28, this->bootupstate(), output);
  }
  
  // optional string Description = 30;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->description(), output);
  }
  
  // optional string DNSHostName = 31;
  if (has_dnshostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dnshostname().data(), this->dnshostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      31, this->dnshostname(), output);
  }
  
  // optional string Domain = 33;
  if (has_domain()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->domain().data(), this->domain().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      33, this->domain(), output);
  }
  
  // optional string Manufacturer = 34;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      34, this->manufacturer(), output);
  }
  
  // optional string Model = 35;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      35, this->model(), output);
  }
  
  // optional string PrimaryOwnerName = 36;
  if (has_primaryownername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->primaryownername().data(), this->primaryownername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      36, this->primaryownername(), output);
  }
  
  // optional string Roles = 37;
  if (has_roles()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roles().data(), this->roles().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      37, this->roles(), output);
  }
  
  // optional string Status = 38;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      38, this->status(), output);
  }
  
  // optional string SystemStartupOptions = 39;
  if (has_systemstartupoptions()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->systemstartupoptions().data(), this->systemstartupoptions().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      39, this->systemstartupoptions(), output);
  }
  
  // optional string SystemType = 40;
  if (has_systemtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->systemtype().data(), this->systemtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      40, this->systemtype(), output);
  }
  
  // optional string UserName = 41;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      41, this->username(), output);
  }
  
  // optional int32 AdminPasswordStatus = 42;
  if (has_adminpasswordstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(42, this->adminpasswordstatus(), output);
  }
  
  // optional int32 ChassisBootupState = 43;
  if (has_chassisbootupstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(43, this->chassisbootupstate(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ComputerSystemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 DomainRole = 4;
  if (has_domainrole()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->domainrole(), target);
  }
  
  // optional int32 FrontPanelResetStatus = 5;
  if (has_frontpanelresetstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->frontpanelresetstatus(), target);
  }
  
  // optional int32 KeyboardPasswordStatus = 6;
  if (has_keyboardpasswordstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->keyboardpasswordstatus(), target);
  }
  
  // optional int32 PowerOnPasswordStatus = 7;
  if (has_poweronpasswordstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->poweronpasswordstatus(), target);
  }
  
  // optional int32 PowerState = 8;
  if (has_powerstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->powerstate(), target);
  }
  
  // optional int32 PowerSupplyState = 9;
  if (has_powersupplystate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->powersupplystate(), target);
  }
  
  // optional int32 ResetCapability = 10;
  if (has_resetcapability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->resetcapability(), target);
  }
  
  // optional int32 SystemStartupDelay = 11;
  if (has_systemstartupdelay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->systemstartupdelay(), target);
  }
  
  // optional int32 ThermalState = 12;
  if (has_thermalstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->thermalstate(), target);
  }
  
  // optional int32 WakeUpType = 13;
  if (has_wakeuptype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->wakeuptype(), target);
  }
  
  // optional int32 CurrentTimeZone = 14;
  if (has_currenttimezone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->currenttimezone(), target);
  }
  
  // optional int32 ResetCount = 15;
  if (has_resetcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->resetcount(), target);
  }
  
  // optional int32 ResetLimit = 16;
  if (has_resetlimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->resetlimit(), target);
  }
  
  // optional int32 NumberOfProcessors = 17;
  if (has_numberofprocessors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->numberofprocessors(), target);
  }
  
  // optional uint64 TotalPhysicalMemory = 18;
  if (has_totalphysicalmemory()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->totalphysicalmemory(), target);
  }
  
  // optional int64 PauseAfterReset = 19;
  if (has_pauseafterreset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->pauseafterreset(), target);
  }
  
  // optional int32 AutomaticResetBootOption = 20;
  if (has_automaticresetbootoption()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(20, this->automaticresetbootoption(), target);
  }
  
  // optional int32 AutomaticResetCapability = 21;
  if (has_automaticresetcapability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(21, this->automaticresetcapability(), target);
  }
  
  // optional int32 BootROMSupported = 22;
  if (has_bootromsupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->bootromsupported(), target);
  }
  
  // optional int32 EnableDaylightSavingsTime = 23;
  if (has_enabledaylightsavingstime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(23, this->enabledaylightsavingstime(), target);
  }
  
  // optional int32 InfraredSupported = 24;
  if (has_infraredsupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(24, this->infraredsupported(), target);
  }
  
  // optional int32 NetworkServerModeEnabled = 25;
  if (has_networkservermodeenabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(25, this->networkservermodeenabled(), target);
  }
  
  // optional int32 PartOfDomain = 26;
  if (has_partofdomain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(26, this->partofdomain(), target);
  }
  
  // optional int32 SystemStartupSetting = 27;
  if (has_systemstartupsetting()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(27, this->systemstartupsetting(), target);
  }
  
  // optional string BootupState = 28;
  if (has_bootupstate()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bootupstate().data(), this->bootupstate().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        28, this->bootupstate(), target);
  }
  
  // optional string Description = 30;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->description(), target);
  }
  
  // optional string DNSHostName = 31;
  if (has_dnshostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dnshostname().data(), this->dnshostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        31, this->dnshostname(), target);
  }
  
  // optional string Domain = 33;
  if (has_domain()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->domain().data(), this->domain().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        33, this->domain(), target);
  }
  
  // optional string Manufacturer = 34;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        34, this->manufacturer(), target);
  }
  
  // optional string Model = 35;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        35, this->model(), target);
  }
  
  // optional string PrimaryOwnerName = 36;
  if (has_primaryownername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->primaryownername().data(), this->primaryownername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        36, this->primaryownername(), target);
  }
  
  // optional string Roles = 37;
  if (has_roles()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->roles().data(), this->roles().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        37, this->roles(), target);
  }
  
  // optional string Status = 38;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        38, this->status(), target);
  }
  
  // optional string SystemStartupOptions = 39;
  if (has_systemstartupoptions()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->systemstartupoptions().data(), this->systemstartupoptions().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        39, this->systemstartupoptions(), target);
  }
  
  // optional string SystemType = 40;
  if (has_systemtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->systemtype().data(), this->systemtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        40, this->systemtype(), target);
  }
  
  // optional string UserName = 41;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        41, this->username(), target);
  }
  
  // optional int32 AdminPasswordStatus = 42;
  if (has_adminpasswordstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(42, this->adminpasswordstatus(), target);
  }
  
  // optional int32 ChassisBootupState = 43;
  if (has_chassisbootupstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(43, this->chassisbootupstate(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ComputerSystemInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 DomainRole = 4;
    if (has_domainrole()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->domainrole());
    }
    
    // optional int32 FrontPanelResetStatus = 5;
    if (has_frontpanelresetstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frontpanelresetstatus());
    }
    
    // optional int32 KeyboardPasswordStatus = 6;
    if (has_keyboardpasswordstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->keyboardpasswordstatus());
    }
    
    // optional int32 PowerOnPasswordStatus = 7;
    if (has_poweronpasswordstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->poweronpasswordstatus());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 PowerState = 8;
    if (has_powerstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->powerstate());
    }
    
    // optional int32 PowerSupplyState = 9;
    if (has_powersupplystate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->powersupplystate());
    }
    
    // optional int32 ResetCapability = 10;
    if (has_resetcapability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resetcapability());
    }
    
    // optional int32 SystemStartupDelay = 11;
    if (has_systemstartupdelay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->systemstartupdelay());
    }
    
    // optional int32 ThermalState = 12;
    if (has_thermalstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->thermalstate());
    }
    
    // optional int32 WakeUpType = 13;
    if (has_wakeuptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wakeuptype());
    }
    
    // optional int32 CurrentTimeZone = 14;
    if (has_currenttimezone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currenttimezone());
    }
    
    // optional int32 ResetCount = 15;
    if (has_resetcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resetcount());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 ResetLimit = 16;
    if (has_resetlimit()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resetlimit());
    }
    
    // optional int32 NumberOfProcessors = 17;
    if (has_numberofprocessors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberofprocessors());
    }
    
    // optional uint64 TotalPhysicalMemory = 18;
    if (has_totalphysicalmemory()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->totalphysicalmemory());
    }
    
    // optional int64 PauseAfterReset = 19;
    if (has_pauseafterreset()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pauseafterreset());
    }
    
    // optional int32 AutomaticResetBootOption = 20;
    if (has_automaticresetbootoption()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->automaticresetbootoption());
    }
    
    // optional int32 AutomaticResetCapability = 21;
    if (has_automaticresetcapability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->automaticresetcapability());
    }
    
    // optional int32 BootROMSupported = 22;
    if (has_bootromsupported()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bootromsupported());
    }
    
    // optional int32 EnableDaylightSavingsTime = 23;
    if (has_enabledaylightsavingstime()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enabledaylightsavingstime());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional int32 InfraredSupported = 24;
    if (has_infraredsupported()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->infraredsupported());
    }
    
    // optional int32 NetworkServerModeEnabled = 25;
    if (has_networkservermodeenabled()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->networkservermodeenabled());
    }
    
    // optional int32 PartOfDomain = 26;
    if (has_partofdomain()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->partofdomain());
    }
    
    // optional int32 SystemStartupSetting = 27;
    if (has_systemstartupsetting()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->systemstartupsetting());
    }
    
    // optional string BootupState = 28;
    if (has_bootupstate()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bootupstate());
    }
    
    // optional string Description = 30;
    if (has_description()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string DNSHostName = 31;
    if (has_dnshostname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dnshostname());
    }
    
    // optional string Domain = 33;
    if (has_domain()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->domain());
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional string Manufacturer = 34;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Model = 35;
    if (has_model()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }
    
    // optional string PrimaryOwnerName = 36;
    if (has_primaryownername()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->primaryownername());
    }
    
    // optional string Roles = 37;
    if (has_roles()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->roles());
    }
    
    // optional string Status = 38;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string SystemStartupOptions = 39;
    if (has_systemstartupoptions()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->systemstartupoptions());
    }
    
    // optional string SystemType = 40;
    if (has_systemtype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->systemtype());
    }
    
    // optional string UserName = 41;
    if (has_username()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }
    
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional int32 AdminPasswordStatus = 42;
    if (has_adminpasswordstatus()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->adminpasswordstatus());
    }
    
    // optional int32 ChassisBootupState = 43;
    if (has_chassisbootupstate()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chassisbootupstate());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputerSystemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ComputerSystemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ComputerSystemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputerSystemInfo::MergeFrom(const ComputerSystemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_domainrole()) {
      set_domainrole(from.domainrole());
    }
    if (from.has_frontpanelresetstatus()) {
      set_frontpanelresetstatus(from.frontpanelresetstatus());
    }
    if (from.has_keyboardpasswordstatus()) {
      set_keyboardpasswordstatus(from.keyboardpasswordstatus());
    }
    if (from.has_poweronpasswordstatus()) {
      set_poweronpasswordstatus(from.poweronpasswordstatus());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_powerstate()) {
      set_powerstate(from.powerstate());
    }
    if (from.has_powersupplystate()) {
      set_powersupplystate(from.powersupplystate());
    }
    if (from.has_resetcapability()) {
      set_resetcapability(from.resetcapability());
    }
    if (from.has_systemstartupdelay()) {
      set_systemstartupdelay(from.systemstartupdelay());
    }
    if (from.has_thermalstate()) {
      set_thermalstate(from.thermalstate());
    }
    if (from.has_wakeuptype()) {
      set_wakeuptype(from.wakeuptype());
    }
    if (from.has_currenttimezone()) {
      set_currenttimezone(from.currenttimezone());
    }
    if (from.has_resetcount()) {
      set_resetcount(from.resetcount());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_resetlimit()) {
      set_resetlimit(from.resetlimit());
    }
    if (from.has_numberofprocessors()) {
      set_numberofprocessors(from.numberofprocessors());
    }
    if (from.has_totalphysicalmemory()) {
      set_totalphysicalmemory(from.totalphysicalmemory());
    }
    if (from.has_pauseafterreset()) {
      set_pauseafterreset(from.pauseafterreset());
    }
    if (from.has_automaticresetbootoption()) {
      set_automaticresetbootoption(from.automaticresetbootoption());
    }
    if (from.has_automaticresetcapability()) {
      set_automaticresetcapability(from.automaticresetcapability());
    }
    if (from.has_bootromsupported()) {
      set_bootromsupported(from.bootromsupported());
    }
    if (from.has_enabledaylightsavingstime()) {
      set_enabledaylightsavingstime(from.enabledaylightsavingstime());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_infraredsupported()) {
      set_infraredsupported(from.infraredsupported());
    }
    if (from.has_networkservermodeenabled()) {
      set_networkservermodeenabled(from.networkservermodeenabled());
    }
    if (from.has_partofdomain()) {
      set_partofdomain(from.partofdomain());
    }
    if (from.has_systemstartupsetting()) {
      set_systemstartupsetting(from.systemstartupsetting());
    }
    if (from.has_bootupstate()) {
      set_bootupstate(from.bootupstate());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_dnshostname()) {
      set_dnshostname(from.dnshostname());
    }
    if (from.has_domain()) {
      set_domain(from.domain());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_primaryownername()) {
      set_primaryownername(from.primaryownername());
    }
    if (from.has_roles()) {
      set_roles(from.roles());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_systemstartupoptions()) {
      set_systemstartupoptions(from.systemstartupoptions());
    }
    if (from.has_systemtype()) {
      set_systemtype(from.systemtype());
    }
    if (from.has_username()) {
      set_username(from.username());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_adminpasswordstatus()) {
      set_adminpasswordstatus(from.adminpasswordstatus());
    }
    if (from.has_chassisbootupstate()) {
      set_chassisbootupstate(from.chassisbootupstate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ComputerSystemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputerSystemInfo::CopyFrom(const ComputerSystemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputerSystemInfo::IsInitialized() const {
  
  return true;
}

void ComputerSystemInfo::Swap(ComputerSystemInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(domainrole_, other->domainrole_);
    std::swap(frontpanelresetstatus_, other->frontpanelresetstatus_);
    std::swap(keyboardpasswordstatus_, other->keyboardpasswordstatus_);
    std::swap(poweronpasswordstatus_, other->poweronpasswordstatus_);
    std::swap(powerstate_, other->powerstate_);
    std::swap(powersupplystate_, other->powersupplystate_);
    std::swap(resetcapability_, other->resetcapability_);
    std::swap(systemstartupdelay_, other->systemstartupdelay_);
    std::swap(thermalstate_, other->thermalstate_);
    std::swap(wakeuptype_, other->wakeuptype_);
    std::swap(currenttimezone_, other->currenttimezone_);
    std::swap(resetcount_, other->resetcount_);
    std::swap(resetlimit_, other->resetlimit_);
    std::swap(numberofprocessors_, other->numberofprocessors_);
    std::swap(totalphysicalmemory_, other->totalphysicalmemory_);
    std::swap(pauseafterreset_, other->pauseafterreset_);
    std::swap(automaticresetbootoption_, other->automaticresetbootoption_);
    std::swap(automaticresetcapability_, other->automaticresetcapability_);
    std::swap(bootromsupported_, other->bootromsupported_);
    std::swap(enabledaylightsavingstime_, other->enabledaylightsavingstime_);
    std::swap(infraredsupported_, other->infraredsupported_);
    std::swap(networkservermodeenabled_, other->networkservermodeenabled_);
    std::swap(partofdomain_, other->partofdomain_);
    std::swap(systemstartupsetting_, other->systemstartupsetting_);
    std::swap(bootupstate_, other->bootupstate_);
    std::swap(description_, other->description_);
    std::swap(dnshostname_, other->dnshostname_);
    std::swap(domain_, other->domain_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(model_, other->model_);
    std::swap(primaryownername_, other->primaryownername_);
    std::swap(roles_, other->roles_);
    std::swap(status_, other->status_);
    std::swap(systemstartupoptions_, other->systemstartupoptions_);
    std::swap(systemtype_, other->systemtype_);
    std::swap(username_, other->username_);
    std::swap(adminpasswordstatus_, other->adminpasswordstatus_);
    std::swap(chassisbootupstate_, other->chassisbootupstate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ComputerSystemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputerSystemInfo_descriptor_;
  metadata.reflection = ComputerSystemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ComputerSystemInfoList::kListFieldNumber;
const int ComputerSystemInfoList::kAlarmedFieldNumber;
const int ComputerSystemInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

ComputerSystemInfoList::ComputerSystemInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ComputerSystemInfoList::InitAsDefaultInstance() {
}

ComputerSystemInfoList::ComputerSystemInfoList(const ComputerSystemInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ComputerSystemInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputerSystemInfoList::~ComputerSystemInfoList() {
  SharedDtor();
}

void ComputerSystemInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void ComputerSystemInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputerSystemInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputerSystemInfoList_descriptor_;
}

const ComputerSystemInfoList& ComputerSystemInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ComputerSystemInfoList* ComputerSystemInfoList::default_instance_ = NULL;

ComputerSystemInfoList* ComputerSystemInfoList::New() const {
  return new ComputerSystemInfoList;
}

void ComputerSystemInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ComputerSystemInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.ComputerSystemInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ComputerSystemInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.ComputerSystemInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ComputerSystemInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.ComputerSystemInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ComputerSystemInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.ComputerSystemInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputerSystemInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ComputerSystemInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ComputerSystemInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputerSystemInfoList::MergeFrom(const ComputerSystemInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ComputerSystemInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputerSystemInfoList::CopyFrom(const ComputerSystemInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputerSystemInfoList::IsInitialized() const {
  
  return true;
}

void ComputerSystemInfoList::Swap(ComputerSystemInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ComputerSystemInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputerSystemInfoList_descriptor_;
  metadata.reflection = ComputerSystemInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ComputerSystemProductInfo::kPackageCodeFieldNumber;
const int ComputerSystemProductInfo::kChecktypeFieldNumber;
const int ComputerSystemProductInfo::kScanTimeFieldNumber;
const int ComputerSystemProductInfo::kAddtimeFieldNumber;
const int ComputerSystemProductInfo::kIdentifyingNumberFieldNumber;
const int ComputerSystemProductInfo::kNameFieldNumber;
const int ComputerSystemProductInfo::kVendorFieldNumber;
const int ComputerSystemProductInfo::kVersionFieldNumber;
const int ComputerSystemProductInfo::kDescriptionFieldNumber;
#endif  // !_MSC_VER

ComputerSystemProductInfo::ComputerSystemProductInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ComputerSystemProductInfo::InitAsDefaultInstance() {
}

ComputerSystemProductInfo::ComputerSystemProductInfo(const ComputerSystemProductInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ComputerSystemProductInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  identifyingnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputerSystemProductInfo::~ComputerSystemProductInfo() {
  SharedDtor();
}

void ComputerSystemProductInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (identifyingnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete identifyingnumber_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (this != default_instance_) {
  }
}

void ComputerSystemProductInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputerSystemProductInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputerSystemProductInfo_descriptor_;
}

const ComputerSystemProductInfo& ComputerSystemProductInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ComputerSystemProductInfo* ComputerSystemProductInfo::default_instance_ = NULL;

ComputerSystemProductInfo* ComputerSystemProductInfo::New() const {
  return new ComputerSystemProductInfo;
}

void ComputerSystemProductInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    if (has_identifyingnumber()) {
      if (identifyingnumber_ != &::google::protobuf::internal::kEmptyString) {
        identifyingnumber_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_vendor()) {
      if (vendor_ != &::google::protobuf::internal::kEmptyString) {
        vendor_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ComputerSystemProductInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_IdentifyingNumber;
        break;
      }
      
      // optional string IdentifyingNumber = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_IdentifyingNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_identifyingnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->identifyingnumber().data(), this->identifyingnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Name;
        break;
      }
      
      // optional string Name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_Vendor;
        break;
      }
      
      // optional string Vendor = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Vendor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->vendor().data(), this->vendor().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Version;
        break;
      }
      
      // optional string Version = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Description;
        break;
      }
      
      // optional string Description = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ComputerSystemProductInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional string IdentifyingNumber = 4;
  if (has_identifyingnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifyingnumber().data(), this->identifyingnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->identifyingnumber(), output);
  }
  
  // optional string Name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->name(), output);
  }
  
  // optional string Vendor = 6;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->vendor(), output);
  }
  
  // optional string Version = 7;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->version(), output);
  }
  
  // optional string Description = 8;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->description(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ComputerSystemProductInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional string IdentifyingNumber = 4;
  if (has_identifyingnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifyingnumber().data(), this->identifyingnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->identifyingnumber(), target);
  }
  
  // optional string Name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->name(), target);
  }
  
  // optional string Vendor = 6;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->vendor(), target);
  }
  
  // optional string Version = 7;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->version(), target);
  }
  
  // optional string Description = 8;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->description(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ComputerSystemProductInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional string IdentifyingNumber = 4;
    if (has_identifyingnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->identifyingnumber());
    }
    
    // optional string Name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string Vendor = 6;
    if (has_vendor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vendor());
    }
    
    // optional string Version = 7;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string Description = 8;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputerSystemProductInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ComputerSystemProductInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ComputerSystemProductInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputerSystemProductInfo::MergeFrom(const ComputerSystemProductInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_identifyingnumber()) {
      set_identifyingnumber(from.identifyingnumber());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_vendor()) {
      set_vendor(from.vendor());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ComputerSystemProductInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputerSystemProductInfo::CopyFrom(const ComputerSystemProductInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputerSystemProductInfo::IsInitialized() const {
  
  return true;
}

void ComputerSystemProductInfo::Swap(ComputerSystemProductInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(identifyingnumber_, other->identifyingnumber_);
    std::swap(name_, other->name_);
    std::swap(vendor_, other->vendor_);
    std::swap(version_, other->version_);
    std::swap(description_, other->description_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ComputerSystemProductInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputerSystemProductInfo_descriptor_;
  metadata.reflection = ComputerSystemProductInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ComputerSystemProductInfoList::kListFieldNumber;
const int ComputerSystemProductInfoList::kAlarmedFieldNumber;
const int ComputerSystemProductInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

ComputerSystemProductInfoList::ComputerSystemProductInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ComputerSystemProductInfoList::InitAsDefaultInstance() {
}

ComputerSystemProductInfoList::ComputerSystemProductInfoList(const ComputerSystemProductInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ComputerSystemProductInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputerSystemProductInfoList::~ComputerSystemProductInfoList() {
  SharedDtor();
}

void ComputerSystemProductInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void ComputerSystemProductInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputerSystemProductInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputerSystemProductInfoList_descriptor_;
}

const ComputerSystemProductInfoList& ComputerSystemProductInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ComputerSystemProductInfoList* ComputerSystemProductInfoList::default_instance_ = NULL;

ComputerSystemProductInfoList* ComputerSystemProductInfoList::New() const {
  return new ComputerSystemProductInfoList;
}

void ComputerSystemProductInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ComputerSystemProductInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.ComputerSystemProductInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ComputerSystemProductInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.ComputerSystemProductInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ComputerSystemProductInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.ComputerSystemProductInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ComputerSystemProductInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.ComputerSystemProductInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputerSystemProductInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ComputerSystemProductInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ComputerSystemProductInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputerSystemProductInfoList::MergeFrom(const ComputerSystemProductInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ComputerSystemProductInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputerSystemProductInfoList::CopyFrom(const ComputerSystemProductInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputerSystemProductInfoList::IsInitialized() const {
  
  return true;
}

void ComputerSystemProductInfoList::Swap(ComputerSystemProductInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ComputerSystemProductInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputerSystemProductInfoList_descriptor_;
  metadata.reflection = ComputerSystemProductInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DiskPartitionInfo::kPackageCodeFieldNumber;
const int DiskPartitionInfo::kChecktypeFieldNumber;
const int DiskPartitionInfo::kScanTimeFieldNumber;
const int DiskPartitionInfo::kAddtimeFieldNumber;
const int DiskPartitionInfo::kBlockSizeFieldNumber;
const int DiskPartitionInfo::kNumberOfBlocksFieldNumber;
const int DiskPartitionInfo::kSizeFieldNumber;
const int DiskPartitionInfo::kStartingOffsetFieldNumber;
const int DiskPartitionInfo::kDescriptionFieldNumber;
const int DiskPartitionInfo::kNameFieldNumber;
const int DiskPartitionInfo::kDiskIndexFieldNumber;
const int DiskPartitionInfo::kIndexFieldNumber;
const int DiskPartitionInfo::kBuyTimeFieldNumber;
const int DiskPartitionInfo::kBuyPriceFieldNumber;
const int DiskPartitionInfo::kDCheckTimeFieldNumber;
const int DiskPartitionInfo::kOtherInfoFieldNumber;
const int DiskPartitionInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

DiskPartitionInfo::DiskPartitionInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DiskPartitionInfo::InitAsDefaultInstance() {
}

DiskPartitionInfo::DiskPartitionInfo(const DiskPartitionInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DiskPartitionInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  blocksize_ = GOOGLE_ULONGLONG(0);
  numberofblocks_ = GOOGLE_ULONGLONG(0);
  size_ = GOOGLE_ULONGLONG(0);
  startingoffset_ = GOOGLE_ULONGLONG(0);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  diskindex_ = 0;
  index_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiskPartitionInfo::~DiskPartitionInfo() {
  SharedDtor();
}

void DiskPartitionInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void DiskPartitionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DiskPartitionInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiskPartitionInfo_descriptor_;
}

const DiskPartitionInfo& DiskPartitionInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DiskPartitionInfo* DiskPartitionInfo::default_instance_ = NULL;

DiskPartitionInfo* DiskPartitionInfo::New() const {
  return new DiskPartitionInfo;
}

void DiskPartitionInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    blocksize_ = GOOGLE_ULONGLONG(0);
    numberofblocks_ = GOOGLE_ULONGLONG(0);
    size_ = GOOGLE_ULONGLONG(0);
    startingoffset_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    diskindex_ = 0;
    index_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DiskPartitionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_BlockSize;
        break;
      }
      
      // optional uint64 BlockSize = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocksize_)));
          set_has_blocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_NumberOfBlocks;
        break;
      }
      
      // optional uint64 NumberOfBlocks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfBlocks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &numberofblocks_)));
          set_has_numberofblocks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Size;
        break;
      }
      
      // optional uint64 Size = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_StartingOffset;
        break;
      }
      
      // optional uint64 StartingOffset = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_StartingOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &startingoffset_)));
          set_has_startingoffset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_Description;
        break;
      }
      
      // optional string Description = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Name;
        break;
      }
      
      // optional string Name = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_DiskIndex;
        break;
      }
      
      // optional int32 DiskIndex = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DiskIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &diskindex_)));
          set_has_diskindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_Index;
        break;
      }
      
      // optional int32 Index = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(113)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(129)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DiskPartitionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional uint64 BlockSize = 4;
  if (has_blocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->blocksize(), output);
  }
  
  // optional uint64 NumberOfBlocks = 5;
  if (has_numberofblocks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->numberofblocks(), output);
  }
  
  // optional uint64 Size = 6;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->size(), output);
  }
  
  // optional uint64 StartingOffset = 7;
  if (has_startingoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->startingoffset(), output);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->description(), output);
  }
  
  // optional string Name = 11;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->name(), output);
  }
  
  // optional int32 DiskIndex = 12;
  if (has_diskindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->diskindex(), output);
  }
  
  // optional int32 Index = 13;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->index(), output);
  }
  
  // optional double BuyTime = 14;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->buytime(), output);
  }
  
  // optional string BuyPrice = 15;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 16;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 17;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->otherinfo(), output);
  }
  
  // optional string BuyName = 18;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DiskPartitionInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional uint64 BlockSize = 4;
  if (has_blocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->blocksize(), target);
  }
  
  // optional uint64 NumberOfBlocks = 5;
  if (has_numberofblocks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->numberofblocks(), target);
  }
  
  // optional uint64 Size = 6;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->size(), target);
  }
  
  // optional uint64 StartingOffset = 7;
  if (has_startingoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->startingoffset(), target);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->description(), target);
  }
  
  // optional string Name = 11;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->name(), target);
  }
  
  // optional int32 DiskIndex = 12;
  if (has_diskindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->diskindex(), target);
  }
  
  // optional int32 Index = 13;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->index(), target);
  }
  
  // optional double BuyTime = 14;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->buytime(), target);
  }
  
  // optional string BuyPrice = 15;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 16;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 17;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->otherinfo(), target);
  }
  
  // optional string BuyName = 18;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DiskPartitionInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional uint64 BlockSize = 4;
    if (has_blocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blocksize());
    }
    
    // optional uint64 NumberOfBlocks = 5;
    if (has_numberofblocks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->numberofblocks());
    }
    
    // optional uint64 Size = 6;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
    // optional uint64 StartingOffset = 7;
    if (has_startingoffset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->startingoffset());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string Description = 10;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Name = 11;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional int32 DiskIndex = 12;
    if (has_diskindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->diskindex());
    }
    
    // optional int32 Index = 13;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }
    
    // optional double BuyTime = 14;
    if (has_buytime()) {
      total_size += 1 + 8;
    }
    
    // optional string BuyPrice = 15;
    if (has_buyprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 16;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 17;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string BuyName = 18;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiskPartitionInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DiskPartitionInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DiskPartitionInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DiskPartitionInfo::MergeFrom(const DiskPartitionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_blocksize()) {
      set_blocksize(from.blocksize());
    }
    if (from.has_numberofblocks()) {
      set_numberofblocks(from.numberofblocks());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_startingoffset()) {
      set_startingoffset(from.startingoffset());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_diskindex()) {
      set_diskindex(from.diskindex());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DiskPartitionInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiskPartitionInfo::CopyFrom(const DiskPartitionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskPartitionInfo::IsInitialized() const {
  
  return true;
}

void DiskPartitionInfo::Swap(DiskPartitionInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(blocksize_, other->blocksize_);
    std::swap(numberofblocks_, other->numberofblocks_);
    std::swap(size_, other->size_);
    std::swap(startingoffset_, other->startingoffset_);
    std::swap(description_, other->description_);
    std::swap(name_, other->name_);
    std::swap(diskindex_, other->diskindex_);
    std::swap(index_, other->index_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DiskPartitionInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DiskPartitionInfo_descriptor_;
  metadata.reflection = DiskPartitionInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DiskPartitionInfoList::kListFieldNumber;
const int DiskPartitionInfoList::kAlarmedFieldNumber;
const int DiskPartitionInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

DiskPartitionInfoList::DiskPartitionInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DiskPartitionInfoList::InitAsDefaultInstance() {
}

DiskPartitionInfoList::DiskPartitionInfoList(const DiskPartitionInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DiskPartitionInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiskPartitionInfoList::~DiskPartitionInfoList() {
  SharedDtor();
}

void DiskPartitionInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void DiskPartitionInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DiskPartitionInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiskPartitionInfoList_descriptor_;
}

const DiskPartitionInfoList& DiskPartitionInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DiskPartitionInfoList* DiskPartitionInfoList::default_instance_ = NULL;

DiskPartitionInfoList* DiskPartitionInfoList::New() const {
  return new DiskPartitionInfoList;
}

void DiskPartitionInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DiskPartitionInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.DiskPartitionInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DiskPartitionInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.DiskPartitionInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DiskPartitionInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.DiskPartitionInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DiskPartitionInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.DiskPartitionInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiskPartitionInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DiskPartitionInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DiskPartitionInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DiskPartitionInfoList::MergeFrom(const DiskPartitionInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DiskPartitionInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiskPartitionInfoList::CopyFrom(const DiskPartitionInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskPartitionInfoList::IsInitialized() const {
  
  return true;
}

void DiskPartitionInfoList::Swap(DiskPartitionInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DiskPartitionInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DiskPartitionInfoList_descriptor_;
  metadata.reflection = DiskPartitionInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DisplayConfigurationInfo::kPackageCodeFieldNumber;
const int DisplayConfigurationInfo::kChecktypeFieldNumber;
const int DisplayConfigurationInfo::kScanTimeFieldNumber;
const int DisplayConfigurationInfo::kAddtimeFieldNumber;
const int DisplayConfigurationInfo::kDisplayFrequencyFieldNumber;
const int DisplayConfigurationInfo::kDitherTypeFieldNumber;
const int DisplayConfigurationInfo::kICMIntentFieldNumber;
const int DisplayConfigurationInfo::kICMMethodFieldNumber;
const int DisplayConfigurationInfo::kLogPixelsFieldNumber;
const int DisplayConfigurationInfo::kPelsHeightFieldNumber;
const int DisplayConfigurationInfo::kPelsWidthFieldNumber;
const int DisplayConfigurationInfo::kSpecificationVersionFieldNumber;
const int DisplayConfigurationInfo::kDescriptionFieldNumber;
const int DisplayConfigurationInfo::kDeviceNameFieldNumber;
const int DisplayConfigurationInfo::kDriverVersionFieldNumber;
const int DisplayConfigurationInfo::kBitsPerPerlFieldNumber;
const int DisplayConfigurationInfo::kDisplayFlagsFieldNumber;
const int DisplayConfigurationInfo::kBuyTimeFieldNumber;
const int DisplayConfigurationInfo::kBuyPriceFieldNumber;
const int DisplayConfigurationInfo::kDCheckTimeFieldNumber;
const int DisplayConfigurationInfo::kOtherInfoFieldNumber;
const int DisplayConfigurationInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

DisplayConfigurationInfo::DisplayConfigurationInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DisplayConfigurationInfo::InitAsDefaultInstance() {
}

DisplayConfigurationInfo::DisplayConfigurationInfo(const DisplayConfigurationInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DisplayConfigurationInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  displayfrequency_ = 0;
  dithertype_ = 0;
  icmintent_ = 0;
  icmmethod_ = 0;
  logpixels_ = 0;
  pelsheight_ = 0;
  pelswidth_ = 0;
  specificationversion_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  driverversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bitsperperl_ = 0;
  displayflags_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisplayConfigurationInfo::~DisplayConfigurationInfo() {
  SharedDtor();
}

void DisplayConfigurationInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    delete devicename_;
  }
  if (driverversion_ != &::google::protobuf::internal::kEmptyString) {
    delete driverversion_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void DisplayConfigurationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisplayConfigurationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisplayConfigurationInfo_descriptor_;
}

const DisplayConfigurationInfo& DisplayConfigurationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DisplayConfigurationInfo* DisplayConfigurationInfo::default_instance_ = NULL;

DisplayConfigurationInfo* DisplayConfigurationInfo::New() const {
  return new DisplayConfigurationInfo;
}

void DisplayConfigurationInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    displayfrequency_ = 0;
    dithertype_ = 0;
    icmintent_ = 0;
    icmmethod_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    logpixels_ = 0;
    pelsheight_ = 0;
    pelswidth_ = 0;
    specificationversion_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_devicename()) {
      if (devicename_ != &::google::protobuf::internal::kEmptyString) {
        devicename_->clear();
      }
    }
    if (has_driverversion()) {
      if (driverversion_ != &::google::protobuf::internal::kEmptyString) {
        driverversion_->clear();
      }
    }
    bitsperperl_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    displayflags_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DisplayConfigurationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_DisplayFrequency;
        break;
      }
      
      // optional int32 DisplayFrequency = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DisplayFrequency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &displayfrequency_)));
          set_has_displayfrequency();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_DitherType;
        break;
      }
      
      // optional int32 DitherType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DitherType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dithertype_)));
          set_has_dithertype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ICMIntent;
        break;
      }
      
      // optional int32 ICMIntent = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ICMIntent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icmintent_)));
          set_has_icmintent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_ICMMethod;
        break;
      }
      
      // optional int32 ICMMethod = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ICMMethod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icmmethod_)));
          set_has_icmmethod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_LogPixels;
        break;
      }
      
      // optional int32 LogPixels = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_LogPixels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &logpixels_)));
          set_has_logpixels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_PelsHeight;
        break;
      }
      
      // optional int32 PelsHeight = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PelsHeight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pelsheight_)));
          set_has_pelsheight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_PelsWidth;
        break;
      }
      
      // optional int32 PelsWidth = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PelsWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pelswidth_)));
          set_has_pelswidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_SpecificationVersion;
        break;
      }
      
      // optional int32 SpecificationVersion = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SpecificationVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &specificationversion_)));
          set_has_specificationversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_Description;
        break;
      }
      
      // optional string Description = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_DeviceName;
        break;
      }
      
      // optional string DeviceName = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DeviceName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_devicename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->devicename().data(), this->devicename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_DriverVersion;
        break;
      }
      
      // optional string DriverVersion = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DriverVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driverversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->driverversion().data(), this->driverversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_BitsPerPerl;
        break;
      }
      
      // optional int32 BitsPerPerl = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BitsPerPerl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bitsperperl_)));
          set_has_bitsperperl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_DisplayFlags;
        break;
      }
      
      // optional int32 DisplayFlags = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DisplayFlags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &displayflags_)));
          set_has_displayflags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(145)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(161)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DisplayConfigurationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 DisplayFrequency = 4;
  if (has_displayfrequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->displayfrequency(), output);
  }
  
  // optional int32 DitherType = 5;
  if (has_dithertype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->dithertype(), output);
  }
  
  // optional int32 ICMIntent = 6;
  if (has_icmintent()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->icmintent(), output);
  }
  
  // optional int32 ICMMethod = 7;
  if (has_icmmethod()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->icmmethod(), output);
  }
  
  // optional int32 LogPixels = 8;
  if (has_logpixels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->logpixels(), output);
  }
  
  // optional int32 PelsHeight = 9;
  if (has_pelsheight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->pelsheight(), output);
  }
  
  // optional int32 PelsWidth = 10;
  if (has_pelswidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->pelswidth(), output);
  }
  
  // optional int32 SpecificationVersion = 11;
  if (has_specificationversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->specificationversion(), output);
  }
  
  // optional string Description = 13;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->description(), output);
  }
  
  // optional string DeviceName = 14;
  if (has_devicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicename().data(), this->devicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->devicename(), output);
  }
  
  // optional string DriverVersion = 15;
  if (has_driverversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->driverversion().data(), this->driverversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->driverversion(), output);
  }
  
  // optional int32 BitsPerPerl = 16;
  if (has_bitsperperl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->bitsperperl(), output);
  }
  
  // optional int32 DisplayFlags = 17;
  if (has_displayflags()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->displayflags(), output);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->buytime(), output);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->otherinfo(), output);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DisplayConfigurationInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 DisplayFrequency = 4;
  if (has_displayfrequency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->displayfrequency(), target);
  }
  
  // optional int32 DitherType = 5;
  if (has_dithertype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->dithertype(), target);
  }
  
  // optional int32 ICMIntent = 6;
  if (has_icmintent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->icmintent(), target);
  }
  
  // optional int32 ICMMethod = 7;
  if (has_icmmethod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->icmmethod(), target);
  }
  
  // optional int32 LogPixels = 8;
  if (has_logpixels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->logpixels(), target);
  }
  
  // optional int32 PelsHeight = 9;
  if (has_pelsheight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->pelsheight(), target);
  }
  
  // optional int32 PelsWidth = 10;
  if (has_pelswidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->pelswidth(), target);
  }
  
  // optional int32 SpecificationVersion = 11;
  if (has_specificationversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->specificationversion(), target);
  }
  
  // optional string Description = 13;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->description(), target);
  }
  
  // optional string DeviceName = 14;
  if (has_devicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicename().data(), this->devicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->devicename(), target);
  }
  
  // optional string DriverVersion = 15;
  if (has_driverversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->driverversion().data(), this->driverversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->driverversion(), target);
  }
  
  // optional int32 BitsPerPerl = 16;
  if (has_bitsperperl()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->bitsperperl(), target);
  }
  
  // optional int32 DisplayFlags = 17;
  if (has_displayflags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->displayflags(), target);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->buytime(), target);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->otherinfo(), target);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DisplayConfigurationInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 DisplayFrequency = 4;
    if (has_displayfrequency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->displayfrequency());
    }
    
    // optional int32 DitherType = 5;
    if (has_dithertype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dithertype());
    }
    
    // optional int32 ICMIntent = 6;
    if (has_icmintent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icmintent());
    }
    
    // optional int32 ICMMethod = 7;
    if (has_icmmethod()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icmmethod());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 LogPixels = 8;
    if (has_logpixels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->logpixels());
    }
    
    // optional int32 PelsHeight = 9;
    if (has_pelsheight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pelsheight());
    }
    
    // optional int32 PelsWidth = 10;
    if (has_pelswidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pelswidth());
    }
    
    // optional int32 SpecificationVersion = 11;
    if (has_specificationversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->specificationversion());
    }
    
    // optional string Description = 13;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string DeviceName = 14;
    if (has_devicename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->devicename());
    }
    
    // optional string DriverVersion = 15;
    if (has_driverversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driverversion());
    }
    
    // optional int32 BitsPerPerl = 16;
    if (has_bitsperperl()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bitsperperl());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 DisplayFlags = 17;
    if (has_displayflags()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->displayflags());
    }
    
    // optional double BuyTime = 18;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 19;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 20;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 21;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 22;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisplayConfigurationInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DisplayConfigurationInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DisplayConfigurationInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DisplayConfigurationInfo::MergeFrom(const DisplayConfigurationInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_displayfrequency()) {
      set_displayfrequency(from.displayfrequency());
    }
    if (from.has_dithertype()) {
      set_dithertype(from.dithertype());
    }
    if (from.has_icmintent()) {
      set_icmintent(from.icmintent());
    }
    if (from.has_icmmethod()) {
      set_icmmethod(from.icmmethod());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_logpixels()) {
      set_logpixels(from.logpixels());
    }
    if (from.has_pelsheight()) {
      set_pelsheight(from.pelsheight());
    }
    if (from.has_pelswidth()) {
      set_pelswidth(from.pelswidth());
    }
    if (from.has_specificationversion()) {
      set_specificationversion(from.specificationversion());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_devicename()) {
      set_devicename(from.devicename());
    }
    if (from.has_driverversion()) {
      set_driverversion(from.driverversion());
    }
    if (from.has_bitsperperl()) {
      set_bitsperperl(from.bitsperperl());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_displayflags()) {
      set_displayflags(from.displayflags());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DisplayConfigurationInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisplayConfigurationInfo::CopyFrom(const DisplayConfigurationInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisplayConfigurationInfo::IsInitialized() const {
  
  return true;
}

void DisplayConfigurationInfo::Swap(DisplayConfigurationInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(displayfrequency_, other->displayfrequency_);
    std::swap(dithertype_, other->dithertype_);
    std::swap(icmintent_, other->icmintent_);
    std::swap(icmmethod_, other->icmmethod_);
    std::swap(logpixels_, other->logpixels_);
    std::swap(pelsheight_, other->pelsheight_);
    std::swap(pelswidth_, other->pelswidth_);
    std::swap(specificationversion_, other->specificationversion_);
    std::swap(description_, other->description_);
    std::swap(devicename_, other->devicename_);
    std::swap(driverversion_, other->driverversion_);
    std::swap(bitsperperl_, other->bitsperperl_);
    std::swap(displayflags_, other->displayflags_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DisplayConfigurationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisplayConfigurationInfo_descriptor_;
  metadata.reflection = DisplayConfigurationInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DisplayConfigurationInfoList::kListFieldNumber;
const int DisplayConfigurationInfoList::kAlarmedFieldNumber;
const int DisplayConfigurationInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

DisplayConfigurationInfoList::DisplayConfigurationInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DisplayConfigurationInfoList::InitAsDefaultInstance() {
}

DisplayConfigurationInfoList::DisplayConfigurationInfoList(const DisplayConfigurationInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DisplayConfigurationInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisplayConfigurationInfoList::~DisplayConfigurationInfoList() {
  SharedDtor();
}

void DisplayConfigurationInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void DisplayConfigurationInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisplayConfigurationInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisplayConfigurationInfoList_descriptor_;
}

const DisplayConfigurationInfoList& DisplayConfigurationInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DisplayConfigurationInfoList* DisplayConfigurationInfoList::default_instance_ = NULL;

DisplayConfigurationInfoList* DisplayConfigurationInfoList::New() const {
  return new DisplayConfigurationInfoList;
}

void DisplayConfigurationInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DisplayConfigurationInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.DisplayConfigurationInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DisplayConfigurationInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.DisplayConfigurationInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DisplayConfigurationInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.DisplayConfigurationInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DisplayConfigurationInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.DisplayConfigurationInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisplayConfigurationInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DisplayConfigurationInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DisplayConfigurationInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DisplayConfigurationInfoList::MergeFrom(const DisplayConfigurationInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DisplayConfigurationInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisplayConfigurationInfoList::CopyFrom(const DisplayConfigurationInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisplayConfigurationInfoList::IsInitialized() const {
  
  return true;
}

void DisplayConfigurationInfoList::Swap(DisplayConfigurationInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DisplayConfigurationInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisplayConfigurationInfoList_descriptor_;
  metadata.reflection = DisplayConfigurationInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IDEControllerInfo::kPackageCodeFieldNumber;
const int IDEControllerInfo::kChecktypeFieldNumber;
const int IDEControllerInfo::kScanTimeFieldNumber;
const int IDEControllerInfo::kAddtimeFieldNumber;
const int IDEControllerInfo::kMaxNumberControlledFieldNumber;
const int IDEControllerInfo::kDescriptionFieldNumber;
const int IDEControllerInfo::kManufacturerFieldNumber;
const int IDEControllerInfo::kNameFieldNumber;
const int IDEControllerInfo::kPNPDeviceIDFieldNumber;
const int IDEControllerInfo::kStatusFieldNumber;
const int IDEControllerInfo::kAvailabilityFieldNumber;
const int IDEControllerInfo::kProtocolSupportedFieldNumber;
const int IDEControllerInfo::kBuyTimeFieldNumber;
const int IDEControllerInfo::kBuyPriceFieldNumber;
const int IDEControllerInfo::kDCheckTimeFieldNumber;
const int IDEControllerInfo::kOtherInfoFieldNumber;
const int IDEControllerInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

IDEControllerInfo::IDEControllerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IDEControllerInfo::InitAsDefaultInstance() {
}

IDEControllerInfo::IDEControllerInfo(const IDEControllerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IDEControllerInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  maxnumbercontrolled_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  protocolsupported_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IDEControllerInfo::~IDEControllerInfo() {
  SharedDtor();
}

void IDEControllerInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void IDEControllerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IDEControllerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IDEControllerInfo_descriptor_;
}

const IDEControllerInfo& IDEControllerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

IDEControllerInfo* IDEControllerInfo::default_instance_ = NULL;

IDEControllerInfo* IDEControllerInfo::New() const {
  return new IDEControllerInfo;
}

void IDEControllerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    maxnumbercontrolled_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    availability_ = 0;
    protocolsupported_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IDEControllerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_MaxNumberControlled;
        break;
      }
      
      // optional int32 MaxNumberControlled = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxNumberControlled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxnumbercontrolled_)));
          set_has_maxnumbercontrolled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_Description;
        break;
      }
      
      // optional string Description = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_Name;
        break;
      }
      
      // optional string Name = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_Status;
        break;
      }
      
      // optional string Status = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_ProtocolSupported;
        break;
      }
      
      // optional int32 ProtocolSupported = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ProtocolSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocolsupported_)));
          set_has_protocolsupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(145)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(161)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IDEControllerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 MaxNumberControlled = 7;
  if (has_maxnumbercontrolled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->maxnumbercontrolled(), output);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->description(), output);
  }
  
  // optional string Manufacturer = 12;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->manufacturer(), output);
  }
  
  // optional string Name = 13;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->name(), output);
  }
  
  // optional string PNPDeviceID = 14;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->pnpdeviceid(), output);
  }
  
  // optional string Status = 15;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->status(), output);
  }
  
  // optional int32 Availability = 16;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->availability(), output);
  }
  
  // optional int32 ProtocolSupported = 17;
  if (has_protocolsupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->protocolsupported(), output);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->buytime(), output);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->otherinfo(), output);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IDEControllerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 MaxNumberControlled = 7;
  if (has_maxnumbercontrolled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->maxnumbercontrolled(), target);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->description(), target);
  }
  
  // optional string Manufacturer = 12;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->manufacturer(), target);
  }
  
  // optional string Name = 13;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->name(), target);
  }
  
  // optional string PNPDeviceID = 14;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->pnpdeviceid(), target);
  }
  
  // optional string Status = 15;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->status(), target);
  }
  
  // optional int32 Availability = 16;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->availability(), target);
  }
  
  // optional int32 ProtocolSupported = 17;
  if (has_protocolsupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->protocolsupported(), target);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->buytime(), target);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->otherinfo(), target);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IDEControllerInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 MaxNumberControlled = 7;
    if (has_maxnumbercontrolled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxnumbercontrolled());
    }
    
    // optional string Description = 10;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Manufacturer = 12;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Name = 13;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string PNPDeviceID = 14;
    if (has_pnpdeviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string Status = 15;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional int32 Availability = 16;
    if (has_availability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 ProtocolSupported = 17;
    if (has_protocolsupported()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->protocolsupported());
    }
    
    // optional double BuyTime = 18;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 19;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 20;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 21;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string BuyName = 22;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IDEControllerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IDEControllerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IDEControllerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IDEControllerInfo::MergeFrom(const IDEControllerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_maxnumbercontrolled()) {
      set_maxnumbercontrolled(from.maxnumbercontrolled());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_protocolsupported()) {
      set_protocolsupported(from.protocolsupported());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IDEControllerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IDEControllerInfo::CopyFrom(const IDEControllerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IDEControllerInfo::IsInitialized() const {
  
  return true;
}

void IDEControllerInfo::Swap(IDEControllerInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(maxnumbercontrolled_, other->maxnumbercontrolled_);
    std::swap(description_, other->description_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(status_, other->status_);
    std::swap(availability_, other->availability_);
    std::swap(protocolsupported_, other->protocolsupported_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IDEControllerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IDEControllerInfo_descriptor_;
  metadata.reflection = IDEControllerInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IDEControllerInfoList::kListFieldNumber;
const int IDEControllerInfoList::kAlarmedFieldNumber;
const int IDEControllerInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

IDEControllerInfoList::IDEControllerInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IDEControllerInfoList::InitAsDefaultInstance() {
}

IDEControllerInfoList::IDEControllerInfoList(const IDEControllerInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IDEControllerInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IDEControllerInfoList::~IDEControllerInfoList() {
  SharedDtor();
}

void IDEControllerInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void IDEControllerInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IDEControllerInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IDEControllerInfoList_descriptor_;
}

const IDEControllerInfoList& IDEControllerInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

IDEControllerInfoList* IDEControllerInfoList::default_instance_ = NULL;

IDEControllerInfoList* IDEControllerInfoList::New() const {
  return new IDEControllerInfoList;
}

void IDEControllerInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IDEControllerInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.IDEControllerInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IDEControllerInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.IDEControllerInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IDEControllerInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.IDEControllerInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IDEControllerInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.IDEControllerInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IDEControllerInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IDEControllerInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IDEControllerInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IDEControllerInfoList::MergeFrom(const IDEControllerInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IDEControllerInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IDEControllerInfoList::CopyFrom(const IDEControllerInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IDEControllerInfoList::IsInitialized() const {
  
  return true;
}

void IDEControllerInfoList::Swap(IDEControllerInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IDEControllerInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IDEControllerInfoList_descriptor_;
  metadata.reflection = IDEControllerInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InstalledSofteware::kPackageCodeFieldNumber;
const int InstalledSofteware::kChecktypeFieldNumber;
const int InstalledSofteware::kScanTimeFieldNumber;
const int InstalledSofteware::kAddtimeFieldNumber;
const int InstalledSofteware::kManufacturerFieldNumber;
const int InstalledSofteware::kInstalledPathFieldNumber;
const int InstalledSofteware::kVersionFieldNumber;
const int InstalledSofteware::kInstalledTimeFieldNumber;
const int InstalledSofteware::kHelpLinkFieldNumber;
const int InstalledSofteware::kNameFieldNumber;
const int InstalledSofteware::kDescriptionFieldNumber;
#endif  // !_MSC_VER

InstalledSofteware::InstalledSofteware()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InstalledSofteware::InitAsDefaultInstance() {
}

InstalledSofteware::InstalledSofteware(const InstalledSofteware& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InstalledSofteware::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  installed_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  installed_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  help_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InstalledSofteware::~InstalledSofteware() {
  SharedDtor();
}

void InstalledSofteware::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (installed_path_ != &::google::protobuf::internal::kEmptyString) {
    delete installed_path_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (installed_time_ != &::google::protobuf::internal::kEmptyString) {
    delete installed_time_;
  }
  if (help_link_ != &::google::protobuf::internal::kEmptyString) {
    delete help_link_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (this != default_instance_) {
  }
}

void InstalledSofteware::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InstalledSofteware::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InstalledSofteware_descriptor_;
}

const InstalledSofteware& InstalledSofteware::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

InstalledSofteware* InstalledSofteware::default_instance_ = NULL;

InstalledSofteware* InstalledSofteware::New() const {
  return new InstalledSofteware;
}

void InstalledSofteware::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_installed_path()) {
      if (installed_path_ != &::google::protobuf::internal::kEmptyString) {
        installed_path_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_installed_time()) {
      if (installed_time_ != &::google::protobuf::internal::kEmptyString) {
        installed_time_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_help_link()) {
      if (help_link_ != &::google::protobuf::internal::kEmptyString) {
        help_link_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InstalledSofteware::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_manufacturer;
        break;
      }
      
      // optional string manufacturer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_installed_path;
        break;
      }
      
      // optional string installed_path = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_installed_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_installed_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->installed_path().data(), this->installed_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }
      
      // optional string version = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_installed_time;
        break;
      }
      
      // optional string installed_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_installed_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_installed_time()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->installed_time().data(), this->installed_time().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_help_link;
        break;
      }
      
      // optional string help_link = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_help_link:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_help_link()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->help_link().data(), this->help_link().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_name;
        break;
      }
      
      // optional string name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_description;
        break;
      }
      
      // optional string description = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InstalledSofteware::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional string manufacturer = 4;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->manufacturer(), output);
  }
  
  // optional string installed_path = 5;
  if (has_installed_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->installed_path().data(), this->installed_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->installed_path(), output);
  }
  
  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->version(), output);
  }
  
  // optional string installed_time = 7;
  if (has_installed_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->installed_time().data(), this->installed_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->installed_time(), output);
  }
  
  // optional string help_link = 8;
  if (has_help_link()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->help_link().data(), this->help_link().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->help_link(), output);
  }
  
  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->name(), output);
  }
  
  // optional string description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->description(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InstalledSofteware::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional string manufacturer = 4;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->manufacturer(), target);
  }
  
  // optional string installed_path = 5;
  if (has_installed_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->installed_path().data(), this->installed_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->installed_path(), target);
  }
  
  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }
  
  // optional string installed_time = 7;
  if (has_installed_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->installed_time().data(), this->installed_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->installed_time(), target);
  }
  
  // optional string help_link = 8;
  if (has_help_link()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->help_link().data(), this->help_link().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->help_link(), target);
  }
  
  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->name(), target);
  }
  
  // optional string description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->description(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InstalledSofteware::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional string manufacturer = 4;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string installed_path = 5;
    if (has_installed_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->installed_path());
    }
    
    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional string installed_time = 7;
    if (has_installed_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->installed_time());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string help_link = 8;
    if (has_help_link()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->help_link());
    }
    
    // optional string name = 9;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string description = 10;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InstalledSofteware::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InstalledSofteware* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InstalledSofteware*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InstalledSofteware::MergeFrom(const InstalledSofteware& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_installed_path()) {
      set_installed_path(from.installed_path());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_installed_time()) {
      set_installed_time(from.installed_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_help_link()) {
      set_help_link(from.help_link());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InstalledSofteware::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InstalledSofteware::CopyFrom(const InstalledSofteware& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstalledSofteware::IsInitialized() const {
  
  return true;
}

void InstalledSofteware::Swap(InstalledSofteware* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(installed_path_, other->installed_path_);
    std::swap(version_, other->version_);
    std::swap(installed_time_, other->installed_time_);
    std::swap(help_link_, other->help_link_);
    std::swap(name_, other->name_);
    std::swap(description_, other->description_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InstalledSofteware::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InstalledSofteware_descriptor_;
  metadata.reflection = InstalledSofteware_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InstalledSoftewareList::kListFieldNumber;
const int InstalledSoftewareList::kAlarmedFieldNumber;
const int InstalledSoftewareList::kWinuserFieldNumber;
#endif  // !_MSC_VER

InstalledSoftewareList::InstalledSoftewareList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InstalledSoftewareList::InitAsDefaultInstance() {
}

InstalledSoftewareList::InstalledSoftewareList(const InstalledSoftewareList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InstalledSoftewareList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InstalledSoftewareList::~InstalledSoftewareList() {
  SharedDtor();
}

void InstalledSoftewareList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void InstalledSoftewareList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InstalledSoftewareList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InstalledSoftewareList_descriptor_;
}

const InstalledSoftewareList& InstalledSoftewareList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

InstalledSoftewareList* InstalledSoftewareList::default_instance_ = NULL;

InstalledSoftewareList* InstalledSoftewareList::New() const {
  return new InstalledSoftewareList;
}

void InstalledSoftewareList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InstalledSoftewareList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.InstalledSofteware list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InstalledSoftewareList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.InstalledSofteware list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InstalledSoftewareList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.InstalledSofteware list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InstalledSoftewareList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.InstalledSofteware list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InstalledSoftewareList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InstalledSoftewareList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InstalledSoftewareList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InstalledSoftewareList::MergeFrom(const InstalledSoftewareList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InstalledSoftewareList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InstalledSoftewareList::CopyFrom(const InstalledSoftewareList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstalledSoftewareList::IsInitialized() const {
  
  return true;
}

void InstalledSoftewareList::Swap(InstalledSoftewareList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InstalledSoftewareList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InstalledSoftewareList_descriptor_;
  metadata.reflection = InstalledSoftewareList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyboardInfo::kPackageCodeFieldNumber;
const int KeyboardInfo::kChecktypeFieldNumber;
const int KeyboardInfo::kScanTimeFieldNumber;
const int KeyboardInfo::kAddtimeFieldNumber;
const int KeyboardInfo::kPasswordFieldNumber;
const int KeyboardInfo::kIsLockedFieldNumber;
const int KeyboardInfo::kDescriptionFieldNumber;
const int KeyboardInfo::kLayoutFieldNumber;
const int KeyboardInfo::kNameFieldNumber;
const int KeyboardInfo::kPNPDeviceIDFieldNumber;
const int KeyboardInfo::kStatusFieldNumber;
const int KeyboardInfo::kAvailabilityFieldNumber;
const int KeyboardInfo::kNumberOfFunctionKeysFieldNumber;
const int KeyboardInfo::kBuyTimeFieldNumber;
const int KeyboardInfo::kBuyPriceFieldNumber;
const int KeyboardInfo::kDCheckTimeFieldNumber;
const int KeyboardInfo::kOtherInfoFieldNumber;
const int KeyboardInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

KeyboardInfo::KeyboardInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyboardInfo::InitAsDefaultInstance() {
}

KeyboardInfo::KeyboardInfo(const KeyboardInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyboardInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  password_ = 0;
  islocked_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  numberoffunctionkeys_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyboardInfo::~KeyboardInfo() {
  SharedDtor();
}

void KeyboardInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    delete layout_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void KeyboardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyboardInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyboardInfo_descriptor_;
}

const KeyboardInfo& KeyboardInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

KeyboardInfo* KeyboardInfo::default_instance_ = NULL;

KeyboardInfo* KeyboardInfo::New() const {
  return new KeyboardInfo;
}

void KeyboardInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    password_ = 0;
    islocked_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_layout()) {
      if (layout_ != &::google::protobuf::internal::kEmptyString) {
        layout_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    availability_ = 0;
    numberoffunctionkeys_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyboardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Password;
        break;
      }
      
      // optional int32 Password = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Password:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &password_)));
          set_has_password();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_IsLocked;
        break;
      }
      
      // optional int32 IsLocked = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_IsLocked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &islocked_)));
          set_has_islocked();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Description;
        break;
      }
      
      // optional string Description = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Layout;
        break;
      }
      
      // optional string Layout = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Layout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_layout()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->layout().data(), this->layout().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_Name;
        break;
      }
      
      // optional string Name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Status;
        break;
      }
      
      // optional string Status = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_NumberOfFunctionKeys;
        break;
      }
      
      // optional int32 NumberOfFunctionKeys = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfFunctionKeys:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberoffunctionkeys_)));
          set_has_numberoffunctionkeys();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(113)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(129)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyboardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 Password = 4;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->password(), output);
  }
  
  // optional int32 IsLocked = 6;
  if (has_islocked()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->islocked(), output);
  }
  
  // optional string Description = 7;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->description(), output);
  }
  
  // optional string Layout = 8;
  if (has_layout()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->layout().data(), this->layout().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->layout(), output);
  }
  
  // optional string Name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->name(), output);
  }
  
  // optional string PNPDeviceID = 10;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->pnpdeviceid(), output);
  }
  
  // optional string Status = 11;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->status(), output);
  }
  
  // optional int32 Availability = 12;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->availability(), output);
  }
  
  // optional int32 NumberOfFunctionKeys = 13;
  if (has_numberoffunctionkeys()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->numberoffunctionkeys(), output);
  }
  
  // optional double BuyTime = 14;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->buytime(), output);
  }
  
  // optional string BuyPrice = 15;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 16;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 17;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->otherinfo(), output);
  }
  
  // optional string BuyName = 18;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyboardInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 Password = 4;
  if (has_password()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->password(), target);
  }
  
  // optional int32 IsLocked = 6;
  if (has_islocked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->islocked(), target);
  }
  
  // optional string Description = 7;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->description(), target);
  }
  
  // optional string Layout = 8;
  if (has_layout()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->layout().data(), this->layout().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->layout(), target);
  }
  
  // optional string Name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->name(), target);
  }
  
  // optional string PNPDeviceID = 10;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->pnpdeviceid(), target);
  }
  
  // optional string Status = 11;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->status(), target);
  }
  
  // optional int32 Availability = 12;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->availability(), target);
  }
  
  // optional int32 NumberOfFunctionKeys = 13;
  if (has_numberoffunctionkeys()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->numberoffunctionkeys(), target);
  }
  
  // optional double BuyTime = 14;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->buytime(), target);
  }
  
  // optional string BuyPrice = 15;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 16;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 17;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->otherinfo(), target);
  }
  
  // optional string BuyName = 18;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyboardInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 Password = 4;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->password());
    }
    
    // optional int32 IsLocked = 6;
    if (has_islocked()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->islocked());
    }
    
    // optional string Description = 7;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Layout = 8;
    if (has_layout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->layout());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string Name = 9;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string PNPDeviceID = 10;
    if (has_pnpdeviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string Status = 11;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional int32 Availability = 12;
    if (has_availability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 NumberOfFunctionKeys = 13;
    if (has_numberoffunctionkeys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberoffunctionkeys());
    }
    
    // optional double BuyTime = 14;
    if (has_buytime()) {
      total_size += 1 + 8;
    }
    
    // optional string BuyPrice = 15;
    if (has_buyprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 16;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string OtherInfo = 17;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 18;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyboardInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyboardInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyboardInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyboardInfo::MergeFrom(const KeyboardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_islocked()) {
      set_islocked(from.islocked());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_layout()) {
      set_layout(from.layout());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_numberoffunctionkeys()) {
      set_numberoffunctionkeys(from.numberoffunctionkeys());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyboardInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyboardInfo::CopyFrom(const KeyboardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyboardInfo::IsInitialized() const {
  
  return true;
}

void KeyboardInfo::Swap(KeyboardInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(password_, other->password_);
    std::swap(islocked_, other->islocked_);
    std::swap(description_, other->description_);
    std::swap(layout_, other->layout_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(status_, other->status_);
    std::swap(availability_, other->availability_);
    std::swap(numberoffunctionkeys_, other->numberoffunctionkeys_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyboardInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyboardInfo_descriptor_;
  metadata.reflection = KeyboardInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyboardInfoList::kListFieldNumber;
const int KeyboardInfoList::kAlarmedFieldNumber;
const int KeyboardInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

KeyboardInfoList::KeyboardInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyboardInfoList::InitAsDefaultInstance() {
}

KeyboardInfoList::KeyboardInfoList(const KeyboardInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyboardInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyboardInfoList::~KeyboardInfoList() {
  SharedDtor();
}

void KeyboardInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void KeyboardInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyboardInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyboardInfoList_descriptor_;
}

const KeyboardInfoList& KeyboardInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

KeyboardInfoList* KeyboardInfoList::default_instance_ = NULL;

KeyboardInfoList* KeyboardInfoList::New() const {
  return new KeyboardInfoList;
}

void KeyboardInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyboardInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.KeyboardInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyboardInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.KeyboardInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyboardInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.KeyboardInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyboardInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.KeyboardInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyboardInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyboardInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyboardInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyboardInfoList::MergeFrom(const KeyboardInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyboardInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyboardInfoList::CopyFrom(const KeyboardInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyboardInfoList::IsInitialized() const {
  
  return true;
}

void KeyboardInfoList::Swap(KeyboardInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyboardInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyboardInfoList_descriptor_;
  metadata.reflection = KeyboardInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalDiskInfo::kPackageCodeFieldNumber;
const int LogicalDiskInfo::kChecktypeFieldNumber;
const int LogicalDiskInfo::kScanTimeFieldNumber;
const int LogicalDiskInfo::kAddtimeFieldNumber;
const int LogicalDiskInfo::kMediaTypeFieldNumber;
const int LogicalDiskInfo::kFreeSpaceFieldNumber;
const int LogicalDiskInfo::kSizeFieldNumber;
const int LogicalDiskInfo::kQuotasDisabledFieldNumber;
const int LogicalDiskInfo::kQuotasIncompleteFieldNumber;
const int LogicalDiskInfo::kQuotasRebuildingFieldNumber;
const int LogicalDiskInfo::kSupportsDiskQuotasFieldNumber;
const int LogicalDiskInfo::kSupportsFileBasedCompressionFieldNumber;
const int LogicalDiskInfo::kDescriptionFieldNumber;
const int LogicalDiskInfo::kFileSystemFieldNumber;
const int LogicalDiskInfo::kNameFieldNumber;
const int LogicalDiskInfo::kVolumeNameFieldNumber;
const int LogicalDiskInfo::kVolumeSerialNumberFieldNumber;
const int LogicalDiskInfo::kDriveTypeFieldNumber;
const int LogicalDiskInfo::kMaximumComponentLengthFieldNumber;
const int LogicalDiskInfo::kBuyTimeFieldNumber;
const int LogicalDiskInfo::kBuyPriceFieldNumber;
const int LogicalDiskInfo::kDCheckTimeFieldNumber;
const int LogicalDiskInfo::kOtherInfoFieldNumber;
const int LogicalDiskInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

LogicalDiskInfo::LogicalDiskInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalDiskInfo::InitAsDefaultInstance() {
}

LogicalDiskInfo::LogicalDiskInfo(const LogicalDiskInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalDiskInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  mediatype_ = 0;
  freespace_ = GOOGLE_ULONGLONG(0);
  size_ = GOOGLE_ULONGLONG(0);
  quotasdisabled_ = 0;
  quotasincomplete_ = 0;
  quotasrebuilding_ = 0;
  supportsdiskquotas_ = 0;
  supportsfilebasedcompression_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  filesystem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  volumename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  volumeserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  drivetype_ = 0;
  maximumcomponentlength_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalDiskInfo::~LogicalDiskInfo() {
  SharedDtor();
}

void LogicalDiskInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (filesystem_ != &::google::protobuf::internal::kEmptyString) {
    delete filesystem_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (volumename_ != &::google::protobuf::internal::kEmptyString) {
    delete volumename_;
  }
  if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete volumeserialnumber_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void LogicalDiskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalDiskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalDiskInfo_descriptor_;
}

const LogicalDiskInfo& LogicalDiskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

LogicalDiskInfo* LogicalDiskInfo::default_instance_ = NULL;

LogicalDiskInfo* LogicalDiskInfo::New() const {
  return new LogicalDiskInfo;
}

void LogicalDiskInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    mediatype_ = 0;
    freespace_ = GOOGLE_ULONGLONG(0);
    size_ = GOOGLE_ULONGLONG(0);
    quotasdisabled_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    quotasincomplete_ = 0;
    quotasrebuilding_ = 0;
    supportsdiskquotas_ = 0;
    supportsfilebasedcompression_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_filesystem()) {
      if (filesystem_ != &::google::protobuf::internal::kEmptyString) {
        filesystem_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_volumename()) {
      if (volumename_ != &::google::protobuf::internal::kEmptyString) {
        volumename_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_volumeserialnumber()) {
      if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
        volumeserialnumber_->clear();
      }
    }
    drivetype_ = 0;
    maximumcomponentlength_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalDiskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_MediaType;
        break;
      }
      
      // optional int32 MediaType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MediaType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mediatype_)));
          set_has_mediatype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_FreeSpace;
        break;
      }
      
      // optional uint64 FreeSpace = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_FreeSpace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &freespace_)));
          set_has_freespace();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Size;
        break;
      }
      
      // optional uint64 Size = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_QuotasDisabled;
        break;
      }
      
      // optional int32 QuotasDisabled = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QuotasDisabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quotasdisabled_)));
          set_has_quotasdisabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_QuotasIncomplete;
        break;
      }
      
      // optional int32 QuotasIncomplete = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QuotasIncomplete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quotasincomplete_)));
          set_has_quotasincomplete();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_QuotasRebuilding;
        break;
      }
      
      // optional int32 QuotasRebuilding = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QuotasRebuilding:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quotasrebuilding_)));
          set_has_quotasrebuilding();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_SupportsDiskQuotas;
        break;
      }
      
      // optional int32 SupportsDiskQuotas = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SupportsDiskQuotas:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &supportsdiskquotas_)));
          set_has_supportsdiskquotas();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_SupportsFileBasedCompression;
        break;
      }
      
      // optional int32 SupportsFileBasedCompression = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SupportsFileBasedCompression:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &supportsfilebasedcompression_)));
          set_has_supportsfilebasedcompression();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Description;
        break;
      }
      
      // optional string Description = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_FileSystem;
        break;
      }
      
      // optional string FileSystem = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_FileSystem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filesystem()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filesystem().data(), this->filesystem().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_Name;
        break;
      }
      
      // optional string Name = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_VolumeName;
        break;
      }
      
      // optional string VolumeName = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_VolumeName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volumename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->volumename().data(), this->volumename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_VolumeSerialNumber;
        break;
      }
      
      // optional string VolumeSerialNumber = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_VolumeSerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volumeserialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->volumeserialnumber().data(), this->volumeserialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_DriveType;
        break;
      }
      
      // optional int32 DriveType = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DriveType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &drivetype_)));
          set_has_drivetype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_MaximumComponentLength;
        break;
      }
      
      // optional int32 MaximumComponentLength = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaximumComponentLength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maximumcomponentlength_)));
          set_has_maximumcomponentlength();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(185)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(201)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalDiskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 MediaType = 4;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->mediatype(), output);
  }
  
  // optional uint64 FreeSpace = 5;
  if (has_freespace()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->freespace(), output);
  }
  
  // optional uint64 Size = 6;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->size(), output);
  }
  
  // optional int32 QuotasDisabled = 7;
  if (has_quotasdisabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->quotasdisabled(), output);
  }
  
  // optional int32 QuotasIncomplete = 8;
  if (has_quotasincomplete()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->quotasincomplete(), output);
  }
  
  // optional int32 QuotasRebuilding = 9;
  if (has_quotasrebuilding()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->quotasrebuilding(), output);
  }
  
  // optional int32 SupportsDiskQuotas = 10;
  if (has_supportsdiskquotas()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->supportsdiskquotas(), output);
  }
  
  // optional int32 SupportsFileBasedCompression = 11;
  if (has_supportsfilebasedcompression()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->supportsfilebasedcompression(), output);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->description(), output);
  }
  
  // optional string FileSystem = 15;
  if (has_filesystem()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filesystem().data(), this->filesystem().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->filesystem(), output);
  }
  
  // optional string Name = 16;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->name(), output);
  }
  
  // optional string VolumeName = 19;
  if (has_volumename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumename().data(), this->volumename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->volumename(), output);
  }
  
  // optional string VolumeSerialNumber = 20;
  if (has_volumeserialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumeserialnumber().data(), this->volumeserialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->volumeserialnumber(), output);
  }
  
  // optional int32 DriveType = 21;
  if (has_drivetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(21, this->drivetype(), output);
  }
  
  // optional int32 MaximumComponentLength = 22;
  if (has_maximumcomponentlength()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->maximumcomponentlength(), output);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->buytime(), output);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->otherinfo(), output);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalDiskInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 MediaType = 4;
  if (has_mediatype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->mediatype(), target);
  }
  
  // optional uint64 FreeSpace = 5;
  if (has_freespace()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->freespace(), target);
  }
  
  // optional uint64 Size = 6;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->size(), target);
  }
  
  // optional int32 QuotasDisabled = 7;
  if (has_quotasdisabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->quotasdisabled(), target);
  }
  
  // optional int32 QuotasIncomplete = 8;
  if (has_quotasincomplete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->quotasincomplete(), target);
  }
  
  // optional int32 QuotasRebuilding = 9;
  if (has_quotasrebuilding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->quotasrebuilding(), target);
  }
  
  // optional int32 SupportsDiskQuotas = 10;
  if (has_supportsdiskquotas()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->supportsdiskquotas(), target);
  }
  
  // optional int32 SupportsFileBasedCompression = 11;
  if (has_supportsfilebasedcompression()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->supportsfilebasedcompression(), target);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->description(), target);
  }
  
  // optional string FileSystem = 15;
  if (has_filesystem()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filesystem().data(), this->filesystem().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->filesystem(), target);
  }
  
  // optional string Name = 16;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->name(), target);
  }
  
  // optional string VolumeName = 19;
  if (has_volumename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumename().data(), this->volumename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->volumename(), target);
  }
  
  // optional string VolumeSerialNumber = 20;
  if (has_volumeserialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->volumeserialnumber().data(), this->volumeserialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->volumeserialnumber(), target);
  }
  
  // optional int32 DriveType = 21;
  if (has_drivetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(21, this->drivetype(), target);
  }
  
  // optional int32 MaximumComponentLength = 22;
  if (has_maximumcomponentlength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->maximumcomponentlength(), target);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->buytime(), target);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->otherinfo(), target);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalDiskInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 MediaType = 4;
    if (has_mediatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mediatype());
    }
    
    // optional uint64 FreeSpace = 5;
    if (has_freespace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->freespace());
    }
    
    // optional uint64 Size = 6;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
    // optional int32 QuotasDisabled = 7;
    if (has_quotasdisabled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quotasdisabled());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 QuotasIncomplete = 8;
    if (has_quotasincomplete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quotasincomplete());
    }
    
    // optional int32 QuotasRebuilding = 9;
    if (has_quotasrebuilding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quotasrebuilding());
    }
    
    // optional int32 SupportsDiskQuotas = 10;
    if (has_supportsdiskquotas()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->supportsdiskquotas());
    }
    
    // optional int32 SupportsFileBasedCompression = 11;
    if (has_supportsfilebasedcompression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->supportsfilebasedcompression());
    }
    
    // optional string Description = 14;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string FileSystem = 15;
    if (has_filesystem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filesystem());
    }
    
    // optional string Name = 16;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string VolumeName = 19;
    if (has_volumename()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volumename());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string VolumeSerialNumber = 20;
    if (has_volumeserialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volumeserialnumber());
    }
    
    // optional int32 DriveType = 21;
    if (has_drivetype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->drivetype());
    }
    
    // optional int32 MaximumComponentLength = 22;
    if (has_maximumcomponentlength()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maximumcomponentlength());
    }
    
    // optional double BuyTime = 23;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 24;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 25;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 26;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 27;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalDiskInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalDiskInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalDiskInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalDiskInfo::MergeFrom(const LogicalDiskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_mediatype()) {
      set_mediatype(from.mediatype());
    }
    if (from.has_freespace()) {
      set_freespace(from.freespace());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_quotasdisabled()) {
      set_quotasdisabled(from.quotasdisabled());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_quotasincomplete()) {
      set_quotasincomplete(from.quotasincomplete());
    }
    if (from.has_quotasrebuilding()) {
      set_quotasrebuilding(from.quotasrebuilding());
    }
    if (from.has_supportsdiskquotas()) {
      set_supportsdiskquotas(from.supportsdiskquotas());
    }
    if (from.has_supportsfilebasedcompression()) {
      set_supportsfilebasedcompression(from.supportsfilebasedcompression());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_filesystem()) {
      set_filesystem(from.filesystem());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_volumename()) {
      set_volumename(from.volumename());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_volumeserialnumber()) {
      set_volumeserialnumber(from.volumeserialnumber());
    }
    if (from.has_drivetype()) {
      set_drivetype(from.drivetype());
    }
    if (from.has_maximumcomponentlength()) {
      set_maximumcomponentlength(from.maximumcomponentlength());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalDiskInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalDiskInfo::CopyFrom(const LogicalDiskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalDiskInfo::IsInitialized() const {
  
  return true;
}

void LogicalDiskInfo::Swap(LogicalDiskInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(mediatype_, other->mediatype_);
    std::swap(freespace_, other->freespace_);
    std::swap(size_, other->size_);
    std::swap(quotasdisabled_, other->quotasdisabled_);
    std::swap(quotasincomplete_, other->quotasincomplete_);
    std::swap(quotasrebuilding_, other->quotasrebuilding_);
    std::swap(supportsdiskquotas_, other->supportsdiskquotas_);
    std::swap(supportsfilebasedcompression_, other->supportsfilebasedcompression_);
    std::swap(description_, other->description_);
    std::swap(filesystem_, other->filesystem_);
    std::swap(name_, other->name_);
    std::swap(volumename_, other->volumename_);
    std::swap(volumeserialnumber_, other->volumeserialnumber_);
    std::swap(drivetype_, other->drivetype_);
    std::swap(maximumcomponentlength_, other->maximumcomponentlength_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalDiskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalDiskInfo_descriptor_;
  metadata.reflection = LogicalDiskInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogicalDiskInfoList::kListFieldNumber;
const int LogicalDiskInfoList::kAlarmedFieldNumber;
const int LogicalDiskInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

LogicalDiskInfoList::LogicalDiskInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogicalDiskInfoList::InitAsDefaultInstance() {
}

LogicalDiskInfoList::LogicalDiskInfoList(const LogicalDiskInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogicalDiskInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogicalDiskInfoList::~LogicalDiskInfoList() {
  SharedDtor();
}

void LogicalDiskInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void LogicalDiskInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogicalDiskInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogicalDiskInfoList_descriptor_;
}

const LogicalDiskInfoList& LogicalDiskInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

LogicalDiskInfoList* LogicalDiskInfoList::default_instance_ = NULL;

LogicalDiskInfoList* LogicalDiskInfoList::New() const {
  return new LogicalDiskInfoList;
}

void LogicalDiskInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogicalDiskInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.LogicalDiskInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogicalDiskInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.LogicalDiskInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogicalDiskInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.LogicalDiskInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogicalDiskInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.LogicalDiskInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogicalDiskInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogicalDiskInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogicalDiskInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogicalDiskInfoList::MergeFrom(const LogicalDiskInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogicalDiskInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogicalDiskInfoList::CopyFrom(const LogicalDiskInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogicalDiskInfoList::IsInitialized() const {
  
  return true;
}

void LogicalDiskInfoList::Swap(LogicalDiskInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogicalDiskInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogicalDiskInfoList_descriptor_;
  metadata.reflection = LogicalDiskInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MainBoardInfo::kPackageCodeFieldNumber;
const int MainBoardInfo::kChecktypeFieldNumber;
const int MainBoardInfo::kScanTimeFieldNumber;
const int MainBoardInfo::kAddtimeFieldNumber;
const int MainBoardInfo::kModelFieldNumber;
const int MainBoardInfo::kOtherIdentifyingInfoFieldNumber;
const int MainBoardInfo::kPartNumberFieldNumber;
const int MainBoardInfo::kProductFieldNumber;
const int MainBoardInfo::kRequirementsDescriptionFieldNumber;
const int MainBoardInfo::kSerialNumberFieldNumber;
const int MainBoardInfo::kSKUFieldNumber;
const int MainBoardInfo::kSlotLayoutFieldNumber;
const int MainBoardInfo::kStatusFieldNumber;
const int MainBoardInfo::kVersionFieldNumber;
const int MainBoardInfo::kNameFieldNumber;
const int MainBoardInfo::kDescriptionFieldNumber;
const int MainBoardInfo::kManufacturerFieldNumber;
const int MainBoardInfo::kBuyTimeFieldNumber;
const int MainBoardInfo::kBuyPriceFieldNumber;
const int MainBoardInfo::kDCheckTimeFieldNumber;
const int MainBoardInfo::kOtherInfoFieldNumber;
const int MainBoardInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

MainBoardInfo::MainBoardInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MainBoardInfo::InitAsDefaultInstance() {
}

MainBoardInfo::MainBoardInfo(const MainBoardInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MainBoardInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  requirementsdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  slotlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MainBoardInfo::~MainBoardInfo() {
  SharedDtor();
}

void MainBoardInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otheridentifyinginfo_;
  }
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete partnumber_;
  }
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    delete product_;
  }
  if (requirementsdescription_ != &::google::protobuf::internal::kEmptyString) {
    delete requirementsdescription_;
  }
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    delete sku_;
  }
  if (slotlayout_ != &::google::protobuf::internal::kEmptyString) {
    delete slotlayout_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void MainBoardInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MainBoardInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MainBoardInfo_descriptor_;
}

const MainBoardInfo& MainBoardInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MainBoardInfo* MainBoardInfo::default_instance_ = NULL;

MainBoardInfo* MainBoardInfo::New() const {
  return new MainBoardInfo;
}

void MainBoardInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::kEmptyString) {
        model_->clear();
      }
    }
    if (has_otheridentifyinginfo()) {
      if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
        otheridentifyinginfo_->clear();
      }
    }
    if (has_partnumber()) {
      if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
        partnumber_->clear();
      }
    }
    if (has_product()) {
      if (product_ != &::google::protobuf::internal::kEmptyString) {
        product_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_requirementsdescription()) {
      if (requirementsdescription_ != &::google::protobuf::internal::kEmptyString) {
        requirementsdescription_->clear();
      }
    }
    if (has_serialnumber()) {
      if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
        serialnumber_->clear();
      }
    }
    if (has_sku()) {
      if (sku_ != &::google::protobuf::internal::kEmptyString) {
        sku_->clear();
      }
    }
    if (has_slotlayout()) {
      if (slotlayout_ != &::google::protobuf::internal::kEmptyString) {
        slotlayout_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MainBoardInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_Model;
        break;
      }
      
      // optional string Model = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_OtherIdentifyingInfo;
        break;
      }
      
      // optional string OtherIdentifyingInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherIdentifyingInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otheridentifyinginfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_PartNumber;
        break;
      }
      
      // optional string PartNumber = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PartNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->partnumber().data(), this->partnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Product;
        break;
      }
      
      // optional string Product = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Product:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_product()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->product().data(), this->product().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_RequirementsDescription;
        break;
      }
      
      // optional string RequirementsDescription = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_RequirementsDescription:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_requirementsdescription()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->requirementsdescription().data(), this->requirementsdescription().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_SerialNumber;
        break;
      }
      
      // optional string SerialNumber = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serialnumber().data(), this->serialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_SKU;
        break;
      }
      
      // optional string SKU = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SKU:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sku()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->sku().data(), this->sku().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_SlotLayout;
        break;
      }
      
      // optional string SlotLayout = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SlotLayout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_slotlayout()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->slotlayout().data(), this->slotlayout().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_Status;
        break;
      }
      
      // optional string Status = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_Version;
        break;
      }
      
      // optional string Version = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Name;
        break;
      }
      
      // optional string Name = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_Description;
        break;
      }
      
      // optional string Description = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(137)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(153)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MainBoardInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional string Model = 4;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->model(), output);
  }
  
  // optional string OtherIdentifyingInfo = 5;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->otheridentifyinginfo(), output);
  }
  
  // optional string PartNumber = 6;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->partnumber(), output);
  }
  
  // optional string Product = 7;
  if (has_product()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->product().data(), this->product().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->product(), output);
  }
  
  // optional string RequirementsDescription = 8;
  if (has_requirementsdescription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->requirementsdescription().data(), this->requirementsdescription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->requirementsdescription(), output);
  }
  
  // optional string SerialNumber = 9;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->serialnumber(), output);
  }
  
  // optional string SKU = 10;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->sku(), output);
  }
  
  // optional string SlotLayout = 11;
  if (has_slotlayout()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slotlayout().data(), this->slotlayout().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->slotlayout(), output);
  }
  
  // optional string Status = 12;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->status(), output);
  }
  
  // optional string Version = 13;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->version(), output);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->name(), output);
  }
  
  // optional string Description = 15;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->description(), output);
  }
  
  // optional string Manufacturer = 16;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->manufacturer(), output);
  }
  
  // optional double BuyTime = 17;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->buytime(), output);
  }
  
  // optional string BuyPrice = 18;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 19;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 20;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->otherinfo(), output);
  }
  
  // optional string BuyName = 21;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MainBoardInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional string Model = 4;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->model(), target);
  }
  
  // optional string OtherIdentifyingInfo = 5;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->otheridentifyinginfo(), target);
  }
  
  // optional string PartNumber = 6;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->partnumber(), target);
  }
  
  // optional string Product = 7;
  if (has_product()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->product().data(), this->product().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->product(), target);
  }
  
  // optional string RequirementsDescription = 8;
  if (has_requirementsdescription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->requirementsdescription().data(), this->requirementsdescription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->requirementsdescription(), target);
  }
  
  // optional string SerialNumber = 9;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->serialnumber(), target);
  }
  
  // optional string SKU = 10;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->sku(), target);
  }
  
  // optional string SlotLayout = 11;
  if (has_slotlayout()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->slotlayout().data(), this->slotlayout().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->slotlayout(), target);
  }
  
  // optional string Status = 12;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->status(), target);
  }
  
  // optional string Version = 13;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->version(), target);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->name(), target);
  }
  
  // optional string Description = 15;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->description(), target);
  }
  
  // optional string Manufacturer = 16;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->manufacturer(), target);
  }
  
  // optional double BuyTime = 17;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->buytime(), target);
  }
  
  // optional string BuyPrice = 18;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 19;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 20;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->otherinfo(), target);
  }
  
  // optional string BuyName = 21;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MainBoardInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional string Model = 4;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }
    
    // optional string OtherIdentifyingInfo = 5;
    if (has_otheridentifyinginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otheridentifyinginfo());
    }
    
    // optional string PartNumber = 6;
    if (has_partnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->partnumber());
    }
    
    // optional string Product = 7;
    if (has_product()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->product());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string RequirementsDescription = 8;
    if (has_requirementsdescription()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->requirementsdescription());
    }
    
    // optional string SerialNumber = 9;
    if (has_serialnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serialnumber());
    }
    
    // optional string SKU = 10;
    if (has_sku()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sku());
    }
    
    // optional string SlotLayout = 11;
    if (has_slotlayout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->slotlayout());
    }
    
    // optional string Status = 12;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string Version = 13;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional string Name = 14;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string Description = 15;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string Manufacturer = 16;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional double BuyTime = 17;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 18;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 19;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 20;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 21;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MainBoardInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MainBoardInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MainBoardInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MainBoardInfo::MergeFrom(const MainBoardInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_otheridentifyinginfo()) {
      set_otheridentifyinginfo(from.otheridentifyinginfo());
    }
    if (from.has_partnumber()) {
      set_partnumber(from.partnumber());
    }
    if (from.has_product()) {
      set_product(from.product());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_requirementsdescription()) {
      set_requirementsdescription(from.requirementsdescription());
    }
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_sku()) {
      set_sku(from.sku());
    }
    if (from.has_slotlayout()) {
      set_slotlayout(from.slotlayout());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MainBoardInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MainBoardInfo::CopyFrom(const MainBoardInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MainBoardInfo::IsInitialized() const {
  
  return true;
}

void MainBoardInfo::Swap(MainBoardInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(model_, other->model_);
    std::swap(otheridentifyinginfo_, other->otheridentifyinginfo_);
    std::swap(partnumber_, other->partnumber_);
    std::swap(product_, other->product_);
    std::swap(requirementsdescription_, other->requirementsdescription_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(sku_, other->sku_);
    std::swap(slotlayout_, other->slotlayout_);
    std::swap(status_, other->status_);
    std::swap(version_, other->version_);
    std::swap(name_, other->name_);
    std::swap(description_, other->description_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MainBoardInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MainBoardInfo_descriptor_;
  metadata.reflection = MainBoardInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MainBoardInfoList::kListFieldNumber;
const int MainBoardInfoList::kAlarmedFieldNumber;
const int MainBoardInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

MainBoardInfoList::MainBoardInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MainBoardInfoList::InitAsDefaultInstance() {
}

MainBoardInfoList::MainBoardInfoList(const MainBoardInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MainBoardInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MainBoardInfoList::~MainBoardInfoList() {
  SharedDtor();
}

void MainBoardInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void MainBoardInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MainBoardInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MainBoardInfoList_descriptor_;
}

const MainBoardInfoList& MainBoardInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MainBoardInfoList* MainBoardInfoList::default_instance_ = NULL;

MainBoardInfoList* MainBoardInfoList::New() const {
  return new MainBoardInfoList;
}

void MainBoardInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MainBoardInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.MainBoardInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MainBoardInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.MainBoardInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MainBoardInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.MainBoardInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MainBoardInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.MainBoardInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MainBoardInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MainBoardInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MainBoardInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MainBoardInfoList::MergeFrom(const MainBoardInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MainBoardInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MainBoardInfoList::CopyFrom(const MainBoardInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MainBoardInfoList::IsInitialized() const {
  
  return true;
}

void MainBoardInfoList::Swap(MainBoardInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MainBoardInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MainBoardInfoList_descriptor_;
  metadata.reflection = MainBoardInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemoryDeviceInfo::kPackageCodeFieldNumber;
const int MemoryDeviceInfo::kChecktypeFieldNumber;
const int MemoryDeviceInfo::kScanTimeFieldNumber;
const int MemoryDeviceInfo::kAddtimeFieldNumber;
const int MemoryDeviceInfo::kEndingAddressFieldNumber;
const int MemoryDeviceInfo::kStartingAddressFieldNumber;
const int MemoryDeviceInfo::kDescriptionFieldNumber;
const int MemoryDeviceInfo::kNameFieldNumber;
const int MemoryDeviceInfo::kBuyTimeFieldNumber;
const int MemoryDeviceInfo::kBuyPriceFieldNumber;
const int MemoryDeviceInfo::kDCheckTimeFieldNumber;
const int MemoryDeviceInfo::kOtherInfoFieldNumber;
const int MemoryDeviceInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

MemoryDeviceInfo::MemoryDeviceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemoryDeviceInfo::InitAsDefaultInstance() {
}

MemoryDeviceInfo::MemoryDeviceInfo(const MemoryDeviceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemoryDeviceInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  endingaddress_ = GOOGLE_ULONGLONG(0);
  startingaddress_ = GOOGLE_ULONGLONG(0);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemoryDeviceInfo::~MemoryDeviceInfo() {
  SharedDtor();
}

void MemoryDeviceInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void MemoryDeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemoryDeviceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemoryDeviceInfo_descriptor_;
}

const MemoryDeviceInfo& MemoryDeviceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MemoryDeviceInfo* MemoryDeviceInfo::default_instance_ = NULL;

MemoryDeviceInfo* MemoryDeviceInfo::New() const {
  return new MemoryDeviceInfo;
}

void MemoryDeviceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    endingaddress_ = GOOGLE_ULONGLONG(0);
    startingaddress_ = GOOGLE_ULONGLONG(0);
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemoryDeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_EndingAddress;
        break;
      }
      
      // optional uint64 EndingAddress = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_EndingAddress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &endingaddress_)));
          set_has_endingaddress();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_StartingAddress;
        break;
      }
      
      // optional uint64 StartingAddress = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_StartingAddress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &startingaddress_)));
          set_has_startingaddress();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_Description;
        break;
      }
      
      // optional string Description = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Name;
        break;
      }
      
      // optional string Name = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(65)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemoryDeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional uint64 EndingAddress = 4;
  if (has_endingaddress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->endingaddress(), output);
  }
  
  // optional uint64 StartingAddress = 5;
  if (has_startingaddress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->startingaddress(), output);
  }
  
  // optional string Description = 6;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->description(), output);
  }
  
  // optional string Name = 7;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->name(), output);
  }
  
  // optional double BuyTime = 8;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->buytime(), output);
  }
  
  // optional string BuyPrice = 9;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 10;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 11;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->otherinfo(), output);
  }
  
  // optional string BuyName = 12;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemoryDeviceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional uint64 EndingAddress = 4;
  if (has_endingaddress()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->endingaddress(), target);
  }
  
  // optional uint64 StartingAddress = 5;
  if (has_startingaddress()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->startingaddress(), target);
  }
  
  // optional string Description = 6;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->description(), target);
  }
  
  // optional string Name = 7;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->name(), target);
  }
  
  // optional double BuyTime = 8;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->buytime(), target);
  }
  
  // optional string BuyPrice = 9;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 10;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 11;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->otherinfo(), target);
  }
  
  // optional string BuyName = 12;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemoryDeviceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional uint64 EndingAddress = 4;
    if (has_endingaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->endingaddress());
    }
    
    // optional uint64 StartingAddress = 5;
    if (has_startingaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->startingaddress());
    }
    
    // optional string Description = 6;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Name = 7;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double BuyTime = 8;
    if (has_buytime()) {
      total_size += 1 + 8;
    }
    
    // optional string BuyPrice = 9;
    if (has_buyprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 10;
    if (has_dchecktime()) {
      total_size += 1 + 8;
    }
    
    // optional string OtherInfo = 11;
    if (has_otherinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 12;
    if (has_buyname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryDeviceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemoryDeviceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemoryDeviceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemoryDeviceInfo::MergeFrom(const MemoryDeviceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_endingaddress()) {
      set_endingaddress(from.endingaddress());
    }
    if (from.has_startingaddress()) {
      set_startingaddress(from.startingaddress());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemoryDeviceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemoryDeviceInfo::CopyFrom(const MemoryDeviceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryDeviceInfo::IsInitialized() const {
  
  return true;
}

void MemoryDeviceInfo::Swap(MemoryDeviceInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(endingaddress_, other->endingaddress_);
    std::swap(startingaddress_, other->startingaddress_);
    std::swap(description_, other->description_);
    std::swap(name_, other->name_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemoryDeviceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemoryDeviceInfo_descriptor_;
  metadata.reflection = MemoryDeviceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemoryDeviceInfoList::kListFieldNumber;
const int MemoryDeviceInfoList::kAlarmedFieldNumber;
const int MemoryDeviceInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

MemoryDeviceInfoList::MemoryDeviceInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemoryDeviceInfoList::InitAsDefaultInstance() {
}

MemoryDeviceInfoList::MemoryDeviceInfoList(const MemoryDeviceInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemoryDeviceInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemoryDeviceInfoList::~MemoryDeviceInfoList() {
  SharedDtor();
}

void MemoryDeviceInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void MemoryDeviceInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemoryDeviceInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemoryDeviceInfoList_descriptor_;
}

const MemoryDeviceInfoList& MemoryDeviceInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MemoryDeviceInfoList* MemoryDeviceInfoList::default_instance_ = NULL;

MemoryDeviceInfoList* MemoryDeviceInfoList::New() const {
  return new MemoryDeviceInfoList;
}

void MemoryDeviceInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemoryDeviceInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.MemoryDeviceInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemoryDeviceInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.MemoryDeviceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemoryDeviceInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.MemoryDeviceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemoryDeviceInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.MemoryDeviceInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryDeviceInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemoryDeviceInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemoryDeviceInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemoryDeviceInfoList::MergeFrom(const MemoryDeviceInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemoryDeviceInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemoryDeviceInfoList::CopyFrom(const MemoryDeviceInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryDeviceInfoList::IsInitialized() const {
  
  return true;
}

void MemoryDeviceInfoList::Swap(MemoryDeviceInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemoryDeviceInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemoryDeviceInfoList_descriptor_;
  metadata.reflection = MemoryDeviceInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemoryInfo::kPackageCodeFieldNumber;
const int MemoryInfo::kChecktypeFieldNumber;
const int MemoryInfo::kScanTimeFieldNumber;
const int MemoryInfo::kAddtimeFieldNumber;
const int MemoryInfo::kFormFactorFieldNumber;
const int MemoryInfo::kInterleaveDataDepthFieldNumber;
const int MemoryInfo::kInterleavePositionFieldNumber;
const int MemoryInfo::kMemoryTypeFieldNumber;
const int MemoryInfo::kPositionInRowFieldNumber;
const int MemoryInfo::kSpeedFieldNumber;
const int MemoryInfo::kTotalWidthFieldNumber;
const int MemoryInfo::kTypeDetailFieldNumber;
const int MemoryInfo::kPoweredOnFieldNumber;
const int MemoryInfo::kBankLabelFieldNumber;
const int MemoryInfo::kDescriptionFieldNumber;
const int MemoryInfo::kDeviceLocatorFieldNumber;
const int MemoryInfo::kManufacturerFieldNumber;
const int MemoryInfo::kModelFieldNumber;
const int MemoryInfo::kNameFieldNumber;
const int MemoryInfo::kOtherIdentifyingInfoFieldNumber;
const int MemoryInfo::kPartNumberFieldNumber;
const int MemoryInfo::kSerialNumberFieldNumber;
const int MemoryInfo::kSKUFieldNumber;
const int MemoryInfo::kStatusFieldNumber;
const int MemoryInfo::kVersionFieldNumber;
const int MemoryInfo::kCapacityFieldNumber;
const int MemoryInfo::kDataWidthFieldNumber;
const int MemoryInfo::kBuyTimeFieldNumber;
const int MemoryInfo::kBuyPriceFieldNumber;
const int MemoryInfo::kDCheckTimeFieldNumber;
const int MemoryInfo::kOtherInfoFieldNumber;
const int MemoryInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

MemoryInfo::MemoryInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemoryInfo::InitAsDefaultInstance() {
}

MemoryInfo::MemoryInfo(const MemoryInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemoryInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  formfactor_ = 0;
  interleavedatadepth_ = 0;
  interleaveposition_ = 0;
  memorytype_ = 0;
  positioninrow_ = 0;
  speed_ = 0;
  totalwidth_ = 0;
  typedetail_ = 0;
  poweredon_ = 0;
  banklabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  devicelocator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  capacity_ = GOOGLE_ULONGLONG(0);
  datawidth_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemoryInfo::~MemoryInfo() {
  SharedDtor();
}

void MemoryInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (banklabel_ != &::google::protobuf::internal::kEmptyString) {
    delete banklabel_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (devicelocator_ != &::google::protobuf::internal::kEmptyString) {
    delete devicelocator_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otheridentifyinginfo_;
  }
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete partnumber_;
  }
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    delete sku_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void MemoryInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemoryInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemoryInfo_descriptor_;
}

const MemoryInfo& MemoryInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MemoryInfo* MemoryInfo::default_instance_ = NULL;

MemoryInfo* MemoryInfo::New() const {
  return new MemoryInfo;
}

void MemoryInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    formfactor_ = 0;
    interleavedatadepth_ = 0;
    interleaveposition_ = 0;
    memorytype_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    positioninrow_ = 0;
    speed_ = 0;
    totalwidth_ = 0;
    typedetail_ = 0;
    poweredon_ = 0;
    if (has_banklabel()) {
      if (banklabel_ != &::google::protobuf::internal::kEmptyString) {
        banklabel_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_devicelocator()) {
      if (devicelocator_ != &::google::protobuf::internal::kEmptyString) {
        devicelocator_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::kEmptyString) {
        model_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_otheridentifyinginfo()) {
      if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
        otheridentifyinginfo_->clear();
      }
    }
    if (has_partnumber()) {
      if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
        partnumber_->clear();
      }
    }
    if (has_serialnumber()) {
      if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
        serialnumber_->clear();
      }
    }
    if (has_sku()) {
      if (sku_ != &::google::protobuf::internal::kEmptyString) {
        sku_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    capacity_ = GOOGLE_ULONGLONG(0);
    datawidth_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemoryInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_FormFactor;
        break;
      }
      
      // optional int32 FormFactor = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_FormFactor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &formfactor_)));
          set_has_formfactor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_InterleaveDataDepth;
        break;
      }
      
      // optional int32 InterleaveDataDepth = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_InterleaveDataDepth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interleavedatadepth_)));
          set_has_interleavedatadepth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_InterleavePosition;
        break;
      }
      
      // optional int32 InterleavePosition = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_InterleavePosition:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interleaveposition_)));
          set_has_interleaveposition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_MemoryType;
        break;
      }
      
      // optional int32 MemoryType = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MemoryType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &memorytype_)));
          set_has_memorytype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_PositionInRow;
        break;
      }
      
      // optional int32 PositionInRow = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PositionInRow:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &positioninrow_)));
          set_has_positioninrow();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_Speed;
        break;
      }
      
      // optional int32 Speed = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_TotalWidth;
        break;
      }
      
      // optional int32 TotalWidth = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totalwidth_)));
          set_has_totalwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_TypeDetail;
        break;
      }
      
      // optional int32 TypeDetail = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TypeDetail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &typedetail_)));
          set_has_typedetail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_PoweredOn;
        break;
      }
      
      // optional int32 PoweredOn = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PoweredOn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &poweredon_)));
          set_has_poweredon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_BankLabel;
        break;
      }
      
      // optional string BankLabel = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BankLabel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_banklabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->banklabel().data(), this->banklabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Description;
        break;
      }
      
      // optional string Description = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_DeviceLocator;
        break;
      }
      
      // optional string DeviceLocator = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DeviceLocator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_devicelocator()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->devicelocator().data(), this->devicelocator().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_Model;
        break;
      }
      
      // optional string Model = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_Name;
        break;
      }
      
      // optional string Name = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_OtherIdentifyingInfo;
        break;
      }
      
      // optional string OtherIdentifyingInfo = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherIdentifyingInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otheridentifyinginfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_PartNumber;
        break;
      }
      
      // optional string PartNumber = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PartNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->partnumber().data(), this->partnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_SerialNumber;
        break;
      }
      
      // optional string SerialNumber = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serialnumber().data(), this->serialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_SKU;
        break;
      }
      
      // optional string SKU = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SKU:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sku()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->sku().data(), this->sku().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_Status;
        break;
      }
      
      // optional string Status = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_Version;
        break;
      }
      
      // optional string Version = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_Capacity;
        break;
      }
      
      // optional uint64 Capacity = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_DataWidth;
        break;
      }
      
      // optional int32 DataWidth = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DataWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datawidth_)));
          set_has_datawidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(217)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(233)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemoryInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 FormFactor = 4;
  if (has_formfactor()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->formfactor(), output);
  }
  
  // optional int32 InterleaveDataDepth = 5;
  if (has_interleavedatadepth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->interleavedatadepth(), output);
  }
  
  // optional int32 InterleavePosition = 6;
  if (has_interleaveposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->interleaveposition(), output);
  }
  
  // optional int32 MemoryType = 7;
  if (has_memorytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->memorytype(), output);
  }
  
  // optional int32 PositionInRow = 8;
  if (has_positioninrow()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->positioninrow(), output);
  }
  
  // optional int32 Speed = 9;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->speed(), output);
  }
  
  // optional int32 TotalWidth = 10;
  if (has_totalwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->totalwidth(), output);
  }
  
  // optional int32 TypeDetail = 11;
  if (has_typedetail()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->typedetail(), output);
  }
  
  // optional int32 PoweredOn = 12;
  if (has_poweredon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->poweredon(), output);
  }
  
  // optional string BankLabel = 13;
  if (has_banklabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->banklabel().data(), this->banklabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->banklabel(), output);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->description(), output);
  }
  
  // optional string DeviceLocator = 15;
  if (has_devicelocator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicelocator().data(), this->devicelocator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->devicelocator(), output);
  }
  
  // optional string Manufacturer = 16;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->manufacturer(), output);
  }
  
  // optional string Model = 17;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->model(), output);
  }
  
  // optional string Name = 18;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->name(), output);
  }
  
  // optional string OtherIdentifyingInfo = 19;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->otheridentifyinginfo(), output);
  }
  
  // optional string PartNumber = 20;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->partnumber(), output);
  }
  
  // optional string SerialNumber = 21;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->serialnumber(), output);
  }
  
  // optional string SKU = 22;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->sku(), output);
  }
  
  // optional string Status = 23;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      23, this->status(), output);
  }
  
  // optional string Version = 24;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->version(), output);
  }
  
  // optional uint64 Capacity = 25;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(25, this->capacity(), output);
  }
  
  // optional int32 DataWidth = 26;
  if (has_datawidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(26, this->datawidth(), output);
  }
  
  // optional double BuyTime = 27;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->buytime(), output);
  }
  
  // optional string BuyPrice = 28;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      28, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 29;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 30;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->otherinfo(), output);
  }
  
  // optional string BuyName = 31;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      31, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemoryInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 FormFactor = 4;
  if (has_formfactor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->formfactor(), target);
  }
  
  // optional int32 InterleaveDataDepth = 5;
  if (has_interleavedatadepth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->interleavedatadepth(), target);
  }
  
  // optional int32 InterleavePosition = 6;
  if (has_interleaveposition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->interleaveposition(), target);
  }
  
  // optional int32 MemoryType = 7;
  if (has_memorytype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->memorytype(), target);
  }
  
  // optional int32 PositionInRow = 8;
  if (has_positioninrow()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->positioninrow(), target);
  }
  
  // optional int32 Speed = 9;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->speed(), target);
  }
  
  // optional int32 TotalWidth = 10;
  if (has_totalwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->totalwidth(), target);
  }
  
  // optional int32 TypeDetail = 11;
  if (has_typedetail()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->typedetail(), target);
  }
  
  // optional int32 PoweredOn = 12;
  if (has_poweredon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->poweredon(), target);
  }
  
  // optional string BankLabel = 13;
  if (has_banklabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->banklabel().data(), this->banklabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->banklabel(), target);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->description(), target);
  }
  
  // optional string DeviceLocator = 15;
  if (has_devicelocator()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicelocator().data(), this->devicelocator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->devicelocator(), target);
  }
  
  // optional string Manufacturer = 16;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->manufacturer(), target);
  }
  
  // optional string Model = 17;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->model(), target);
  }
  
  // optional string Name = 18;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->name(), target);
  }
  
  // optional string OtherIdentifyingInfo = 19;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->otheridentifyinginfo(), target);
  }
  
  // optional string PartNumber = 20;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->partnumber(), target);
  }
  
  // optional string SerialNumber = 21;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->serialnumber(), target);
  }
  
  // optional string SKU = 22;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->sku(), target);
  }
  
  // optional string Status = 23;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        23, this->status(), target);
  }
  
  // optional string Version = 24;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->version(), target);
  }
  
  // optional uint64 Capacity = 25;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(25, this->capacity(), target);
  }
  
  // optional int32 DataWidth = 26;
  if (has_datawidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(26, this->datawidth(), target);
  }
  
  // optional double BuyTime = 27;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->buytime(), target);
  }
  
  // optional string BuyPrice = 28;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        28, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 29;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 30;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->otherinfo(), target);
  }
  
  // optional string BuyName = 31;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        31, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemoryInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 FormFactor = 4;
    if (has_formfactor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->formfactor());
    }
    
    // optional int32 InterleaveDataDepth = 5;
    if (has_interleavedatadepth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interleavedatadepth());
    }
    
    // optional int32 InterleavePosition = 6;
    if (has_interleaveposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interleaveposition());
    }
    
    // optional int32 MemoryType = 7;
    if (has_memorytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->memorytype());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 PositionInRow = 8;
    if (has_positioninrow()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->positioninrow());
    }
    
    // optional int32 Speed = 9;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed());
    }
    
    // optional int32 TotalWidth = 10;
    if (has_totalwidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->totalwidth());
    }
    
    // optional int32 TypeDetail = 11;
    if (has_typedetail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->typedetail());
    }
    
    // optional int32 PoweredOn = 12;
    if (has_poweredon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->poweredon());
    }
    
    // optional string BankLabel = 13;
    if (has_banklabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->banklabel());
    }
    
    // optional string Description = 14;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string DeviceLocator = 15;
    if (has_devicelocator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->devicelocator());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string Manufacturer = 16;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Model = 17;
    if (has_model()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }
    
    // optional string Name = 18;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string OtherIdentifyingInfo = 19;
    if (has_otheridentifyinginfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otheridentifyinginfo());
    }
    
    // optional string PartNumber = 20;
    if (has_partnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->partnumber());
    }
    
    // optional string SerialNumber = 21;
    if (has_serialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serialnumber());
    }
    
    // optional string SKU = 22;
    if (has_sku()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sku());
    }
    
    // optional string Status = 23;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string Version = 24;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional uint64 Capacity = 25;
    if (has_capacity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }
    
    // optional int32 DataWidth = 26;
    if (has_datawidth()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datawidth());
    }
    
    // optional double BuyTime = 27;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 28;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 29;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 30;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 31;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemoryInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemoryInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemoryInfo::MergeFrom(const MemoryInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_formfactor()) {
      set_formfactor(from.formfactor());
    }
    if (from.has_interleavedatadepth()) {
      set_interleavedatadepth(from.interleavedatadepth());
    }
    if (from.has_interleaveposition()) {
      set_interleaveposition(from.interleaveposition());
    }
    if (from.has_memorytype()) {
      set_memorytype(from.memorytype());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_positioninrow()) {
      set_positioninrow(from.positioninrow());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_totalwidth()) {
      set_totalwidth(from.totalwidth());
    }
    if (from.has_typedetail()) {
      set_typedetail(from.typedetail());
    }
    if (from.has_poweredon()) {
      set_poweredon(from.poweredon());
    }
    if (from.has_banklabel()) {
      set_banklabel(from.banklabel());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_devicelocator()) {
      set_devicelocator(from.devicelocator());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_otheridentifyinginfo()) {
      set_otheridentifyinginfo(from.otheridentifyinginfo());
    }
    if (from.has_partnumber()) {
      set_partnumber(from.partnumber());
    }
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_sku()) {
      set_sku(from.sku());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_datawidth()) {
      set_datawidth(from.datawidth());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemoryInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemoryInfo::CopyFrom(const MemoryInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryInfo::IsInitialized() const {
  
  return true;
}

void MemoryInfo::Swap(MemoryInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(formfactor_, other->formfactor_);
    std::swap(interleavedatadepth_, other->interleavedatadepth_);
    std::swap(interleaveposition_, other->interleaveposition_);
    std::swap(memorytype_, other->memorytype_);
    std::swap(positioninrow_, other->positioninrow_);
    std::swap(speed_, other->speed_);
    std::swap(totalwidth_, other->totalwidth_);
    std::swap(typedetail_, other->typedetail_);
    std::swap(poweredon_, other->poweredon_);
    std::swap(banklabel_, other->banklabel_);
    std::swap(description_, other->description_);
    std::swap(devicelocator_, other->devicelocator_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(model_, other->model_);
    std::swap(name_, other->name_);
    std::swap(otheridentifyinginfo_, other->otheridentifyinginfo_);
    std::swap(partnumber_, other->partnumber_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(sku_, other->sku_);
    std::swap(status_, other->status_);
    std::swap(version_, other->version_);
    std::swap(capacity_, other->capacity_);
    std::swap(datawidth_, other->datawidth_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemoryInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemoryInfo_descriptor_;
  metadata.reflection = MemoryInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemoryInfoList::kListFieldNumber;
const int MemoryInfoList::kAlarmedFieldNumber;
const int MemoryInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

MemoryInfoList::MemoryInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemoryInfoList::InitAsDefaultInstance() {
}

MemoryInfoList::MemoryInfoList(const MemoryInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemoryInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemoryInfoList::~MemoryInfoList() {
  SharedDtor();
}

void MemoryInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void MemoryInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemoryInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemoryInfoList_descriptor_;
}

const MemoryInfoList& MemoryInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MemoryInfoList* MemoryInfoList::default_instance_ = NULL;

MemoryInfoList* MemoryInfoList::New() const {
  return new MemoryInfoList;
}

void MemoryInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemoryInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.MemoryInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemoryInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.MemoryInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemoryInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.MemoryInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemoryInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.MemoryInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemoryInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemoryInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemoryInfoList::MergeFrom(const MemoryInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemoryInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemoryInfoList::CopyFrom(const MemoryInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryInfoList::IsInitialized() const {
  
  return true;
}

void MemoryInfoList::Swap(MemoryInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemoryInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemoryInfoList_descriptor_;
  metadata.reflection = MemoryInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MouseInfo::kPackageCodeFieldNumber;
const int MouseInfo::kChecktypeFieldNumber;
const int MouseInfo::kScanTimeFieldNumber;
const int MouseInfo::kAddtimeFieldNumber;
const int MouseInfo::kDoubleSpeedThresholdFieldNumber;
const int MouseInfo::kHandednessFieldNumber;
const int MouseInfo::kNumberOfButtonsFieldNumber;
const int MouseInfo::kPointingTypeFieldNumber;
const int MouseInfo::kQuadSpeedThresholdFieldNumber;
const int MouseInfo::kResolutionFieldNumber;
const int MouseInfo::kSampleRateFieldNumber;
const int MouseInfo::kSynchFieldNumber;
const int MouseInfo::kIsLockedFieldNumber;
const int MouseInfo::kDescriptionFieldNumber;
const int MouseInfo::kHardwareTypeFieldNumber;
const int MouseInfo::kInfFileNameFieldNumber;
const int MouseInfo::kInfSectionFieldNumber;
const int MouseInfo::kManufacturerFieldNumber;
const int MouseInfo::kNameFieldNumber;
const int MouseInfo::kPNPDeviceIDFieldNumber;
const int MouseInfo::kStatusFieldNumber;
const int MouseInfo::kAvailabilityFieldNumber;
const int MouseInfo::kDeviceInterfaceFieldNumber;
const int MouseInfo::kBuyTimeFieldNumber;
const int MouseInfo::kBuyPriceFieldNumber;
const int MouseInfo::kDCheckTimeFieldNumber;
const int MouseInfo::kOtherInfoFieldNumber;
const int MouseInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

MouseInfo::MouseInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MouseInfo::InitAsDefaultInstance() {
}

MouseInfo::MouseInfo(const MouseInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MouseInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  doublespeedthreshold_ = 0;
  handedness_ = 0;
  numberofbuttons_ = 0;
  pointingtype_ = 0;
  quadspeedthreshold_ = 0;
  resolution_ = 0;
  samplerate_ = 0;
  synch_ = 0;
  islocked_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hardwaretype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  inffilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  infsection_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  deviceinterface_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MouseInfo::~MouseInfo() {
  SharedDtor();
}

void MouseInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (hardwaretype_ != &::google::protobuf::internal::kEmptyString) {
    delete hardwaretype_;
  }
  if (inffilename_ != &::google::protobuf::internal::kEmptyString) {
    delete inffilename_;
  }
  if (infsection_ != &::google::protobuf::internal::kEmptyString) {
    delete infsection_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void MouseInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MouseInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MouseInfo_descriptor_;
}

const MouseInfo& MouseInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MouseInfo* MouseInfo::default_instance_ = NULL;

MouseInfo* MouseInfo::New() const {
  return new MouseInfo;
}

void MouseInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    doublespeedthreshold_ = 0;
    handedness_ = 0;
    numberofbuttons_ = 0;
    pointingtype_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    quadspeedthreshold_ = 0;
    resolution_ = 0;
    samplerate_ = 0;
    synch_ = 0;
    islocked_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_hardwaretype()) {
      if (hardwaretype_ != &::google::protobuf::internal::kEmptyString) {
        hardwaretype_->clear();
      }
    }
    if (has_inffilename()) {
      if (inffilename_ != &::google::protobuf::internal::kEmptyString) {
        inffilename_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_infsection()) {
      if (infsection_ != &::google::protobuf::internal::kEmptyString) {
        infsection_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    availability_ = 0;
    deviceinterface_ = 0;
    buytime_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MouseInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_DoubleSpeedThreshold;
        break;
      }
      
      // optional int32 DoubleSpeedThreshold = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DoubleSpeedThreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &doublespeedthreshold_)));
          set_has_doublespeedthreshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Handedness;
        break;
      }
      
      // optional int32 Handedness = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Handedness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &handedness_)));
          set_has_handedness();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_NumberOfButtons;
        break;
      }
      
      // optional int32 NumberOfButtons = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfButtons:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberofbuttons_)));
          set_has_numberofbuttons();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_PointingType;
        break;
      }
      
      // optional int32 PointingType = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PointingType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pointingtype_)));
          set_has_pointingtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_QuadSpeedThreshold;
        break;
      }
      
      // optional int32 QuadSpeedThreshold = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QuadSpeedThreshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quadspeedthreshold_)));
          set_has_quadspeedthreshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_Resolution;
        break;
      }
      
      // optional int32 Resolution = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Resolution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resolution_)));
          set_has_resolution();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_SampleRate;
        break;
      }
      
      // optional int32 SampleRate = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SampleRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &samplerate_)));
          set_has_samplerate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_Synch;
        break;
      }
      
      // optional int32 Synch = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Synch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &synch_)));
          set_has_synch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_IsLocked;
        break;
      }
      
      // optional int32 IsLocked = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_IsLocked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &islocked_)));
          set_has_islocked();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Description;
        break;
      }
      
      // optional string Description = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_HardwareType;
        break;
      }
      
      // optional string HardwareType = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_HardwareType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardwaretype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hardwaretype().data(), this->hardwaretype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_InfFileName;
        break;
      }
      
      // optional string InfFileName = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_InfFileName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_inffilename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->inffilename().data(), this->inffilename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_InfSection;
        break;
      }
      
      // optional string InfSection = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_InfSection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_infsection()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->infsection().data(), this->infsection().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_Name;
        break;
      }
      
      // optional string Name = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_Status;
        break;
      }
      
      // optional string Status = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_DeviceInterface;
        break;
      }
      
      // optional int32 DeviceInterface = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DeviceInterface:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deviceinterface_)));
          set_has_deviceinterface();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(201)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(217)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MouseInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 DoubleSpeedThreshold = 4;
  if (has_doublespeedthreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->doublespeedthreshold(), output);
  }
  
  // optional int32 Handedness = 5;
  if (has_handedness()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->handedness(), output);
  }
  
  // optional int32 NumberOfButtons = 6;
  if (has_numberofbuttons()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->numberofbuttons(), output);
  }
  
  // optional int32 PointingType = 7;
  if (has_pointingtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->pointingtype(), output);
  }
  
  // optional int32 QuadSpeedThreshold = 8;
  if (has_quadspeedthreshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->quadspeedthreshold(), output);
  }
  
  // optional int32 Resolution = 9;
  if (has_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->resolution(), output);
  }
  
  // optional int32 SampleRate = 10;
  if (has_samplerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->samplerate(), output);
  }
  
  // optional int32 Synch = 12;
  if (has_synch()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->synch(), output);
  }
  
  // optional int32 IsLocked = 13;
  if (has_islocked()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->islocked(), output);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->description(), output);
  }
  
  // optional string HardwareType = 16;
  if (has_hardwaretype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hardwaretype().data(), this->hardwaretype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->hardwaretype(), output);
  }
  
  // optional string InfFileName = 17;
  if (has_inffilename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->inffilename().data(), this->inffilename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->inffilename(), output);
  }
  
  // optional string InfSection = 18;
  if (has_infsection()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->infsection().data(), this->infsection().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->infsection(), output);
  }
  
  // optional string Manufacturer = 19;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->manufacturer(), output);
  }
  
  // optional string Name = 20;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->name(), output);
  }
  
  // optional string PNPDeviceID = 21;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->pnpdeviceid(), output);
  }
  
  // optional string Status = 22;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->status(), output);
  }
  
  // optional int32 Availability = 23;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(23, this->availability(), output);
  }
  
  // optional int32 DeviceInterface = 24;
  if (has_deviceinterface()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(24, this->deviceinterface(), output);
  }
  
  // optional double BuyTime = 25;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->buytime(), output);
  }
  
  // optional string BuyPrice = 26;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 27;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 28;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      28, this->otherinfo(), output);
  }
  
  // optional string BuyName = 29;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      29, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MouseInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 DoubleSpeedThreshold = 4;
  if (has_doublespeedthreshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->doublespeedthreshold(), target);
  }
  
  // optional int32 Handedness = 5;
  if (has_handedness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->handedness(), target);
  }
  
  // optional int32 NumberOfButtons = 6;
  if (has_numberofbuttons()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->numberofbuttons(), target);
  }
  
  // optional int32 PointingType = 7;
  if (has_pointingtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->pointingtype(), target);
  }
  
  // optional int32 QuadSpeedThreshold = 8;
  if (has_quadspeedthreshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->quadspeedthreshold(), target);
  }
  
  // optional int32 Resolution = 9;
  if (has_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->resolution(), target);
  }
  
  // optional int32 SampleRate = 10;
  if (has_samplerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->samplerate(), target);
  }
  
  // optional int32 Synch = 12;
  if (has_synch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->synch(), target);
  }
  
  // optional int32 IsLocked = 13;
  if (has_islocked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->islocked(), target);
  }
  
  // optional string Description = 14;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->description(), target);
  }
  
  // optional string HardwareType = 16;
  if (has_hardwaretype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hardwaretype().data(), this->hardwaretype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->hardwaretype(), target);
  }
  
  // optional string InfFileName = 17;
  if (has_inffilename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->inffilename().data(), this->inffilename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->inffilename(), target);
  }
  
  // optional string InfSection = 18;
  if (has_infsection()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->infsection().data(), this->infsection().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->infsection(), target);
  }
  
  // optional string Manufacturer = 19;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->manufacturer(), target);
  }
  
  // optional string Name = 20;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->name(), target);
  }
  
  // optional string PNPDeviceID = 21;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->pnpdeviceid(), target);
  }
  
  // optional string Status = 22;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->status(), target);
  }
  
  // optional int32 Availability = 23;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(23, this->availability(), target);
  }
  
  // optional int32 DeviceInterface = 24;
  if (has_deviceinterface()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(24, this->deviceinterface(), target);
  }
  
  // optional double BuyTime = 25;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->buytime(), target);
  }
  
  // optional string BuyPrice = 26;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 27;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 28;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        28, this->otherinfo(), target);
  }
  
  // optional string BuyName = 29;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        29, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MouseInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 DoubleSpeedThreshold = 4;
    if (has_doublespeedthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->doublespeedthreshold());
    }
    
    // optional int32 Handedness = 5;
    if (has_handedness()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->handedness());
    }
    
    // optional int32 NumberOfButtons = 6;
    if (has_numberofbuttons()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberofbuttons());
    }
    
    // optional int32 PointingType = 7;
    if (has_pointingtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pointingtype());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 QuadSpeedThreshold = 8;
    if (has_quadspeedthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quadspeedthreshold());
    }
    
    // optional int32 Resolution = 9;
    if (has_resolution()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resolution());
    }
    
    // optional int32 SampleRate = 10;
    if (has_samplerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->samplerate());
    }
    
    // optional int32 Synch = 12;
    if (has_synch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->synch());
    }
    
    // optional int32 IsLocked = 13;
    if (has_islocked()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->islocked());
    }
    
    // optional string Description = 14;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string HardwareType = 16;
    if (has_hardwaretype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardwaretype());
    }
    
    // optional string InfFileName = 17;
    if (has_inffilename()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->inffilename());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string InfSection = 18;
    if (has_infsection()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->infsection());
    }
    
    // optional string Manufacturer = 19;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Name = 20;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string PNPDeviceID = 21;
    if (has_pnpdeviceid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string Status = 22;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional int32 Availability = 23;
    if (has_availability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 DeviceInterface = 24;
    if (has_deviceinterface()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deviceinterface());
    }
    
    // optional double BuyTime = 25;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string BuyPrice = 26;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 27;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 28;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 29;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MouseInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MouseInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MouseInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MouseInfo::MergeFrom(const MouseInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_doublespeedthreshold()) {
      set_doublespeedthreshold(from.doublespeedthreshold());
    }
    if (from.has_handedness()) {
      set_handedness(from.handedness());
    }
    if (from.has_numberofbuttons()) {
      set_numberofbuttons(from.numberofbuttons());
    }
    if (from.has_pointingtype()) {
      set_pointingtype(from.pointingtype());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_quadspeedthreshold()) {
      set_quadspeedthreshold(from.quadspeedthreshold());
    }
    if (from.has_resolution()) {
      set_resolution(from.resolution());
    }
    if (from.has_samplerate()) {
      set_samplerate(from.samplerate());
    }
    if (from.has_synch()) {
      set_synch(from.synch());
    }
    if (from.has_islocked()) {
      set_islocked(from.islocked());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_hardwaretype()) {
      set_hardwaretype(from.hardwaretype());
    }
    if (from.has_inffilename()) {
      set_inffilename(from.inffilename());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_infsection()) {
      set_infsection(from.infsection());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_deviceinterface()) {
      set_deviceinterface(from.deviceinterface());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MouseInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MouseInfo::CopyFrom(const MouseInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MouseInfo::IsInitialized() const {
  
  return true;
}

void MouseInfo::Swap(MouseInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(doublespeedthreshold_, other->doublespeedthreshold_);
    std::swap(handedness_, other->handedness_);
    std::swap(numberofbuttons_, other->numberofbuttons_);
    std::swap(pointingtype_, other->pointingtype_);
    std::swap(quadspeedthreshold_, other->quadspeedthreshold_);
    std::swap(resolution_, other->resolution_);
    std::swap(samplerate_, other->samplerate_);
    std::swap(synch_, other->synch_);
    std::swap(islocked_, other->islocked_);
    std::swap(description_, other->description_);
    std::swap(hardwaretype_, other->hardwaretype_);
    std::swap(inffilename_, other->inffilename_);
    std::swap(infsection_, other->infsection_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(status_, other->status_);
    std::swap(availability_, other->availability_);
    std::swap(deviceinterface_, other->deviceinterface_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MouseInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MouseInfo_descriptor_;
  metadata.reflection = MouseInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MouseInfoList::kListFieldNumber;
const int MouseInfoList::kAlarmedFieldNumber;
const int MouseInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

MouseInfoList::MouseInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MouseInfoList::InitAsDefaultInstance() {
}

MouseInfoList::MouseInfoList(const MouseInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MouseInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MouseInfoList::~MouseInfoList() {
  SharedDtor();
}

void MouseInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void MouseInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MouseInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MouseInfoList_descriptor_;
}

const MouseInfoList& MouseInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

MouseInfoList* MouseInfoList::default_instance_ = NULL;

MouseInfoList* MouseInfoList::New() const {
  return new MouseInfoList;
}

void MouseInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MouseInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.MouseInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MouseInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.MouseInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MouseInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.MouseInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MouseInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.MouseInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MouseInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MouseInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MouseInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MouseInfoList::MergeFrom(const MouseInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MouseInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MouseInfoList::CopyFrom(const MouseInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MouseInfoList::IsInitialized() const {
  
  return true;
}

void MouseInfoList::Swap(MouseInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MouseInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MouseInfoList_descriptor_;
  metadata.reflection = MouseInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NetWorkAdapterInfo::kPackageCodeFieldNumber;
const int NetWorkAdapterInfo::kChecktypeFieldNumber;
const int NetWorkAdapterInfo::kScanTimeFieldNumber;
const int NetWorkAdapterInfo::kAddtimeFieldNumber;
const int NetWorkAdapterInfo::kMaxNumberControlledFieldNumber;
const int NetWorkAdapterInfo::kAdapterTypeFieldNumber;
const int NetWorkAdapterInfo::kDescriptionFieldNumber;
const int NetWorkAdapterInfo::kNameFieldNumber;
const int NetWorkAdapterInfo::kMACAddressFieldNumber;
const int NetWorkAdapterInfo::kProductNameFieldNumber;
const int NetWorkAdapterInfo::kServiceNameFieldNumber;
const int NetWorkAdapterInfo::kPNPDeviceIDFieldNumber;
const int NetWorkAdapterInfo::kAdapterTypeIDFieldNumber;
const int NetWorkAdapterInfo::kIndexFieldNumber;
const int NetWorkAdapterInfo::kBuyTimeFieldNumber;
const int NetWorkAdapterInfo::kBuyPriceFieldNumber;
const int NetWorkAdapterInfo::kDCheckTimeFieldNumber;
const int NetWorkAdapterInfo::kOtherInfoFieldNumber;
const int NetWorkAdapterInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

NetWorkAdapterInfo::NetWorkAdapterInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NetWorkAdapterInfo::InitAsDefaultInstance() {
}

NetWorkAdapterInfo::NetWorkAdapterInfo(const NetWorkAdapterInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NetWorkAdapterInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  maxnumbercontrolled_ = 0;
  adaptertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  adaptertypeid_ = 0;
  index_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetWorkAdapterInfo::~NetWorkAdapterInfo() {
  SharedDtor();
}

void NetWorkAdapterInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (adaptertype_ != &::google::protobuf::internal::kEmptyString) {
    delete adaptertype_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete macaddress_;
  }
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    delete productname_;
  }
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    delete servicename_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void NetWorkAdapterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetWorkAdapterInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetWorkAdapterInfo_descriptor_;
}

const NetWorkAdapterInfo& NetWorkAdapterInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

NetWorkAdapterInfo* NetWorkAdapterInfo::default_instance_ = NULL;

NetWorkAdapterInfo* NetWorkAdapterInfo::New() const {
  return new NetWorkAdapterInfo;
}

void NetWorkAdapterInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    maxnumbercontrolled_ = 0;
    if (has_adaptertype()) {
      if (adaptertype_ != &::google::protobuf::internal::kEmptyString) {
        adaptertype_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_macaddress()) {
      if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
        macaddress_->clear();
      }
    }
    if (has_productname()) {
      if (productname_ != &::google::protobuf::internal::kEmptyString) {
        productname_->clear();
      }
    }
    if (has_servicename()) {
      if (servicename_ != &::google::protobuf::internal::kEmptyString) {
        servicename_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    adaptertypeid_ = 0;
    index_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetWorkAdapterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_MaxNumberControlled;
        break;
      }
      
      // optional int32 MaxNumberControlled = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxNumberControlled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxnumbercontrolled_)));
          set_has_maxnumbercontrolled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_AdapterType;
        break;
      }
      
      // optional string AdapterType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_AdapterType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_adaptertype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->adaptertype().data(), this->adaptertype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_Description;
        break;
      }
      
      // optional string Description = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_Name;
        break;
      }
      
      // optional string Name = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_MACAddress;
        break;
      }
      
      // optional string MACAddress = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MACAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_macaddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->macaddress().data(), this->macaddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_ProductName;
        break;
      }
      
      // optional string ProductName = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ProductName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_productname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->productname().data(), this->productname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_ServiceName;
        break;
      }
      
      // optional string ServiceName = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ServiceName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servicename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->servicename().data(), this->servicename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_AdapterTypeID;
        break;
      }
      
      // optional int32 AdapterTypeID = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AdapterTypeID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &adaptertypeid_)));
          set_has_adaptertypeid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_Index;
        break;
      }
      
      // optional int32 Index = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(145)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(161)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetWorkAdapterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 MaxNumberControlled = 4;
  if (has_maxnumbercontrolled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->maxnumbercontrolled(), output);
  }
  
  // optional string AdapterType = 5;
  if (has_adaptertype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->adaptertype().data(), this->adaptertype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->adaptertype(), output);
  }
  
  // optional string Description = 7;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->description(), output);
  }
  
  // optional string Name = 8;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->name(), output);
  }
  
  // optional string MACAddress = 10;
  if (has_macaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->macaddress().data(), this->macaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->macaddress(), output);
  }
  
  // optional string ProductName = 11;
  if (has_productname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->productname().data(), this->productname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->productname(), output);
  }
  
  // optional string ServiceName = 12;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->servicename(), output);
  }
  
  // optional string PNPDeviceID = 15;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->pnpdeviceid(), output);
  }
  
  // optional int32 AdapterTypeID = 16;
  if (has_adaptertypeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->adaptertypeid(), output);
  }
  
  // optional int32 Index = 17;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->index(), output);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->buytime(), output);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->otherinfo(), output);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NetWorkAdapterInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 MaxNumberControlled = 4;
  if (has_maxnumbercontrolled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->maxnumbercontrolled(), target);
  }
  
  // optional string AdapterType = 5;
  if (has_adaptertype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->adaptertype().data(), this->adaptertype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->adaptertype(), target);
  }
  
  // optional string Description = 7;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->description(), target);
  }
  
  // optional string Name = 8;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->name(), target);
  }
  
  // optional string MACAddress = 10;
  if (has_macaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->macaddress().data(), this->macaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->macaddress(), target);
  }
  
  // optional string ProductName = 11;
  if (has_productname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->productname().data(), this->productname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->productname(), target);
  }
  
  // optional string ServiceName = 12;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->servicename(), target);
  }
  
  // optional string PNPDeviceID = 15;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->pnpdeviceid(), target);
  }
  
  // optional int32 AdapterTypeID = 16;
  if (has_adaptertypeid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->adaptertypeid(), target);
  }
  
  // optional int32 Index = 17;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->index(), target);
  }
  
  // optional double BuyTime = 18;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->buytime(), target);
  }
  
  // optional string BuyPrice = 19;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 20;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 21;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        21, this->otherinfo(), target);
  }
  
  // optional string BuyName = 22;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NetWorkAdapterInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 MaxNumberControlled = 4;
    if (has_maxnumbercontrolled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxnumbercontrolled());
    }
    
    // optional string AdapterType = 5;
    if (has_adaptertype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->adaptertype());
    }
    
    // optional string Description = 7;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Name = 8;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string MACAddress = 10;
    if (has_macaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->macaddress());
    }
    
    // optional string ProductName = 11;
    if (has_productname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->productname());
    }
    
    // optional string ServiceName = 12;
    if (has_servicename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servicename());
    }
    
    // optional string PNPDeviceID = 15;
    if (has_pnpdeviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional int32 AdapterTypeID = 16;
    if (has_adaptertypeid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->adaptertypeid());
    }
    
    // optional int32 Index = 17;
    if (has_index()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }
    
    // optional double BuyTime = 18;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 19;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional double DCheckTime = 20;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 21;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 22;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetWorkAdapterInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetWorkAdapterInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetWorkAdapterInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetWorkAdapterInfo::MergeFrom(const NetWorkAdapterInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_maxnumbercontrolled()) {
      set_maxnumbercontrolled(from.maxnumbercontrolled());
    }
    if (from.has_adaptertype()) {
      set_adaptertype(from.adaptertype());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_macaddress()) {
      set_macaddress(from.macaddress());
    }
    if (from.has_productname()) {
      set_productname(from.productname());
    }
    if (from.has_servicename()) {
      set_servicename(from.servicename());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_adaptertypeid()) {
      set_adaptertypeid(from.adaptertypeid());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetWorkAdapterInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetWorkAdapterInfo::CopyFrom(const NetWorkAdapterInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetWorkAdapterInfo::IsInitialized() const {
  
  return true;
}

void NetWorkAdapterInfo::Swap(NetWorkAdapterInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(maxnumbercontrolled_, other->maxnumbercontrolled_);
    std::swap(adaptertype_, other->adaptertype_);
    std::swap(description_, other->description_);
    std::swap(name_, other->name_);
    std::swap(macaddress_, other->macaddress_);
    std::swap(productname_, other->productname_);
    std::swap(servicename_, other->servicename_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(adaptertypeid_, other->adaptertypeid_);
    std::swap(index_, other->index_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetWorkAdapterInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetWorkAdapterInfo_descriptor_;
  metadata.reflection = NetWorkAdapterInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NetWorkAdapterInfoList::kListFieldNumber;
const int NetWorkAdapterInfoList::kAlarmedFieldNumber;
const int NetWorkAdapterInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

NetWorkAdapterInfoList::NetWorkAdapterInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NetWorkAdapterInfoList::InitAsDefaultInstance() {
}

NetWorkAdapterInfoList::NetWorkAdapterInfoList(const NetWorkAdapterInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NetWorkAdapterInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetWorkAdapterInfoList::~NetWorkAdapterInfoList() {
  SharedDtor();
}

void NetWorkAdapterInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void NetWorkAdapterInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetWorkAdapterInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetWorkAdapterInfoList_descriptor_;
}

const NetWorkAdapterInfoList& NetWorkAdapterInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

NetWorkAdapterInfoList* NetWorkAdapterInfoList::default_instance_ = NULL;

NetWorkAdapterInfoList* NetWorkAdapterInfoList::New() const {
  return new NetWorkAdapterInfoList;
}

void NetWorkAdapterInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetWorkAdapterInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.NetWorkAdapterInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetWorkAdapterInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.NetWorkAdapterInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NetWorkAdapterInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.NetWorkAdapterInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NetWorkAdapterInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.NetWorkAdapterInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetWorkAdapterInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetWorkAdapterInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetWorkAdapterInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetWorkAdapterInfoList::MergeFrom(const NetWorkAdapterInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetWorkAdapterInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetWorkAdapterInfoList::CopyFrom(const NetWorkAdapterInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetWorkAdapterInfoList::IsInitialized() const {
  
  return true;
}

void NetWorkAdapterInfoList::Swap(NetWorkAdapterInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetWorkAdapterInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetWorkAdapterInfoList_descriptor_;
  metadata.reflection = NetWorkAdapterInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhysicalDiskDriversInfo::kPackageCodeFieldNumber;
const int PhysicalDiskDriversInfo::kChecktypeFieldNumber;
const int PhysicalDiskDriversInfo::kScanTimeFieldNumber;
const int PhysicalDiskDriversInfo::kAddtimeFieldNumber;
const int PhysicalDiskDriversInfo::kDefaultBlockSizeFieldNumber;
const int PhysicalDiskDriversInfo::kIndexFieldNumber;
const int PhysicalDiskDriversInfo::kMaxBlockSizeFieldNumber;
const int PhysicalDiskDriversInfo::kMaxMediaSizeFieldNumber;
const int PhysicalDiskDriversInfo::kMinBlockSizeFieldNumber;
const int PhysicalDiskDriversInfo::kNumberOfMediaSupportedFieldNumber;
const int PhysicalDiskDriversInfo::kPartitionsFieldNumber;
const int PhysicalDiskDriversInfo::kSCSIBusFieldNumber;
const int PhysicalDiskDriversInfo::kSCSILogicalUnitFieldNumber;
const int PhysicalDiskDriversInfo::kSCSIPortFieldNumber;
const int PhysicalDiskDriversInfo::kSCSITargetIdFieldNumber;
const int PhysicalDiskDriversInfo::kSectorsPerTrackFieldNumber;
const int PhysicalDiskDriversInfo::kSignatureFieldNumber;
const int PhysicalDiskDriversInfo::kSizeFieldNumber;
const int PhysicalDiskDriversInfo::kTotalCylindersFieldNumber;
const int PhysicalDiskDriversInfo::kTotalHeadsFieldNumber;
const int PhysicalDiskDriversInfo::kTotalSectorsFieldNumber;
const int PhysicalDiskDriversInfo::kTotalTracksFieldNumber;
const int PhysicalDiskDriversInfo::kTracksPerCylinderFieldNumber;
const int PhysicalDiskDriversInfo::kMediaLoadedFieldNumber;
const int PhysicalDiskDriversInfo::kNeedsCleaningFieldNumber;
const int PhysicalDiskDriversInfo::kCompressionMethodFieldNumber;
const int PhysicalDiskDriversInfo::kDescriptionFieldNumber;
const int PhysicalDiskDriversInfo::kFirmwareRevisionFieldNumber;
const int PhysicalDiskDriversInfo::kInterfaceTypeFieldNumber;
const int PhysicalDiskDriversInfo::kManufacturerFieldNumber;
const int PhysicalDiskDriversInfo::kMediaTypeFieldNumber;
const int PhysicalDiskDriversInfo::kModelFieldNumber;
const int PhysicalDiskDriversInfo::kNameFieldNumber;
const int PhysicalDiskDriversInfo::kPNPDeviceIDFieldNumber;
const int PhysicalDiskDriversInfo::kSerialNumberFieldNumber;
const int PhysicalDiskDriversInfo::kStatusFieldNumber;
const int PhysicalDiskDriversInfo::kAvailabilityFieldNumber;
const int PhysicalDiskDriversInfo::kBytesPerSectorFieldNumber;
const int PhysicalDiskDriversInfo::kBuyTimeFieldNumber;
const int PhysicalDiskDriversInfo::kBuyPriceFieldNumber;
const int PhysicalDiskDriversInfo::kDCheckTimeFieldNumber;
const int PhysicalDiskDriversInfo::kOtherInfoFieldNumber;
const int PhysicalDiskDriversInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

PhysicalDiskDriversInfo::PhysicalDiskDriversInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PhysicalDiskDriversInfo::InitAsDefaultInstance() {
}

PhysicalDiskDriversInfo::PhysicalDiskDriversInfo(const PhysicalDiskDriversInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PhysicalDiskDriversInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  defaultblocksize_ = GOOGLE_ULONGLONG(0);
  index_ = 0;
  maxblocksize_ = GOOGLE_ULONGLONG(0);
  maxmediasize_ = GOOGLE_ULONGLONG(0);
  minblocksize_ = GOOGLE_ULONGLONG(0);
  numberofmediasupported_ = 0;
  partitions_ = 0;
  scsibus_ = 0;
  scsilogicalunit_ = 0;
  scsiport_ = 0;
  scsitargetid_ = 0;
  sectorspertrack_ = 0;
  signature_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  totalcylinders_ = GOOGLE_ULONGLONG(0);
  totalheads_ = 0;
  totalsectors_ = GOOGLE_ULONGLONG(0);
  totaltracks_ = GOOGLE_ULONGLONG(0);
  trackspercylinder_ = 0u;
  medialoaded_ = 0u;
  needscleaning_ = 0;
  compressionmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  firmwarerevision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  interfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  bytespersector_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhysicalDiskDriversInfo::~PhysicalDiskDriversInfo() {
  SharedDtor();
}

void PhysicalDiskDriversInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
    delete compressionmethod_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (firmwarerevision_ != &::google::protobuf::internal::kEmptyString) {
    delete firmwarerevision_;
  }
  if (interfacetype_ != &::google::protobuf::internal::kEmptyString) {
    delete interfacetype_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    delete mediatype_;
  }
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void PhysicalDiskDriversInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhysicalDiskDriversInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhysicalDiskDriversInfo_descriptor_;
}

const PhysicalDiskDriversInfo& PhysicalDiskDriversInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

PhysicalDiskDriversInfo* PhysicalDiskDriversInfo::default_instance_ = NULL;

PhysicalDiskDriversInfo* PhysicalDiskDriversInfo::New() const {
  return new PhysicalDiskDriversInfo;
}

void PhysicalDiskDriversInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    defaultblocksize_ = GOOGLE_ULONGLONG(0);
    index_ = 0;
    maxblocksize_ = GOOGLE_ULONGLONG(0);
    maxmediasize_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    minblocksize_ = GOOGLE_ULONGLONG(0);
    numberofmediasupported_ = 0;
    partitions_ = 0;
    scsibus_ = 0;
    scsilogicalunit_ = 0;
    scsiport_ = 0;
    scsitargetid_ = 0;
    sectorspertrack_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    signature_ = 0;
    size_ = GOOGLE_ULONGLONG(0);
    totalcylinders_ = GOOGLE_ULONGLONG(0);
    totalheads_ = 0;
    totalsectors_ = GOOGLE_ULONGLONG(0);
    totaltracks_ = GOOGLE_ULONGLONG(0);
    trackspercylinder_ = 0u;
    medialoaded_ = 0u;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    needscleaning_ = 0;
    if (has_compressionmethod()) {
      if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
        compressionmethod_->clear();
      }
    }
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_firmwarerevision()) {
      if (firmwarerevision_ != &::google::protobuf::internal::kEmptyString) {
        firmwarerevision_->clear();
      }
    }
    if (has_interfacetype()) {
      if (interfacetype_ != &::google::protobuf::internal::kEmptyString) {
        interfacetype_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_mediatype()) {
      if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
        mediatype_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::kEmptyString) {
        model_->clear();
      }
    }
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_serialnumber()) {
      if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
        serialnumber_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    availability_ = 0;
    bytespersector_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhysicalDiskDriversInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_DefaultBlockSize;
        break;
      }
      
      // optional uint64 DefaultBlockSize = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DefaultBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &defaultblocksize_)));
          set_has_defaultblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Index;
        break;
      }
      
      // optional int32 Index = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_MaxBlockSize;
        break;
      }
      
      // optional uint64 MaxBlockSize = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxblocksize_)));
          set_has_maxblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_MaxMediaSize;
        break;
      }
      
      // optional uint64 MaxMediaSize = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxMediaSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxmediasize_)));
          set_has_maxmediasize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_MinBlockSize;
        break;
      }
      
      // optional uint64 MinBlockSize = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MinBlockSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &minblocksize_)));
          set_has_minblocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_NumberOfMediaSupported;
        break;
      }
      
      // optional int32 NumberOfMediaSupported = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NumberOfMediaSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numberofmediasupported_)));
          set_has_numberofmediasupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_Partitions;
        break;
      }
      
      // optional int32 Partitions = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Partitions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &partitions_)));
          set_has_partitions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_SCSIBus;
        break;
      }
      
      // optional int32 SCSIBus = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSIBus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsibus_)));
          set_has_scsibus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_SCSILogicalUnit;
        break;
      }
      
      // optional int32 SCSILogicalUnit = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSILogicalUnit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsilogicalunit_)));
          set_has_scsilogicalunit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_SCSIPort;
        break;
      }
      
      // optional int32 SCSIPort = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSIPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsiport_)));
          set_has_scsiport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_SCSITargetId;
        break;
      }
      
      // optional int32 SCSITargetId = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SCSITargetId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &scsitargetid_)));
          set_has_scsitargetid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_SectorsPerTrack;
        break;
      }
      
      // optional int32 SectorsPerTrack = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SectorsPerTrack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sectorspertrack_)));
          set_has_sectorspertrack();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_Signature;
        break;
      }
      
      // optional int32 Signature = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Signature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signature_)));
          set_has_signature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_Size;
        break;
      }
      
      // optional uint64 Size = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_TotalCylinders;
        break;
      }
      
      // optional uint64 TotalCylinders = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalCylinders:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &totalcylinders_)));
          set_has_totalcylinders();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_TotalHeads;
        break;
      }
      
      // optional int32 TotalHeads = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalHeads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totalheads_)));
          set_has_totalheads();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_TotalSectors;
        break;
      }
      
      // optional uint64 TotalSectors = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalSectors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &totalsectors_)));
          set_has_totalsectors();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_TotalTracks;
        break;
      }
      
      // optional uint64 TotalTracks = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TotalTracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &totaltracks_)));
          set_has_totaltracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_TracksPerCylinder;
        break;
      }
      
      // optional uint32 TracksPerCylinder = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TracksPerCylinder:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trackspercylinder_)));
          set_has_trackspercylinder();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_MediaLoaded;
        break;
      }
      
      // optional uint32 MediaLoaded = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MediaLoaded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &medialoaded_)));
          set_has_medialoaded();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_NeedsCleaning;
        break;
      }
      
      // optional int32 NeedsCleaning = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NeedsCleaning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &needscleaning_)));
          set_has_needscleaning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_CompressionMethod;
        break;
      }
      
      // optional string CompressionMethod = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CompressionMethod:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_compressionmethod()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->compressionmethod().data(), this->compressionmethod().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_Description;
        break;
      }
      
      // optional string Description = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_FirmwareRevision;
        break;
      }
      
      // optional string FirmwareRevision = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_FirmwareRevision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmwarerevision()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->firmwarerevision().data(), this->firmwarerevision().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_InterfaceType;
        break;
      }
      
      // optional string InterfaceType = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_InterfaceType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_interfacetype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->interfacetype().data(), this->interfacetype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_MediaType;
        break;
      }
      
      // optional string MediaType = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MediaType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mediatype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mediatype().data(), this->mediatype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(258)) goto parse_Model;
        break;
      }
      
      // optional string Model = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(266)) goto parse_Name;
        break;
      }
      
      // optional string Name = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(282)) goto parse_SerialNumber;
        break;
      }
      
      // optional string SerialNumber = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serialnumber().data(), this->serialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(290)) goto parse_Status;
        break;
      }
      
      // optional string Status = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(296)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_BytesPerSector;
        break;
      }
      
      // optional int32 BytesPerSector = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BytesPerSector:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bytespersector_)));
          set_has_bytespersector();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(313)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(329)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(338)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(346)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PhysicalDiskDriversInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional uint64 DefaultBlockSize = 4;
  if (has_defaultblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->defaultblocksize(), output);
  }
  
  // optional int32 Index = 5;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->index(), output);
  }
  
  // optional uint64 MaxBlockSize = 6;
  if (has_maxblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->maxblocksize(), output);
  }
  
  // optional uint64 MaxMediaSize = 7;
  if (has_maxmediasize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->maxmediasize(), output);
  }
  
  // optional uint64 MinBlockSize = 8;
  if (has_minblocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->minblocksize(), output);
  }
  
  // optional int32 NumberOfMediaSupported = 9;
  if (has_numberofmediasupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->numberofmediasupported(), output);
  }
  
  // optional int32 Partitions = 10;
  if (has_partitions()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->partitions(), output);
  }
  
  // optional int32 SCSIBus = 11;
  if (has_scsibus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->scsibus(), output);
  }
  
  // optional int32 SCSILogicalUnit = 12;
  if (has_scsilogicalunit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->scsilogicalunit(), output);
  }
  
  // optional int32 SCSIPort = 13;
  if (has_scsiport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->scsiport(), output);
  }
  
  // optional int32 SCSITargetId = 14;
  if (has_scsitargetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->scsitargetid(), output);
  }
  
  // optional int32 SectorsPerTrack = 15;
  if (has_sectorspertrack()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->sectorspertrack(), output);
  }
  
  // optional int32 Signature = 16;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->signature(), output);
  }
  
  // optional uint64 Size = 17;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->size(), output);
  }
  
  // optional uint64 TotalCylinders = 19;
  if (has_totalcylinders()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->totalcylinders(), output);
  }
  
  // optional int32 TotalHeads = 20;
  if (has_totalheads()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(20, this->totalheads(), output);
  }
  
  // optional uint64 TotalSectors = 21;
  if (has_totalsectors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->totalsectors(), output);
  }
  
  // optional uint64 TotalTracks = 22;
  if (has_totaltracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(22, this->totaltracks(), output);
  }
  
  // optional uint32 TracksPerCylinder = 23;
  if (has_trackspercylinder()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->trackspercylinder(), output);
  }
  
  // optional uint32 MediaLoaded = 24;
  if (has_medialoaded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(24, this->medialoaded(), output);
  }
  
  // optional int32 NeedsCleaning = 25;
  if (has_needscleaning()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(25, this->needscleaning(), output);
  }
  
  // optional string CompressionMethod = 26;
  if (has_compressionmethod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->compressionmethod().data(), this->compressionmethod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->compressionmethod(), output);
  }
  
  // optional string Description = 27;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->description(), output);
  }
  
  // optional string FirmwareRevision = 28;
  if (has_firmwarerevision()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->firmwarerevision().data(), this->firmwarerevision().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      28, this->firmwarerevision(), output);
  }
  
  // optional string InterfaceType = 29;
  if (has_interfacetype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->interfacetype().data(), this->interfacetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      29, this->interfacetype(), output);
  }
  
  // optional string Manufacturer = 30;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->manufacturer(), output);
  }
  
  // optional string MediaType = 31;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediatype().data(), this->mediatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      31, this->mediatype(), output);
  }
  
  // optional string Model = 32;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      32, this->model(), output);
  }
  
  // optional string Name = 33;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      33, this->name(), output);
  }
  
  // optional string PNPDeviceID = 34;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      34, this->pnpdeviceid(), output);
  }
  
  // optional string SerialNumber = 35;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      35, this->serialnumber(), output);
  }
  
  // optional string Status = 36;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      36, this->status(), output);
  }
  
  // optional int32 Availability = 37;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(37, this->availability(), output);
  }
  
  // optional int32 BytesPerSector = 38;
  if (has_bytespersector()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(38, this->bytespersector(), output);
  }
  
  // optional double BuyTime = 39;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(39, this->buytime(), output);
  }
  
  // optional string BuyPrice = 40;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      40, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 41;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(41, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 42;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      42, this->otherinfo(), output);
  }
  
  // optional string BuyName = 43;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      43, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PhysicalDiskDriversInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional uint64 DefaultBlockSize = 4;
  if (has_defaultblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->defaultblocksize(), target);
  }
  
  // optional int32 Index = 5;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->index(), target);
  }
  
  // optional uint64 MaxBlockSize = 6;
  if (has_maxblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->maxblocksize(), target);
  }
  
  // optional uint64 MaxMediaSize = 7;
  if (has_maxmediasize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->maxmediasize(), target);
  }
  
  // optional uint64 MinBlockSize = 8;
  if (has_minblocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->minblocksize(), target);
  }
  
  // optional int32 NumberOfMediaSupported = 9;
  if (has_numberofmediasupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->numberofmediasupported(), target);
  }
  
  // optional int32 Partitions = 10;
  if (has_partitions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->partitions(), target);
  }
  
  // optional int32 SCSIBus = 11;
  if (has_scsibus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->scsibus(), target);
  }
  
  // optional int32 SCSILogicalUnit = 12;
  if (has_scsilogicalunit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->scsilogicalunit(), target);
  }
  
  // optional int32 SCSIPort = 13;
  if (has_scsiport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->scsiport(), target);
  }
  
  // optional int32 SCSITargetId = 14;
  if (has_scsitargetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->scsitargetid(), target);
  }
  
  // optional int32 SectorsPerTrack = 15;
  if (has_sectorspertrack()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->sectorspertrack(), target);
  }
  
  // optional int32 Signature = 16;
  if (has_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->signature(), target);
  }
  
  // optional uint64 Size = 17;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->size(), target);
  }
  
  // optional uint64 TotalCylinders = 19;
  if (has_totalcylinders()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->totalcylinders(), target);
  }
  
  // optional int32 TotalHeads = 20;
  if (has_totalheads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(20, this->totalheads(), target);
  }
  
  // optional uint64 TotalSectors = 21;
  if (has_totalsectors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->totalsectors(), target);
  }
  
  // optional uint64 TotalTracks = 22;
  if (has_totaltracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(22, this->totaltracks(), target);
  }
  
  // optional uint32 TracksPerCylinder = 23;
  if (has_trackspercylinder()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->trackspercylinder(), target);
  }
  
  // optional uint32 MediaLoaded = 24;
  if (has_medialoaded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(24, this->medialoaded(), target);
  }
  
  // optional int32 NeedsCleaning = 25;
  if (has_needscleaning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(25, this->needscleaning(), target);
  }
  
  // optional string CompressionMethod = 26;
  if (has_compressionmethod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->compressionmethod().data(), this->compressionmethod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->compressionmethod(), target);
  }
  
  // optional string Description = 27;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->description(), target);
  }
  
  // optional string FirmwareRevision = 28;
  if (has_firmwarerevision()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->firmwarerevision().data(), this->firmwarerevision().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        28, this->firmwarerevision(), target);
  }
  
  // optional string InterfaceType = 29;
  if (has_interfacetype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->interfacetype().data(), this->interfacetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        29, this->interfacetype(), target);
  }
  
  // optional string Manufacturer = 30;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->manufacturer(), target);
  }
  
  // optional string MediaType = 31;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediatype().data(), this->mediatype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        31, this->mediatype(), target);
  }
  
  // optional string Model = 32;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        32, this->model(), target);
  }
  
  // optional string Name = 33;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        33, this->name(), target);
  }
  
  // optional string PNPDeviceID = 34;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        34, this->pnpdeviceid(), target);
  }
  
  // optional string SerialNumber = 35;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        35, this->serialnumber(), target);
  }
  
  // optional string Status = 36;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        36, this->status(), target);
  }
  
  // optional int32 Availability = 37;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(37, this->availability(), target);
  }
  
  // optional int32 BytesPerSector = 38;
  if (has_bytespersector()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(38, this->bytespersector(), target);
  }
  
  // optional double BuyTime = 39;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(39, this->buytime(), target);
  }
  
  // optional string BuyPrice = 40;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        40, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 41;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(41, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 42;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        42, this->otherinfo(), target);
  }
  
  // optional string BuyName = 43;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        43, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PhysicalDiskDriversInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional uint64 DefaultBlockSize = 4;
    if (has_defaultblocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->defaultblocksize());
    }
    
    // optional int32 Index = 5;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }
    
    // optional uint64 MaxBlockSize = 6;
    if (has_maxblocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxblocksize());
    }
    
    // optional uint64 MaxMediaSize = 7;
    if (has_maxmediasize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxmediasize());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 MinBlockSize = 8;
    if (has_minblocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->minblocksize());
    }
    
    // optional int32 NumberOfMediaSupported = 9;
    if (has_numberofmediasupported()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numberofmediasupported());
    }
    
    // optional int32 Partitions = 10;
    if (has_partitions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->partitions());
    }
    
    // optional int32 SCSIBus = 11;
    if (has_scsibus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsibus());
    }
    
    // optional int32 SCSILogicalUnit = 12;
    if (has_scsilogicalunit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsilogicalunit());
    }
    
    // optional int32 SCSIPort = 13;
    if (has_scsiport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsiport());
    }
    
    // optional int32 SCSITargetId = 14;
    if (has_scsitargetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->scsitargetid());
    }
    
    // optional int32 SectorsPerTrack = 15;
    if (has_sectorspertrack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sectorspertrack());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 Signature = 16;
    if (has_signature()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->signature());
    }
    
    // optional uint64 Size = 17;
    if (has_size()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }
    
    // optional uint64 TotalCylinders = 19;
    if (has_totalcylinders()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->totalcylinders());
    }
    
    // optional int32 TotalHeads = 20;
    if (has_totalheads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->totalheads());
    }
    
    // optional uint64 TotalSectors = 21;
    if (has_totalsectors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->totalsectors());
    }
    
    // optional uint64 TotalTracks = 22;
    if (has_totaltracks()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->totaltracks());
    }
    
    // optional uint32 TracksPerCylinder = 23;
    if (has_trackspercylinder()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trackspercylinder());
    }
    
    // optional uint32 MediaLoaded = 24;
    if (has_medialoaded()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->medialoaded());
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional int32 NeedsCleaning = 25;
    if (has_needscleaning()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->needscleaning());
    }
    
    // optional string CompressionMethod = 26;
    if (has_compressionmethod()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->compressionmethod());
    }
    
    // optional string Description = 27;
    if (has_description()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string FirmwareRevision = 28;
    if (has_firmwarerevision()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmwarerevision());
    }
    
    // optional string InterfaceType = 29;
    if (has_interfacetype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->interfacetype());
    }
    
    // optional string Manufacturer = 30;
    if (has_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string MediaType = 31;
    if (has_mediatype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mediatype());
    }
    
    // optional string Model = 32;
    if (has_model()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }
    
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional string Name = 33;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string PNPDeviceID = 34;
    if (has_pnpdeviceid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string SerialNumber = 35;
    if (has_serialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serialnumber());
    }
    
    // optional string Status = 36;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional int32 Availability = 37;
    if (has_availability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 BytesPerSector = 38;
    if (has_bytespersector()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bytespersector());
    }
    
    // optional double BuyTime = 39;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 40;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional double DCheckTime = 41;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 42;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 43;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhysicalDiskDriversInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhysicalDiskDriversInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhysicalDiskDriversInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhysicalDiskDriversInfo::MergeFrom(const PhysicalDiskDriversInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_defaultblocksize()) {
      set_defaultblocksize(from.defaultblocksize());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_maxblocksize()) {
      set_maxblocksize(from.maxblocksize());
    }
    if (from.has_maxmediasize()) {
      set_maxmediasize(from.maxmediasize());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_minblocksize()) {
      set_minblocksize(from.minblocksize());
    }
    if (from.has_numberofmediasupported()) {
      set_numberofmediasupported(from.numberofmediasupported());
    }
    if (from.has_partitions()) {
      set_partitions(from.partitions());
    }
    if (from.has_scsibus()) {
      set_scsibus(from.scsibus());
    }
    if (from.has_scsilogicalunit()) {
      set_scsilogicalunit(from.scsilogicalunit());
    }
    if (from.has_scsiport()) {
      set_scsiport(from.scsiport());
    }
    if (from.has_scsitargetid()) {
      set_scsitargetid(from.scsitargetid());
    }
    if (from.has_sectorspertrack()) {
      set_sectorspertrack(from.sectorspertrack());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_totalcylinders()) {
      set_totalcylinders(from.totalcylinders());
    }
    if (from.has_totalheads()) {
      set_totalheads(from.totalheads());
    }
    if (from.has_totalsectors()) {
      set_totalsectors(from.totalsectors());
    }
    if (from.has_totaltracks()) {
      set_totaltracks(from.totaltracks());
    }
    if (from.has_trackspercylinder()) {
      set_trackspercylinder(from.trackspercylinder());
    }
    if (from.has_medialoaded()) {
      set_medialoaded(from.medialoaded());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_needscleaning()) {
      set_needscleaning(from.needscleaning());
    }
    if (from.has_compressionmethod()) {
      set_compressionmethod(from.compressionmethod());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_firmwarerevision()) {
      set_firmwarerevision(from.firmwarerevision());
    }
    if (from.has_interfacetype()) {
      set_interfacetype(from.interfacetype());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_mediatype()) {
      set_mediatype(from.mediatype());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_bytespersector()) {
      set_bytespersector(from.bytespersector());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhysicalDiskDriversInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhysicalDiskDriversInfo::CopyFrom(const PhysicalDiskDriversInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicalDiskDriversInfo::IsInitialized() const {
  
  return true;
}

void PhysicalDiskDriversInfo::Swap(PhysicalDiskDriversInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(defaultblocksize_, other->defaultblocksize_);
    std::swap(index_, other->index_);
    std::swap(maxblocksize_, other->maxblocksize_);
    std::swap(maxmediasize_, other->maxmediasize_);
    std::swap(minblocksize_, other->minblocksize_);
    std::swap(numberofmediasupported_, other->numberofmediasupported_);
    std::swap(partitions_, other->partitions_);
    std::swap(scsibus_, other->scsibus_);
    std::swap(scsilogicalunit_, other->scsilogicalunit_);
    std::swap(scsiport_, other->scsiport_);
    std::swap(scsitargetid_, other->scsitargetid_);
    std::swap(sectorspertrack_, other->sectorspertrack_);
    std::swap(signature_, other->signature_);
    std::swap(size_, other->size_);
    std::swap(totalcylinders_, other->totalcylinders_);
    std::swap(totalheads_, other->totalheads_);
    std::swap(totalsectors_, other->totalsectors_);
    std::swap(totaltracks_, other->totaltracks_);
    std::swap(trackspercylinder_, other->trackspercylinder_);
    std::swap(medialoaded_, other->medialoaded_);
    std::swap(needscleaning_, other->needscleaning_);
    std::swap(compressionmethod_, other->compressionmethod_);
    std::swap(description_, other->description_);
    std::swap(firmwarerevision_, other->firmwarerevision_);
    std::swap(interfacetype_, other->interfacetype_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(mediatype_, other->mediatype_);
    std::swap(model_, other->model_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(status_, other->status_);
    std::swap(availability_, other->availability_);
    std::swap(bytespersector_, other->bytespersector_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhysicalDiskDriversInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhysicalDiskDriversInfo_descriptor_;
  metadata.reflection = PhysicalDiskDriversInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhysicalDiskDriversInfoList::kListFieldNumber;
const int PhysicalDiskDriversInfoList::kAlarmedFieldNumber;
const int PhysicalDiskDriversInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

PhysicalDiskDriversInfoList::PhysicalDiskDriversInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PhysicalDiskDriversInfoList::InitAsDefaultInstance() {
}

PhysicalDiskDriversInfoList::PhysicalDiskDriversInfoList(const PhysicalDiskDriversInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PhysicalDiskDriversInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhysicalDiskDriversInfoList::~PhysicalDiskDriversInfoList() {
  SharedDtor();
}

void PhysicalDiskDriversInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void PhysicalDiskDriversInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhysicalDiskDriversInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhysicalDiskDriversInfoList_descriptor_;
}

const PhysicalDiskDriversInfoList& PhysicalDiskDriversInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

PhysicalDiskDriversInfoList* PhysicalDiskDriversInfoList::default_instance_ = NULL;

PhysicalDiskDriversInfoList* PhysicalDiskDriversInfoList::New() const {
  return new PhysicalDiskDriversInfoList;
}

void PhysicalDiskDriversInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhysicalDiskDriversInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.PhysicalDiskDriversInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PhysicalDiskDriversInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.PhysicalDiskDriversInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PhysicalDiskDriversInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.PhysicalDiskDriversInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PhysicalDiskDriversInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.PhysicalDiskDriversInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhysicalDiskDriversInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhysicalDiskDriversInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhysicalDiskDriversInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhysicalDiskDriversInfoList::MergeFrom(const PhysicalDiskDriversInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhysicalDiskDriversInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhysicalDiskDriversInfoList::CopyFrom(const PhysicalDiskDriversInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicalDiskDriversInfoList::IsInitialized() const {
  
  return true;
}

void PhysicalDiskDriversInfoList::Swap(PhysicalDiskDriversInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhysicalDiskDriversInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhysicalDiskDriversInfoList_descriptor_;
  metadata.reflection = PhysicalDiskDriversInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhysicalMediaInfo::kPackageCodeFieldNumber;
const int PhysicalMediaInfo::kChecktypeFieldNumber;
const int PhysicalMediaInfo::kScanTimeFieldNumber;
const int PhysicalMediaInfo::kAddtimeFieldNumber;
const int PhysicalMediaInfo::kCleanerMediaFieldNumber;
const int PhysicalMediaInfo::kHotSwappableFieldNumber;
const int PhysicalMediaInfo::kPoweredOnFieldNumber;
const int PhysicalMediaInfo::kRemovableFieldNumber;
const int PhysicalMediaInfo::kReplaceableFieldNumber;
const int PhysicalMediaInfo::kWriteProtectOnFieldNumber;
const int PhysicalMediaInfo::kDescriptionFieldNumber;
const int PhysicalMediaInfo::kManufacturerFieldNumber;
const int PhysicalMediaInfo::kMediaDescriptionFieldNumber;
const int PhysicalMediaInfo::kModelFieldNumber;
const int PhysicalMediaInfo::kNameFieldNumber;
const int PhysicalMediaInfo::kOtherIdentifyingInfoFieldNumber;
const int PhysicalMediaInfo::kPartNumberFieldNumber;
const int PhysicalMediaInfo::kSKUFieldNumber;
const int PhysicalMediaInfo::kStatusFieldNumber;
const int PhysicalMediaInfo::kVersionFieldNumber;
const int PhysicalMediaInfo::kSerialNumberFieldNumber;
const int PhysicalMediaInfo::kCapacityFieldNumber;
const int PhysicalMediaInfo::kMediaTypeFieldNumber;
const int PhysicalMediaInfo::kBuyTimeFieldNumber;
const int PhysicalMediaInfo::kBuyPriceFieldNumber;
const int PhysicalMediaInfo::kDCheckTimeFieldNumber;
const int PhysicalMediaInfo::kOtherInfoFieldNumber;
const int PhysicalMediaInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

PhysicalMediaInfo::PhysicalMediaInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PhysicalMediaInfo::InitAsDefaultInstance() {
}

PhysicalMediaInfo::PhysicalMediaInfo(const PhysicalMediaInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PhysicalMediaInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  cleanermedia_ = 0;
  hotswappable_ = 0;
  poweredon_ = 0;
  removable_ = 0;
  replaceable_ = 0;
  writeprotecton_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mediadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  capacity_ = 0;
  mediatype_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhysicalMediaInfo::~PhysicalMediaInfo() {
  SharedDtor();
}

void PhysicalMediaInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (mediadescription_ != &::google::protobuf::internal::kEmptyString) {
    delete mediadescription_;
  }
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otheridentifyinginfo_;
  }
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete partnumber_;
  }
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    delete sku_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void PhysicalMediaInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhysicalMediaInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhysicalMediaInfo_descriptor_;
}

const PhysicalMediaInfo& PhysicalMediaInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

PhysicalMediaInfo* PhysicalMediaInfo::default_instance_ = NULL;

PhysicalMediaInfo* PhysicalMediaInfo::New() const {
  return new PhysicalMediaInfo;
}

void PhysicalMediaInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    cleanermedia_ = 0;
    hotswappable_ = 0;
    poweredon_ = 0;
    removable_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    replaceable_ = 0;
    writeprotecton_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_mediadescription()) {
      if (mediadescription_ != &::google::protobuf::internal::kEmptyString) {
        mediadescription_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::kEmptyString) {
        model_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_otheridentifyinginfo()) {
      if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
        otheridentifyinginfo_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_partnumber()) {
      if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
        partnumber_->clear();
      }
    }
    if (has_sku()) {
      if (sku_ != &::google::protobuf::internal::kEmptyString) {
        sku_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_serialnumber()) {
      if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
        serialnumber_->clear();
      }
    }
    capacity_ = 0;
    mediatype_ = 0;
    buytime_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhysicalMediaInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_CleanerMedia;
        break;
      }
      
      // optional int32 CleanerMedia = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CleanerMedia:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cleanermedia_)));
          set_has_cleanermedia();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_HotSwappable;
        break;
      }
      
      // optional int32 HotSwappable = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HotSwappable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hotswappable_)));
          set_has_hotswappable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_PoweredOn;
        break;
      }
      
      // optional int32 PoweredOn = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PoweredOn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &poweredon_)));
          set_has_poweredon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_Removable;
        break;
      }
      
      // optional int32 Removable = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Removable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &removable_)));
          set_has_removable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_Replaceable;
        break;
      }
      
      // optional int32 Replaceable = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Replaceable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &replaceable_)));
          set_has_replaceable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_WriteProtectOn;
        break;
      }
      
      // optional int32 WriteProtectOn = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WriteProtectOn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &writeprotecton_)));
          set_has_writeprotecton();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_Description;
        break;
      }
      
      // optional string Description = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_MediaDescription;
        break;
      }
      
      // optional string MediaDescription = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MediaDescription:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mediadescription()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mediadescription().data(), this->mediadescription().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_Model;
        break;
      }
      
      // optional string Model = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Name;
        break;
      }
      
      // optional string Name = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_OtherIdentifyingInfo;
        break;
      }
      
      // optional string OtherIdentifyingInfo = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherIdentifyingInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otheridentifyinginfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_PartNumber;
        break;
      }
      
      // optional string PartNumber = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PartNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->partnumber().data(), this->partnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_SKU;
        break;
      }
      
      // optional string SKU = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SKU:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sku()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->sku().data(), this->sku().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_Status;
        break;
      }
      
      // optional string Status = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_Version;
        break;
      }
      
      // optional string Version = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_SerialNumber;
        break;
      }
      
      // optional string SerialNumber = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SerialNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_serialnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->serialnumber().data(), this->serialnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_Capacity;
        break;
      }
      
      // optional int32 Capacity = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_MediaType;
        break;
      }
      
      // optional int32 MediaType = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MediaType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mediatype_)));
          set_has_mediatype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(185)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(201)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PhysicalMediaInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 CleanerMedia = 4;
  if (has_cleanermedia()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->cleanermedia(), output);
  }
  
  // optional int32 HotSwappable = 5;
  if (has_hotswappable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->hotswappable(), output);
  }
  
  // optional int32 PoweredOn = 6;
  if (has_poweredon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->poweredon(), output);
  }
  
  // optional int32 Removable = 7;
  if (has_removable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->removable(), output);
  }
  
  // optional int32 Replaceable = 8;
  if (has_replaceable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->replaceable(), output);
  }
  
  // optional int32 WriteProtectOn = 9;
  if (has_writeprotecton()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->writeprotecton(), output);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->description(), output);
  }
  
  // optional string Manufacturer = 11;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->manufacturer(), output);
  }
  
  // optional string MediaDescription = 12;
  if (has_mediadescription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediadescription().data(), this->mediadescription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->mediadescription(), output);
  }
  
  // optional string Model = 13;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->model(), output);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->name(), output);
  }
  
  // optional string OtherIdentifyingInfo = 15;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->otheridentifyinginfo(), output);
  }
  
  // optional string PartNumber = 16;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->partnumber(), output);
  }
  
  // optional string SKU = 17;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->sku(), output);
  }
  
  // optional string Status = 18;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->status(), output);
  }
  
  // optional string Version = 19;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->version(), output);
  }
  
  // optional string SerialNumber = 20;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->serialnumber(), output);
  }
  
  // optional int32 Capacity = 21;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(21, this->capacity(), output);
  }
  
  // optional int32 MediaType = 22;
  if (has_mediatype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->mediatype(), output);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->buytime(), output);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      24, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      26, this->otherinfo(), output);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      27, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PhysicalMediaInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 CleanerMedia = 4;
  if (has_cleanermedia()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->cleanermedia(), target);
  }
  
  // optional int32 HotSwappable = 5;
  if (has_hotswappable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->hotswappable(), target);
  }
  
  // optional int32 PoweredOn = 6;
  if (has_poweredon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->poweredon(), target);
  }
  
  // optional int32 Removable = 7;
  if (has_removable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->removable(), target);
  }
  
  // optional int32 Replaceable = 8;
  if (has_replaceable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->replaceable(), target);
  }
  
  // optional int32 WriteProtectOn = 9;
  if (has_writeprotecton()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->writeprotecton(), target);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->description(), target);
  }
  
  // optional string Manufacturer = 11;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->manufacturer(), target);
  }
  
  // optional string MediaDescription = 12;
  if (has_mediadescription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mediadescription().data(), this->mediadescription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->mediadescription(), target);
  }
  
  // optional string Model = 13;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->model(), target);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->name(), target);
  }
  
  // optional string OtherIdentifyingInfo = 15;
  if (has_otheridentifyinginfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otheridentifyinginfo().data(), this->otheridentifyinginfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->otheridentifyinginfo(), target);
  }
  
  // optional string PartNumber = 16;
  if (has_partnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partnumber().data(), this->partnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->partnumber(), target);
  }
  
  // optional string SKU = 17;
  if (has_sku()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->sku().data(), this->sku().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->sku(), target);
  }
  
  // optional string Status = 18;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->status(), target);
  }
  
  // optional string Version = 19;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->version(), target);
  }
  
  // optional string SerialNumber = 20;
  if (has_serialnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->serialnumber().data(), this->serialnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->serialnumber(), target);
  }
  
  // optional int32 Capacity = 21;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(21, this->capacity(), target);
  }
  
  // optional int32 MediaType = 22;
  if (has_mediatype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->mediatype(), target);
  }
  
  // optional double BuyTime = 23;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->buytime(), target);
  }
  
  // optional string BuyPrice = 24;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 25;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 26;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        26, this->otherinfo(), target);
  }
  
  // optional string BuyName = 27;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        27, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PhysicalMediaInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 CleanerMedia = 4;
    if (has_cleanermedia()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cleanermedia());
    }
    
    // optional int32 HotSwappable = 5;
    if (has_hotswappable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hotswappable());
    }
    
    // optional int32 PoweredOn = 6;
    if (has_poweredon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->poweredon());
    }
    
    // optional int32 Removable = 7;
    if (has_removable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->removable());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 Replaceable = 8;
    if (has_replaceable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->replaceable());
    }
    
    // optional int32 WriteProtectOn = 9;
    if (has_writeprotecton()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->writeprotecton());
    }
    
    // optional string Description = 10;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string Manufacturer = 11;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string MediaDescription = 12;
    if (has_mediadescription()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mediadescription());
    }
    
    // optional string Model = 13;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }
    
    // optional string Name = 14;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string OtherIdentifyingInfo = 15;
    if (has_otheridentifyinginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otheridentifyinginfo());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string PartNumber = 16;
    if (has_partnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->partnumber());
    }
    
    // optional string SKU = 17;
    if (has_sku()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sku());
    }
    
    // optional string Status = 18;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string Version = 19;
    if (has_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional string SerialNumber = 20;
    if (has_serialnumber()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->serialnumber());
    }
    
    // optional int32 Capacity = 21;
    if (has_capacity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->capacity());
    }
    
    // optional int32 MediaType = 22;
    if (has_mediatype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mediatype());
    }
    
    // optional double BuyTime = 23;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional string BuyPrice = 24;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 25;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 26;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 27;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhysicalMediaInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhysicalMediaInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhysicalMediaInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhysicalMediaInfo::MergeFrom(const PhysicalMediaInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_cleanermedia()) {
      set_cleanermedia(from.cleanermedia());
    }
    if (from.has_hotswappable()) {
      set_hotswappable(from.hotswappable());
    }
    if (from.has_poweredon()) {
      set_poweredon(from.poweredon());
    }
    if (from.has_removable()) {
      set_removable(from.removable());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_replaceable()) {
      set_replaceable(from.replaceable());
    }
    if (from.has_writeprotecton()) {
      set_writeprotecton(from.writeprotecton());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_mediadescription()) {
      set_mediadescription(from.mediadescription());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_otheridentifyinginfo()) {
      set_otheridentifyinginfo(from.otheridentifyinginfo());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_partnumber()) {
      set_partnumber(from.partnumber());
    }
    if (from.has_sku()) {
      set_sku(from.sku());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_serialnumber()) {
      set_serialnumber(from.serialnumber());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_mediatype()) {
      set_mediatype(from.mediatype());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhysicalMediaInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhysicalMediaInfo::CopyFrom(const PhysicalMediaInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicalMediaInfo::IsInitialized() const {
  
  return true;
}

void PhysicalMediaInfo::Swap(PhysicalMediaInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(cleanermedia_, other->cleanermedia_);
    std::swap(hotswappable_, other->hotswappable_);
    std::swap(poweredon_, other->poweredon_);
    std::swap(removable_, other->removable_);
    std::swap(replaceable_, other->replaceable_);
    std::swap(writeprotecton_, other->writeprotecton_);
    std::swap(description_, other->description_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(mediadescription_, other->mediadescription_);
    std::swap(model_, other->model_);
    std::swap(name_, other->name_);
    std::swap(otheridentifyinginfo_, other->otheridentifyinginfo_);
    std::swap(partnumber_, other->partnumber_);
    std::swap(sku_, other->sku_);
    std::swap(status_, other->status_);
    std::swap(version_, other->version_);
    std::swap(serialnumber_, other->serialnumber_);
    std::swap(capacity_, other->capacity_);
    std::swap(mediatype_, other->mediatype_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhysicalMediaInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhysicalMediaInfo_descriptor_;
  metadata.reflection = PhysicalMediaInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhysicalMediaInfoList::kListFieldNumber;
const int PhysicalMediaInfoList::kAlarmedFieldNumber;
const int PhysicalMediaInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

PhysicalMediaInfoList::PhysicalMediaInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PhysicalMediaInfoList::InitAsDefaultInstance() {
}

PhysicalMediaInfoList::PhysicalMediaInfoList(const PhysicalMediaInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PhysicalMediaInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhysicalMediaInfoList::~PhysicalMediaInfoList() {
  SharedDtor();
}

void PhysicalMediaInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void PhysicalMediaInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhysicalMediaInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhysicalMediaInfoList_descriptor_;
}

const PhysicalMediaInfoList& PhysicalMediaInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

PhysicalMediaInfoList* PhysicalMediaInfoList::default_instance_ = NULL;

PhysicalMediaInfoList* PhysicalMediaInfoList::New() const {
  return new PhysicalMediaInfoList;
}

void PhysicalMediaInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhysicalMediaInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.PhysicalMediaInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PhysicalMediaInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.PhysicalMediaInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PhysicalMediaInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.PhysicalMediaInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PhysicalMediaInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.PhysicalMediaInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhysicalMediaInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhysicalMediaInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhysicalMediaInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhysicalMediaInfoList::MergeFrom(const PhysicalMediaInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhysicalMediaInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhysicalMediaInfoList::CopyFrom(const PhysicalMediaInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhysicalMediaInfoList::IsInitialized() const {
  
  return true;
}

void PhysicalMediaInfoList::Swap(PhysicalMediaInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhysicalMediaInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhysicalMediaInfoList_descriptor_;
  metadata.reflection = PhysicalMediaInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int USBControllerInfo::kPackageCodeFieldNumber;
const int USBControllerInfo::kChecktypeFieldNumber;
const int USBControllerInfo::kScanTimeFieldNumber;
const int USBControllerInfo::kAddtimeFieldNumber;
const int USBControllerInfo::kAvailabilityFieldNumber;
const int USBControllerInfo::kProtocolSupportedFieldNumber;
const int USBControllerInfo::kMaxNumberControlledFieldNumber;
const int USBControllerInfo::kDescriptionFieldNumber;
const int USBControllerInfo::kManufacturerFieldNumber;
const int USBControllerInfo::kNameFieldNumber;
const int USBControllerInfo::kPNPDeviceIDFieldNumber;
const int USBControllerInfo::kStatusFieldNumber;
const int USBControllerInfo::kBuyTimeFieldNumber;
const int USBControllerInfo::kBuyPriceFieldNumber;
const int USBControllerInfo::kDCheckTimeFieldNumber;
const int USBControllerInfo::kOtherInfoFieldNumber;
const int USBControllerInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

USBControllerInfo::USBControllerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void USBControllerInfo::InitAsDefaultInstance() {
}

USBControllerInfo::USBControllerInfo(const USBControllerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void USBControllerInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  availability_ = 0;
  protocolsupported_ = 0;
  maxnumbercontrolled_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

USBControllerInfo::~USBControllerInfo() {
  SharedDtor();
}

void USBControllerInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete manufacturer_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void USBControllerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* USBControllerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return USBControllerInfo_descriptor_;
}

const USBControllerInfo& USBControllerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

USBControllerInfo* USBControllerInfo::default_instance_ = NULL;

USBControllerInfo* USBControllerInfo::New() const {
  return new USBControllerInfo;
}

void USBControllerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    availability_ = 0;
    protocolsupported_ = 0;
    maxnumbercontrolled_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
        manufacturer_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool USBControllerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ProtocolSupported;
        break;
      }
      
      // optional int32 ProtocolSupported = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ProtocolSupported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &protocolsupported_)));
          set_has_protocolsupported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_MaxNumberControlled;
        break;
      }
      
      // optional int32 MaxNumberControlled = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MaxNumberControlled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxnumbercontrolled_)));
          set_has_maxnumbercontrolled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_Description;
        break;
      }
      
      // optional string Description = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Manufacturer;
        break;
      }
      
      // optional string Manufacturer = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_Name;
        break;
      }
      
      // optional string Name = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Status;
        break;
      }
      
      // optional string Status = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(121)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(137)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void USBControllerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 Availability = 4;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->availability(), output);
  }
  
  // optional int32 ProtocolSupported = 5;
  if (has_protocolsupported()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->protocolsupported(), output);
  }
  
  // optional int32 MaxNumberControlled = 7;
  if (has_maxnumbercontrolled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->maxnumbercontrolled(), output);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->description(), output);
  }
  
  // optional string Manufacturer = 11;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->manufacturer(), output);
  }
  
  // optional string Name = 12;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->name(), output);
  }
  
  // optional string PNPDeviceID = 13;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->pnpdeviceid(), output);
  }
  
  // optional string Status = 14;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->status(), output);
  }
  
  // optional double BuyTime = 15;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(15, this->buytime(), output);
  }
  
  // optional string BuyPrice = 16;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 17;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 18;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->otherinfo(), output);
  }
  
  // optional string BuyName = 19;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* USBControllerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 Availability = 4;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->availability(), target);
  }
  
  // optional int32 ProtocolSupported = 5;
  if (has_protocolsupported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->protocolsupported(), target);
  }
  
  // optional int32 MaxNumberControlled = 7;
  if (has_maxnumbercontrolled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->maxnumbercontrolled(), target);
  }
  
  // optional string Description = 10;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->description(), target);
  }
  
  // optional string Manufacturer = 11;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->manufacturer(), target);
  }
  
  // optional string Name = 12;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->name(), target);
  }
  
  // optional string PNPDeviceID = 13;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->pnpdeviceid(), target);
  }
  
  // optional string Status = 14;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->status(), target);
  }
  
  // optional double BuyTime = 15;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(15, this->buytime(), target);
  }
  
  // optional string BuyPrice = 16;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 17;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 18;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        18, this->otherinfo(), target);
  }
  
  // optional string BuyName = 19;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        19, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int USBControllerInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 Availability = 4;
    if (has_availability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 ProtocolSupported = 5;
    if (has_protocolsupported()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->protocolsupported());
    }
    
    // optional int32 MaxNumberControlled = 7;
    if (has_maxnumbercontrolled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxnumbercontrolled());
    }
    
    // optional string Description = 10;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string Manufacturer = 11;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }
    
    // optional string Name = 12;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string PNPDeviceID = 13;
    if (has_pnpdeviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string Status = 14;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional double BuyTime = 15;
    if (has_buytime()) {
      total_size += 1 + 8;
    }
    
    // optional string BuyPrice = 16;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 17;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 18;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string BuyName = 19;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void USBControllerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const USBControllerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const USBControllerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void USBControllerInfo::MergeFrom(const USBControllerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_protocolsupported()) {
      set_protocolsupported(from.protocolsupported());
    }
    if (from.has_maxnumbercontrolled()) {
      set_maxnumbercontrolled(from.maxnumbercontrolled());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void USBControllerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void USBControllerInfo::CopyFrom(const USBControllerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool USBControllerInfo::IsInitialized() const {
  
  return true;
}

void USBControllerInfo::Swap(USBControllerInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(availability_, other->availability_);
    std::swap(protocolsupported_, other->protocolsupported_);
    std::swap(maxnumbercontrolled_, other->maxnumbercontrolled_);
    std::swap(description_, other->description_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(status_, other->status_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata USBControllerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = USBControllerInfo_descriptor_;
  metadata.reflection = USBControllerInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int USBControllerInfoList::kListFieldNumber;
const int USBControllerInfoList::kAlarmedFieldNumber;
const int USBControllerInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

USBControllerInfoList::USBControllerInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void USBControllerInfoList::InitAsDefaultInstance() {
}

USBControllerInfoList::USBControllerInfoList(const USBControllerInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void USBControllerInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

USBControllerInfoList::~USBControllerInfoList() {
  SharedDtor();
}

void USBControllerInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void USBControllerInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* USBControllerInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return USBControllerInfoList_descriptor_;
}

const USBControllerInfoList& USBControllerInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

USBControllerInfoList* USBControllerInfoList::default_instance_ = NULL;

USBControllerInfoList* USBControllerInfoList::New() const {
  return new USBControllerInfoList;
}

void USBControllerInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool USBControllerInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.USBControllerInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void USBControllerInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.USBControllerInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* USBControllerInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.USBControllerInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int USBControllerInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.USBControllerInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void USBControllerInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const USBControllerInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const USBControllerInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void USBControllerInfoList::MergeFrom(const USBControllerInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void USBControllerInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void USBControllerInfoList::CopyFrom(const USBControllerInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool USBControllerInfoList::IsInitialized() const {
  
  return true;
}

void USBControllerInfoList::Swap(USBControllerInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata USBControllerInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = USBControllerInfoList_descriptor_;
  metadata.reflection = USBControllerInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VideoDisplayDeviceInfo::kPackageCodeFieldNumber;
const int VideoDisplayDeviceInfo::kChecktypeFieldNumber;
const int VideoDisplayDeviceInfo::kScanTimeFieldNumber;
const int VideoDisplayDeviceInfo::kAddtimeFieldNumber;
const int VideoDisplayDeviceInfo::kDisplayTypeFieldNumber;
const int VideoDisplayDeviceInfo::kPixelsPerXLogicalInchFieldNumber;
const int VideoDisplayDeviceInfo::kPixelsPerYLogicalInchFieldNumber;
const int VideoDisplayDeviceInfo::kScreenHeightFieldNumber;
const int VideoDisplayDeviceInfo::kScreenWidthFieldNumber;
const int VideoDisplayDeviceInfo::kIsLockedFieldNumber;
const int VideoDisplayDeviceInfo::kDescriptionFieldNumber;
const int VideoDisplayDeviceInfo::kMonitorManufacturerFieldNumber;
const int VideoDisplayDeviceInfo::kMonitorTypeFieldNumber;
const int VideoDisplayDeviceInfo::kNameFieldNumber;
const int VideoDisplayDeviceInfo::kPNPDeviceIDFieldNumber;
const int VideoDisplayDeviceInfo::kStatusFieldNumber;
const int VideoDisplayDeviceInfo::kAvailabilityFieldNumber;
const int VideoDisplayDeviceInfo::kBandwidthFieldNumber;
const int VideoDisplayDeviceInfo::kBuyTimeFieldNumber;
const int VideoDisplayDeviceInfo::kBuyPriceFieldNumber;
const int VideoDisplayDeviceInfo::kDCheckTimeFieldNumber;
const int VideoDisplayDeviceInfo::kOtherInfoFieldNumber;
const int VideoDisplayDeviceInfo::kBuyNameFieldNumber;
#endif  // !_MSC_VER

VideoDisplayDeviceInfo::VideoDisplayDeviceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VideoDisplayDeviceInfo::InitAsDefaultInstance() {
}

VideoDisplayDeviceInfo::VideoDisplayDeviceInfo(const VideoDisplayDeviceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VideoDisplayDeviceInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  displaytype_ = 0;
  pixelsperxlogicalinch_ = 0;
  pixelsperylogicalinch_ = 0;
  screenheight_ = 0;
  screenwidth_ = 0;
  islocked_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  monitormanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  monitortype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  availability_ = 0;
  bandwidth_ = 0;
  buytime_ = 0;
  buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dchecktime_ = 0;
  otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VideoDisplayDeviceInfo::~VideoDisplayDeviceInfo() {
  SharedDtor();
}

void VideoDisplayDeviceInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (monitormanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    delete monitormanufacturer_;
  }
  if (monitortype_ != &::google::protobuf::internal::kEmptyString) {
    delete monitortype_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete pnpdeviceid_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    delete buyprice_;
  }
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete otherinfo_;
  }
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    delete buyname_;
  }
  if (this != default_instance_) {
  }
}

void VideoDisplayDeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VideoDisplayDeviceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VideoDisplayDeviceInfo_descriptor_;
}

const VideoDisplayDeviceInfo& VideoDisplayDeviceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

VideoDisplayDeviceInfo* VideoDisplayDeviceInfo::default_instance_ = NULL;

VideoDisplayDeviceInfo* VideoDisplayDeviceInfo::New() const {
  return new VideoDisplayDeviceInfo;
}

void VideoDisplayDeviceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    displaytype_ = 0;
    pixelsperxlogicalinch_ = 0;
    pixelsperylogicalinch_ = 0;
    screenheight_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    screenwidth_ = 0;
    islocked_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_monitormanufacturer()) {
      if (monitormanufacturer_ != &::google::protobuf::internal::kEmptyString) {
        monitormanufacturer_->clear();
      }
    }
    if (has_monitortype()) {
      if (monitortype_ != &::google::protobuf::internal::kEmptyString) {
        monitortype_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_pnpdeviceid()) {
      if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
        pnpdeviceid_->clear();
      }
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    availability_ = 0;
    bandwidth_ = 0;
    buytime_ = 0;
    if (has_buyprice()) {
      if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
        buyprice_->clear();
      }
    }
    dchecktime_ = 0;
    if (has_otherinfo()) {
      if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
        otherinfo_->clear();
      }
    }
    if (has_buyname()) {
      if (buyname_ != &::google::protobuf::internal::kEmptyString) {
        buyname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VideoDisplayDeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_DisplayType;
        break;
      }
      
      // optional int32 DisplayType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DisplayType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &displaytype_)));
          set_has_displaytype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_PixelsPerXLogicalInch;
        break;
      }
      
      // optional int32 PixelsPerXLogicalInch = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PixelsPerXLogicalInch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pixelsperxlogicalinch_)));
          set_has_pixelsperxlogicalinch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_PixelsPerYLogicalInch;
        break;
      }
      
      // optional int32 PixelsPerYLogicalInch = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PixelsPerYLogicalInch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pixelsperylogicalinch_)));
          set_has_pixelsperylogicalinch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_ScreenHeight;
        break;
      }
      
      // optional int32 ScreenHeight = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ScreenHeight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &screenheight_)));
          set_has_screenheight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_ScreenWidth;
        break;
      }
      
      // optional int32 ScreenWidth = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ScreenWidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &screenwidth_)));
          set_has_screenwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_IsLocked;
        break;
      }
      
      // optional int32 IsLocked = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_IsLocked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &islocked_)));
          set_has_islocked();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_Description;
        break;
      }
      
      // optional string Description = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_MonitorManufacturer;
        break;
      }
      
      // optional string MonitorManufacturer = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MonitorManufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_monitormanufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->monitormanufacturer().data(), this->monitormanufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_MonitorType;
        break;
      }
      
      // optional string MonitorType = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MonitorType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_monitortype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->monitortype().data(), this->monitortype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_Name;
        break;
      }
      
      // optional string Name = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_PNPDeviceID;
        break;
      }
      
      // optional string PNPDeviceID = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PNPDeviceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pnpdeviceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pnpdeviceid().data(), this->pnpdeviceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_Status;
        break;
      }
      
      // optional string Status = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_Availability;
        break;
      }
      
      // optional int32 Availability = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Availability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &availability_)));
          set_has_availability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_Bandwidth;
        break;
      }
      
      // optional int32 Bandwidth = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Bandwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bandwidth_)));
          set_has_bandwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(153)) goto parse_BuyTime;
        break;
      }
      
      // optional double BuyTime = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_BuyTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &buytime_)));
          set_has_buytime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_BuyPrice;
        break;
      }
      
      // optional string BuyPrice = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyPrice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyprice()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyprice().data(), this->buyprice().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(169)) goto parse_DCheckTime;
        break;
      }
      
      // optional double DCheckTime = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_DCheckTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &dchecktime_)));
          set_has_dchecktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_OtherInfo;
        break;
      }
      
      // optional string OtherInfo = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OtherInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_otherinfo()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->otherinfo().data(), this->otherinfo().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_BuyName;
        break;
      }
      
      // optional string BuyName = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buyname().data(), this->buyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VideoDisplayDeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional int32 DisplayType = 4;
  if (has_displaytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->displaytype(), output);
  }
  
  // optional int32 PixelsPerXLogicalInch = 5;
  if (has_pixelsperxlogicalinch()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->pixelsperxlogicalinch(), output);
  }
  
  // optional int32 PixelsPerYLogicalInch = 6;
  if (has_pixelsperylogicalinch()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->pixelsperylogicalinch(), output);
  }
  
  // optional int32 ScreenHeight = 7;
  if (has_screenheight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->screenheight(), output);
  }
  
  // optional int32 ScreenWidth = 8;
  if (has_screenwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->screenwidth(), output);
  }
  
  // optional int32 IsLocked = 10;
  if (has_islocked()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->islocked(), output);
  }
  
  // optional string Description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->description(), output);
  }
  
  // optional string MonitorManufacturer = 12;
  if (has_monitormanufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->monitormanufacturer().data(), this->monitormanufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->monitormanufacturer(), output);
  }
  
  // optional string MonitorType = 13;
  if (has_monitortype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->monitortype().data(), this->monitortype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->monitortype(), output);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->name(), output);
  }
  
  // optional string PNPDeviceID = 15;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->pnpdeviceid(), output);
  }
  
  // optional string Status = 16;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->status(), output);
  }
  
  // optional int32 Availability = 17;
  if (has_availability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->availability(), output);
  }
  
  // optional int32 Bandwidth = 18;
  if (has_bandwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(18, this->bandwidth(), output);
  }
  
  // optional double BuyTime = 19;
  if (has_buytime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->buytime(), output);
  }
  
  // optional string BuyPrice = 20;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->buyprice(), output);
  }
  
  // optional double DCheckTime = 21;
  if (has_dchecktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->dchecktime(), output);
  }
  
  // optional string OtherInfo = 22;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->otherinfo(), output);
  }
  
  // optional string BuyName = 23;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      23, this->buyname(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VideoDisplayDeviceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional int32 DisplayType = 4;
  if (has_displaytype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->displaytype(), target);
  }
  
  // optional int32 PixelsPerXLogicalInch = 5;
  if (has_pixelsperxlogicalinch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->pixelsperxlogicalinch(), target);
  }
  
  // optional int32 PixelsPerYLogicalInch = 6;
  if (has_pixelsperylogicalinch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->pixelsperylogicalinch(), target);
  }
  
  // optional int32 ScreenHeight = 7;
  if (has_screenheight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->screenheight(), target);
  }
  
  // optional int32 ScreenWidth = 8;
  if (has_screenwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->screenwidth(), target);
  }
  
  // optional int32 IsLocked = 10;
  if (has_islocked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->islocked(), target);
  }
  
  // optional string Description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->description(), target);
  }
  
  // optional string MonitorManufacturer = 12;
  if (has_monitormanufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->monitormanufacturer().data(), this->monitormanufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->monitormanufacturer(), target);
  }
  
  // optional string MonitorType = 13;
  if (has_monitortype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->monitortype().data(), this->monitortype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->monitortype(), target);
  }
  
  // optional string Name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->name(), target);
  }
  
  // optional string PNPDeviceID = 15;
  if (has_pnpdeviceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pnpdeviceid().data(), this->pnpdeviceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->pnpdeviceid(), target);
  }
  
  // optional string Status = 16;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->status(), target);
  }
  
  // optional int32 Availability = 17;
  if (has_availability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->availability(), target);
  }
  
  // optional int32 Bandwidth = 18;
  if (has_bandwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(18, this->bandwidth(), target);
  }
  
  // optional double BuyTime = 19;
  if (has_buytime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->buytime(), target);
  }
  
  // optional string BuyPrice = 20;
  if (has_buyprice()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyprice().data(), this->buyprice().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->buyprice(), target);
  }
  
  // optional double DCheckTime = 21;
  if (has_dchecktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(21, this->dchecktime(), target);
  }
  
  // optional string OtherInfo = 22;
  if (has_otherinfo()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->otherinfo().data(), this->otherinfo().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->otherinfo(), target);
  }
  
  // optional string BuyName = 23;
  if (has_buyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buyname().data(), this->buyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        23, this->buyname(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VideoDisplayDeviceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional int32 DisplayType = 4;
    if (has_displaytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->displaytype());
    }
    
    // optional int32 PixelsPerXLogicalInch = 5;
    if (has_pixelsperxlogicalinch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pixelsperxlogicalinch());
    }
    
    // optional int32 PixelsPerYLogicalInch = 6;
    if (has_pixelsperylogicalinch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pixelsperylogicalinch());
    }
    
    // optional int32 ScreenHeight = 7;
    if (has_screenheight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->screenheight());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 ScreenWidth = 8;
    if (has_screenwidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->screenwidth());
    }
    
    // optional int32 IsLocked = 10;
    if (has_islocked()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->islocked());
    }
    
    // optional string Description = 11;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional string MonitorManufacturer = 12;
    if (has_monitormanufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->monitormanufacturer());
    }
    
    // optional string MonitorType = 13;
    if (has_monitortype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->monitortype());
    }
    
    // optional string Name = 14;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string PNPDeviceID = 15;
    if (has_pnpdeviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pnpdeviceid());
    }
    
    // optional string Status = 16;
    if (has_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional int32 Availability = 17;
    if (has_availability()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->availability());
    }
    
    // optional int32 Bandwidth = 18;
    if (has_bandwidth()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bandwidth());
    }
    
    // optional double BuyTime = 19;
    if (has_buytime()) {
      total_size += 2 + 8;
    }
    
    // optional string BuyPrice = 20;
    if (has_buyprice()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyprice());
    }
    
    // optional double DCheckTime = 21;
    if (has_dchecktime()) {
      total_size += 2 + 8;
    }
    
    // optional string OtherInfo = 22;
    if (has_otherinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->otherinfo());
    }
    
    // optional string BuyName = 23;
    if (has_buyname()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buyname());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoDisplayDeviceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VideoDisplayDeviceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VideoDisplayDeviceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VideoDisplayDeviceInfo::MergeFrom(const VideoDisplayDeviceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_displaytype()) {
      set_displaytype(from.displaytype());
    }
    if (from.has_pixelsperxlogicalinch()) {
      set_pixelsperxlogicalinch(from.pixelsperxlogicalinch());
    }
    if (from.has_pixelsperylogicalinch()) {
      set_pixelsperylogicalinch(from.pixelsperylogicalinch());
    }
    if (from.has_screenheight()) {
      set_screenheight(from.screenheight());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_screenwidth()) {
      set_screenwidth(from.screenwidth());
    }
    if (from.has_islocked()) {
      set_islocked(from.islocked());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_monitormanufacturer()) {
      set_monitormanufacturer(from.monitormanufacturer());
    }
    if (from.has_monitortype()) {
      set_monitortype(from.monitortype());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_pnpdeviceid()) {
      set_pnpdeviceid(from.pnpdeviceid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_availability()) {
      set_availability(from.availability());
    }
    if (from.has_bandwidth()) {
      set_bandwidth(from.bandwidth());
    }
    if (from.has_buytime()) {
      set_buytime(from.buytime());
    }
    if (from.has_buyprice()) {
      set_buyprice(from.buyprice());
    }
    if (from.has_dchecktime()) {
      set_dchecktime(from.dchecktime());
    }
    if (from.has_otherinfo()) {
      set_otherinfo(from.otherinfo());
    }
    if (from.has_buyname()) {
      set_buyname(from.buyname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VideoDisplayDeviceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VideoDisplayDeviceInfo::CopyFrom(const VideoDisplayDeviceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoDisplayDeviceInfo::IsInitialized() const {
  
  return true;
}

void VideoDisplayDeviceInfo::Swap(VideoDisplayDeviceInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(displaytype_, other->displaytype_);
    std::swap(pixelsperxlogicalinch_, other->pixelsperxlogicalinch_);
    std::swap(pixelsperylogicalinch_, other->pixelsperylogicalinch_);
    std::swap(screenheight_, other->screenheight_);
    std::swap(screenwidth_, other->screenwidth_);
    std::swap(islocked_, other->islocked_);
    std::swap(description_, other->description_);
    std::swap(monitormanufacturer_, other->monitormanufacturer_);
    std::swap(monitortype_, other->monitortype_);
    std::swap(name_, other->name_);
    std::swap(pnpdeviceid_, other->pnpdeviceid_);
    std::swap(status_, other->status_);
    std::swap(availability_, other->availability_);
    std::swap(bandwidth_, other->bandwidth_);
    std::swap(buytime_, other->buytime_);
    std::swap(buyprice_, other->buyprice_);
    std::swap(dchecktime_, other->dchecktime_);
    std::swap(otherinfo_, other->otherinfo_);
    std::swap(buyname_, other->buyname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VideoDisplayDeviceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VideoDisplayDeviceInfo_descriptor_;
  metadata.reflection = VideoDisplayDeviceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VideoDisplayDeviceInfoList::kListFieldNumber;
const int VideoDisplayDeviceInfoList::kAlarmedFieldNumber;
const int VideoDisplayDeviceInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

VideoDisplayDeviceInfoList::VideoDisplayDeviceInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VideoDisplayDeviceInfoList::InitAsDefaultInstance() {
}

VideoDisplayDeviceInfoList::VideoDisplayDeviceInfoList(const VideoDisplayDeviceInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VideoDisplayDeviceInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VideoDisplayDeviceInfoList::~VideoDisplayDeviceInfoList() {
  SharedDtor();
}

void VideoDisplayDeviceInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void VideoDisplayDeviceInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VideoDisplayDeviceInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VideoDisplayDeviceInfoList_descriptor_;
}

const VideoDisplayDeviceInfoList& VideoDisplayDeviceInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

VideoDisplayDeviceInfoList* VideoDisplayDeviceInfoList::default_instance_ = NULL;

VideoDisplayDeviceInfoList* VideoDisplayDeviceInfoList::New() const {
  return new VideoDisplayDeviceInfoList;
}

void VideoDisplayDeviceInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VideoDisplayDeviceInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.VideoDisplayDeviceInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VideoDisplayDeviceInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.VideoDisplayDeviceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VideoDisplayDeviceInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.VideoDisplayDeviceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VideoDisplayDeviceInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.VideoDisplayDeviceInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoDisplayDeviceInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VideoDisplayDeviceInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VideoDisplayDeviceInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VideoDisplayDeviceInfoList::MergeFrom(const VideoDisplayDeviceInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VideoDisplayDeviceInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VideoDisplayDeviceInfoList::CopyFrom(const VideoDisplayDeviceInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoDisplayDeviceInfoList::IsInitialized() const {
  
  return true;
}

void VideoDisplayDeviceInfoList::Swap(VideoDisplayDeviceInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VideoDisplayDeviceInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VideoDisplayDeviceInfoList_descriptor_;
  metadata.reflection = VideoDisplayDeviceInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltServiceInfo::kServiceNameFieldNumber;
const int CltServiceInfo::kDispalyNameFieldNumber;
const int CltServiceInfo::kBinaryPathFieldNumber;
const int CltServiceInfo::kDiscriptionFieldNumber;
const int CltServiceInfo::kServiceTypeFieldNumber;
const int CltServiceInfo::kStateFieldNumber;
const int CltServiceInfo::kStartTypeFieldNumber;
const int CltServiceInfo::kControlsAcceptedFieldNumber;
const int CltServiceInfo::kErrorControlFieldNumber;
#endif  // !_MSC_VER

CltServiceInfo::CltServiceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltServiceInfo::InitAsDefaultInstance() {
}

CltServiceInfo::CltServiceInfo(const CltServiceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltServiceInfo::SharedCtor() {
  _cached_size_ = 0;
  service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  dispaly_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  binary_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  service_type_ = 0u;
  state_ = 0u;
  start_type_ = 0u;
  controls_accepted_ = 0u;
  error_control_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltServiceInfo::~CltServiceInfo() {
  SharedDtor();
}

void CltServiceInfo::SharedDtor() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    delete service_name_;
  }
  if (dispaly_name_ != &::google::protobuf::internal::kEmptyString) {
    delete dispaly_name_;
  }
  if (binary_path_ != &::google::protobuf::internal::kEmptyString) {
    delete binary_path_;
  }
  if (discription_ != &::google::protobuf::internal::kEmptyString) {
    delete discription_;
  }
  if (this != default_instance_) {
  }
}

void CltServiceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltServiceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltServiceInfo_descriptor_;
}

const CltServiceInfo& CltServiceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltServiceInfo* CltServiceInfo::default_instance_ = NULL;

CltServiceInfo* CltServiceInfo::New() const {
  return new CltServiceInfo;
}

void CltServiceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_service_name()) {
      if (service_name_ != &::google::protobuf::internal::kEmptyString) {
        service_name_->clear();
      }
    }
    if (has_dispaly_name()) {
      if (dispaly_name_ != &::google::protobuf::internal::kEmptyString) {
        dispaly_name_->clear();
      }
    }
    if (has_binary_path()) {
      if (binary_path_ != &::google::protobuf::internal::kEmptyString) {
        binary_path_->clear();
      }
    }
    if (has_discription()) {
      if (discription_ != &::google::protobuf::internal::kEmptyString) {
        discription_->clear();
      }
    }
    service_type_ = 0u;
    state_ = 0u;
    start_type_ = 0u;
    controls_accepted_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    error_control_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltServiceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->service_name().data(), this->service_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dispaly_name;
        break;
      }
      
      // optional string dispaly_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dispaly_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dispaly_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dispaly_name().data(), this->dispaly_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_binary_Path;
        break;
      }
      
      // optional string binary_Path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_binary_Path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_binary_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->binary_path().data(), this->binary_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_discription;
        break;
      }
      
      // optional string discription = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_discription:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_discription()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->discription().data(), this->discription().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_service_type;
        break;
      }
      
      // optional uint32 service_type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_service_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &service_type_)));
          set_has_service_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }
      
      // optional uint32 state = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_start_type;
        break;
      }
      
      // optional uint32 start_type = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_start_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &start_type_)));
          set_has_start_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_controls_accepted;
        break;
      }
      
      // optional uint32 controls_accepted = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_controls_accepted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &controls_accepted_)));
          set_has_controls_accepted();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_error_control;
        break;
      }
      
      // optional uint32 error_control = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_control:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_control_)));
          set_has_error_control();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltServiceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string service_name = 1;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->service_name().data(), this->service_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->service_name(), output);
  }
  
  // optional string dispaly_name = 2;
  if (has_dispaly_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dispaly_name().data(), this->dispaly_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->dispaly_name(), output);
  }
  
  // optional string binary_Path = 3;
  if (has_binary_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->binary_path().data(), this->binary_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->binary_path(), output);
  }
  
  // optional string discription = 4;
  if (has_discription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->discription().data(), this->discription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->discription(), output);
  }
  
  // optional uint32 service_type = 5;
  if (has_service_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->service_type(), output);
  }
  
  // optional uint32 state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->state(), output);
  }
  
  // optional uint32 start_type = 7;
  if (has_start_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->start_type(), output);
  }
  
  // optional uint32 controls_accepted = 8;
  if (has_controls_accepted()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->controls_accepted(), output);
  }
  
  // optional uint32 error_control = 9;
  if (has_error_control()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->error_control(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltServiceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string service_name = 1;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->service_name().data(), this->service_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_name(), target);
  }
  
  // optional string dispaly_name = 2;
  if (has_dispaly_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dispaly_name().data(), this->dispaly_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->dispaly_name(), target);
  }
  
  // optional string binary_Path = 3;
  if (has_binary_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->binary_path().data(), this->binary_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->binary_path(), target);
  }
  
  // optional string discription = 4;
  if (has_discription()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->discription().data(), this->discription().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->discription(), target);
  }
  
  // optional uint32 service_type = 5;
  if (has_service_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->service_type(), target);
  }
  
  // optional uint32 state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->state(), target);
  }
  
  // optional uint32 start_type = 7;
  if (has_start_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->start_type(), target);
  }
  
  // optional uint32 controls_accepted = 8;
  if (has_controls_accepted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->controls_accepted(), target);
  }
  
  // optional uint32 error_control = 9;
  if (has_error_control()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->error_control(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltServiceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_name = 1;
    if (has_service_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_name());
    }
    
    // optional string dispaly_name = 2;
    if (has_dispaly_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dispaly_name());
    }
    
    // optional string binary_Path = 3;
    if (has_binary_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->binary_path());
    }
    
    // optional string discription = 4;
    if (has_discription()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->discription());
    }
    
    // optional uint32 service_type = 5;
    if (has_service_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->service_type());
    }
    
    // optional uint32 state = 6;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }
    
    // optional uint32 start_type = 7;
    if (has_start_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->start_type());
    }
    
    // optional uint32 controls_accepted = 8;
    if (has_controls_accepted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->controls_accepted());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 error_control = 9;
    if (has_error_control()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->error_control());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltServiceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltServiceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltServiceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltServiceInfo::MergeFrom(const CltServiceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_name()) {
      set_service_name(from.service_name());
    }
    if (from.has_dispaly_name()) {
      set_dispaly_name(from.dispaly_name());
    }
    if (from.has_binary_path()) {
      set_binary_path(from.binary_path());
    }
    if (from.has_discription()) {
      set_discription(from.discription());
    }
    if (from.has_service_type()) {
      set_service_type(from.service_type());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_start_type()) {
      set_start_type(from.start_type());
    }
    if (from.has_controls_accepted()) {
      set_controls_accepted(from.controls_accepted());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_error_control()) {
      set_error_control(from.error_control());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltServiceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltServiceInfo::CopyFrom(const CltServiceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltServiceInfo::IsInitialized() const {
  
  return true;
}

void CltServiceInfo::Swap(CltServiceInfo* other) {
  if (other != this) {
    std::swap(service_name_, other->service_name_);
    std::swap(dispaly_name_, other->dispaly_name_);
    std::swap(binary_path_, other->binary_path_);
    std::swap(discription_, other->discription_);
    std::swap(service_type_, other->service_type_);
    std::swap(state_, other->state_);
    std::swap(start_type_, other->start_type_);
    std::swap(controls_accepted_, other->controls_accepted_);
    std::swap(error_control_, other->error_control_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltServiceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltServiceInfo_descriptor_;
  metadata.reflection = CltServiceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltServiceList::kListFieldNumber;
#endif  // !_MSC_VER

CltServiceList::CltServiceList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltServiceList::InitAsDefaultInstance() {
}

CltServiceList::CltServiceList(const CltServiceList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltServiceList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltServiceList::~CltServiceList() {
  SharedDtor();
}

void CltServiceList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltServiceList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltServiceList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltServiceList_descriptor_;
}

const CltServiceList& CltServiceList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltServiceList* CltServiceList::default_instance_ = NULL;

CltServiceList* CltServiceList::New() const {
  return new CltServiceList;
}

void CltServiceList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltServiceList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltServiceInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltServiceList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltServiceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltServiceList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltServiceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltServiceList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltServiceInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltServiceList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltServiceList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltServiceList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltServiceList::MergeFrom(const CltServiceList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltServiceList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltServiceList::CopyFrom(const CltServiceList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltServiceList::IsInitialized() const {
  
  return true;
}

void CltServiceList::Swap(CltServiceList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltServiceList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltServiceList_descriptor_;
  metadata.reflection = CltServiceList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltProcessInfo::kProcessIdFieldNumber;
const int CltProcessInfo::kSessionIdFieldNumber;
const int CltProcessInfo::kProcessPathFieldNumber;
const int CltProcessInfo::kWinUserFieldNumber;
const int CltProcessInfo::kThreadNumFieldNumber;
const int CltProcessInfo::kPriorityFieldNumber;
const int CltProcessInfo::kUpRateFieldNumber;
const int CltProcessInfo::kDownRateFieldNumber;
const int CltProcessInfo::kUpCountFieldNumber;
const int CltProcessInfo::kDownCountFieldNumber;
const int CltProcessInfo::kContCountFieldNumber;
#endif  // !_MSC_VER

CltProcessInfo::CltProcessInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltProcessInfo::InitAsDefaultInstance() {
}

CltProcessInfo::CltProcessInfo(const CltProcessInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltProcessInfo::SharedCtor() {
  _cached_size_ = 0;
  process_id_ = 0;
  session_id_ = 0;
  process_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  win_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  thread_num_ = 0;
  priority_ = 0;
  uprate_ = 0;
  downrate_ = 0;
  upcount_ = 0;
  downcount_ = 0;
  contcount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltProcessInfo::~CltProcessInfo() {
  SharedDtor();
}

void CltProcessInfo::SharedDtor() {
  if (process_path_ != &::google::protobuf::internal::kEmptyString) {
    delete process_path_;
  }
  if (win_user_ != &::google::protobuf::internal::kEmptyString) {
    delete win_user_;
  }
  if (this != default_instance_) {
  }
}

void CltProcessInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltProcessInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltProcessInfo_descriptor_;
}

const CltProcessInfo& CltProcessInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltProcessInfo* CltProcessInfo::default_instance_ = NULL;

CltProcessInfo* CltProcessInfo::New() const {
  return new CltProcessInfo;
}

void CltProcessInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    process_id_ = 0;
    session_id_ = 0;
    if (has_process_path()) {
      if (process_path_ != &::google::protobuf::internal::kEmptyString) {
        process_path_->clear();
      }
    }
    if (has_win_user()) {
      if (win_user_ != &::google::protobuf::internal::kEmptyString) {
        win_user_->clear();
      }
    }
    thread_num_ = 0;
    priority_ = 0;
    uprate_ = 0;
    downrate_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    upcount_ = 0;
    downcount_ = 0;
    contcount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltProcessInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 process_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &process_id_)));
          set_has_process_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_session_id;
        break;
      }
      
      // optional int32 session_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_process_path;
        break;
      }
      
      // optional string process_path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_process_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_process_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->process_path().data(), this->process_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_win_user;
        break;
      }
      
      // optional string win_user = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_win_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_win_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->win_user().data(), this->win_user().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_thread_num;
        break;
      }
      
      // optional int32 thread_num = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_thread_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &thread_num_)));
          set_has_thread_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_priority;
        break;
      }
      
      // optional int32 priority = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_priority:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &priority_)));
          set_has_priority();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_upRate;
        break;
      }
      
      // optional int32 upRate = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_upRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uprate_)));
          set_has_uprate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_downRate;
        break;
      }
      
      // optional int32 downRate = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_downRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &downrate_)));
          set_has_downrate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_upCount;
        break;
      }
      
      // optional int32 upCount = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_upCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &upcount_)));
          set_has_upcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_downCount;
        break;
      }
      
      // optional int32 downCount = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_downCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &downcount_)));
          set_has_downcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_contCount;
        break;
      }
      
      // optional int32 contCount = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contcount_)));
          set_has_contcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltProcessInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 process_id = 1;
  if (has_process_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->process_id(), output);
  }
  
  // optional int32 session_id = 2;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->session_id(), output);
  }
  
  // optional string process_path = 3;
  if (has_process_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->process_path().data(), this->process_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->process_path(), output);
  }
  
  // optional string win_user = 4;
  if (has_win_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->win_user().data(), this->win_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->win_user(), output);
  }
  
  // optional int32 thread_num = 5;
  if (has_thread_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->thread_num(), output);
  }
  
  // optional int32 priority = 6;
  if (has_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->priority(), output);
  }
  
  // optional int32 upRate = 7;
  if (has_uprate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->uprate(), output);
  }
  
  // optional int32 downRate = 8;
  if (has_downrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->downrate(), output);
  }
  
  // optional int32 upCount = 9;
  if (has_upcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->upcount(), output);
  }
  
  // optional int32 downCount = 10;
  if (has_downcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->downcount(), output);
  }
  
  // optional int32 contCount = 11;
  if (has_contcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->contcount(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltProcessInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 process_id = 1;
  if (has_process_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->process_id(), target);
  }
  
  // optional int32 session_id = 2;
  if (has_session_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->session_id(), target);
  }
  
  // optional string process_path = 3;
  if (has_process_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->process_path().data(), this->process_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->process_path(), target);
  }
  
  // optional string win_user = 4;
  if (has_win_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->win_user().data(), this->win_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->win_user(), target);
  }
  
  // optional int32 thread_num = 5;
  if (has_thread_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->thread_num(), target);
  }
  
  // optional int32 priority = 6;
  if (has_priority()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->priority(), target);
  }
  
  // optional int32 upRate = 7;
  if (has_uprate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->uprate(), target);
  }
  
  // optional int32 downRate = 8;
  if (has_downrate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->downrate(), target);
  }
  
  // optional int32 upCount = 9;
  if (has_upcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->upcount(), target);
  }
  
  // optional int32 downCount = 10;
  if (has_downcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->downcount(), target);
  }
  
  // optional int32 contCount = 11;
  if (has_contcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->contcount(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltProcessInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 process_id = 1;
    if (has_process_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->process_id());
    }
    
    // optional int32 session_id = 2;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->session_id());
    }
    
    // optional string process_path = 3;
    if (has_process_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->process_path());
    }
    
    // optional string win_user = 4;
    if (has_win_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->win_user());
    }
    
    // optional int32 thread_num = 5;
    if (has_thread_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->thread_num());
    }
    
    // optional int32 priority = 6;
    if (has_priority()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->priority());
    }
    
    // optional int32 upRate = 7;
    if (has_uprate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uprate());
    }
    
    // optional int32 downRate = 8;
    if (has_downrate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->downrate());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 upCount = 9;
    if (has_upcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->upcount());
    }
    
    // optional int32 downCount = 10;
    if (has_downcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->downcount());
    }
    
    // optional int32 contCount = 11;
    if (has_contcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contcount());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltProcessInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltProcessInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltProcessInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltProcessInfo::MergeFrom(const CltProcessInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_process_id()) {
      set_process_id(from.process_id());
    }
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_process_path()) {
      set_process_path(from.process_path());
    }
    if (from.has_win_user()) {
      set_win_user(from.win_user());
    }
    if (from.has_thread_num()) {
      set_thread_num(from.thread_num());
    }
    if (from.has_priority()) {
      set_priority(from.priority());
    }
    if (from.has_uprate()) {
      set_uprate(from.uprate());
    }
    if (from.has_downrate()) {
      set_downrate(from.downrate());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_upcount()) {
      set_upcount(from.upcount());
    }
    if (from.has_downcount()) {
      set_downcount(from.downcount());
    }
    if (from.has_contcount()) {
      set_contcount(from.contcount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltProcessInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltProcessInfo::CopyFrom(const CltProcessInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltProcessInfo::IsInitialized() const {
  
  return true;
}

void CltProcessInfo::Swap(CltProcessInfo* other) {
  if (other != this) {
    std::swap(process_id_, other->process_id_);
    std::swap(session_id_, other->session_id_);
    std::swap(process_path_, other->process_path_);
    std::swap(win_user_, other->win_user_);
    std::swap(thread_num_, other->thread_num_);
    std::swap(priority_, other->priority_);
    std::swap(uprate_, other->uprate_);
    std::swap(downrate_, other->downrate_);
    std::swap(upcount_, other->upcount_);
    std::swap(downcount_, other->downcount_);
    std::swap(contcount_, other->contcount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltProcessInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltProcessInfo_descriptor_;
  metadata.reflection = CltProcessInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltProcessList::kListFieldNumber;
#endif  // !_MSC_VER

CltProcessList::CltProcessList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltProcessList::InitAsDefaultInstance() {
}

CltProcessList::CltProcessList(const CltProcessList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltProcessList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltProcessList::~CltProcessList() {
  SharedDtor();
}

void CltProcessList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltProcessList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltProcessList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltProcessList_descriptor_;
}

const CltProcessList& CltProcessList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltProcessList* CltProcessList::default_instance_ = NULL;

CltProcessList* CltProcessList::New() const {
  return new CltProcessList;
}

void CltProcessList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltProcessList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltProcessInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltProcessList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltProcessInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltProcessList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltProcessInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltProcessList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltProcessInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltProcessList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltProcessList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltProcessList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltProcessList::MergeFrom(const CltProcessList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltProcessList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltProcessList::CopyFrom(const CltProcessList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltProcessList::IsInitialized() const {
  
  return true;
}

void CltProcessList::Swap(CltProcessList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltProcessList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltProcessList_descriptor_;
  metadata.reflection = CltProcessList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltUser::kNameFieldNumber;
const int CltUser::kDescFieldNumber;
const int CltUser::kFullNameFieldNumber;
const int CltUser::kProfileFieldNumber;
const int CltUser::kGroupFieldNumber;
const int CltUser::kLockFieldNumber;
const int CltUser::kDisableFieldNumber;
const int CltUser::kUserpswFieldNumber;
#endif  // !_MSC_VER

CltUser::CltUser()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltUser::InitAsDefaultInstance() {
}

CltUser::CltUser(const CltUser& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltUser::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  full_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lock_ = 0;
  disable_ = 0;
  userpsw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltUser::~CltUser() {
  SharedDtor();
}

void CltUser::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (full_name_ != &::google::protobuf::internal::kEmptyString) {
    delete full_name_;
  }
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    delete profile_;
  }
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (userpsw_ != &::google::protobuf::internal::kEmptyString) {
    delete userpsw_;
  }
  if (this != default_instance_) {
  }
}

void CltUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltUser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltUser_descriptor_;
}

const CltUser& CltUser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltUser* CltUser::default_instance_ = NULL;

CltUser* CltUser::New() const {
  return new CltUser;
}

void CltUser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
    if (has_full_name()) {
      if (full_name_ != &::google::protobuf::internal::kEmptyString) {
        full_name_->clear();
      }
    }
    if (has_profile()) {
      if (profile_ != &::google::protobuf::internal::kEmptyString) {
        profile_->clear();
      }
    }
    if (has_group()) {
      if (group_ != &::google::protobuf::internal::kEmptyString) {
        group_->clear();
      }
    }
    lock_ = 0;
    disable_ = 0;
    if (has_userpsw()) {
      if (userpsw_ != &::google::protobuf::internal::kEmptyString) {
        userpsw_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_full_name;
        break;
      }
      
      // optional string full_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_full_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_full_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->full_name().data(), this->full_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_profile;
        break;
      }
      
      // optional string profile = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_profile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_profile()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->profile().data(), this->profile().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_group;
        break;
      }
      
      // optional string group = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->group().data(), this->group().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_lock;
        break;
      }
      
      // optional int32 lock = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lock_)));
          set_has_lock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_disable;
        break;
      }
      
      // optional int32 disable = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &disable_)));
          set_has_disable();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_userpsw;
        break;
      }
      
      // optional string userpsw = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userpsw:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_userpsw()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->userpsw().data(), this->userpsw().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
  // optional string full_name = 3;
  if (has_full_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->full_name().data(), this->full_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->full_name(), output);
  }
  
  // optional string profile = 4;
  if (has_profile()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->profile().data(), this->profile().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->profile(), output);
  }
  
  // optional string group = 5;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->group(), output);
  }
  
  // optional int32 lock = 6;
  if (has_lock()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->lock(), output);
  }
  
  // optional int32 disable = 7;
  if (has_disable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->disable(), output);
  }
  
  // optional string userpsw = 8;
  if (has_userpsw()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->userpsw().data(), this->userpsw().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->userpsw(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltUser::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->desc(), target);
  }
  
  // optional string full_name = 3;
  if (has_full_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->full_name().data(), this->full_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->full_name(), target);
  }
  
  // optional string profile = 4;
  if (has_profile()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->profile().data(), this->profile().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->profile(), target);
  }
  
  // optional string group = 5;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->group(), target);
  }
  
  // optional int32 lock = 6;
  if (has_lock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->lock(), target);
  }
  
  // optional int32 disable = 7;
  if (has_disable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->disable(), target);
  }
  
  // optional string userpsw = 8;
  if (has_userpsw()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->userpsw().data(), this->userpsw().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->userpsw(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltUser::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
    // optional string full_name = 3;
    if (has_full_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->full_name());
    }
    
    // optional string profile = 4;
    if (has_profile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->profile());
    }
    
    // optional string group = 5;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group());
    }
    
    // optional int32 lock = 6;
    if (has_lock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lock());
    }
    
    // optional int32 disable = 7;
    if (has_disable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->disable());
    }
    
    // optional string userpsw = 8;
    if (has_userpsw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->userpsw());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltUser::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltUser* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltUser*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltUser::MergeFrom(const CltUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_full_name()) {
      set_full_name(from.full_name());
    }
    if (from.has_profile()) {
      set_profile(from.profile());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_lock()) {
      set_lock(from.lock());
    }
    if (from.has_disable()) {
      set_disable(from.disable());
    }
    if (from.has_userpsw()) {
      set_userpsw(from.userpsw());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltUser::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltUser::CopyFrom(const CltUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltUser::IsInitialized() const {
  
  return true;
}

void CltUser::Swap(CltUser* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(desc_, other->desc_);
    std::swap(full_name_, other->full_name_);
    std::swap(profile_, other->profile_);
    std::swap(group_, other->group_);
    std::swap(lock_, other->lock_);
    std::swap(disable_, other->disable_);
    std::swap(userpsw_, other->userpsw_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltUser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltUser_descriptor_;
  metadata.reflection = CltUser_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltUserList::kListFieldNumber;
#endif  // !_MSC_VER

CltUserList::CltUserList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltUserList::InitAsDefaultInstance() {
}

CltUserList::CltUserList(const CltUserList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltUserList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltUserList::~CltUserList() {
  SharedDtor();
}

void CltUserList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltUserList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltUserList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltUserList_descriptor_;
}

const CltUserList& CltUserList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltUserList* CltUserList::default_instance_ = NULL;

CltUserList* CltUserList::New() const {
  return new CltUserList;
}

void CltUserList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltUserList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltUser list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltUserList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltUser list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltUserList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltUser list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltUserList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltUser list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltUserList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltUserList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltUserList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltUserList::MergeFrom(const CltUserList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltUserList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltUserList::CopyFrom(const CltUserList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltUserList::IsInitialized() const {
  
  return true;
}

void CltUserList::Swap(CltUserList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltUserList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltUserList_descriptor_;
  metadata.reflection = CltUserList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltGroup::kNameFieldNumber;
const int CltGroup::kDescFieldNumber;
#endif  // !_MSC_VER

CltGroup::CltGroup()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltGroup::InitAsDefaultInstance() {
}

CltGroup::CltGroup(const CltGroup& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltGroup::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltGroup::~CltGroup() {
  SharedDtor();
}

void CltGroup::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (this != default_instance_) {
  }
}

void CltGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltGroup_descriptor_;
}

const CltGroup& CltGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltGroup* CltGroup::default_instance_ = NULL;

CltGroup* CltGroup::New() const {
  return new CltGroup;
}

void CltGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }
      
      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltGroup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->desc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltGroup::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltGroup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltGroup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltGroup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltGroup::MergeFrom(const CltGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltGroup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltGroup::CopyFrom(const CltGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltGroup::IsInitialized() const {
  
  return true;
}

void CltGroup::Swap(CltGroup* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(desc_, other->desc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltGroup_descriptor_;
  metadata.reflection = CltGroup_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltGroupList::kListFieldNumber;
#endif  // !_MSC_VER

CltGroupList::CltGroupList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltGroupList::InitAsDefaultInstance() {
}

CltGroupList::CltGroupList(const CltGroupList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltGroupList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltGroupList::~CltGroupList() {
  SharedDtor();
}

void CltGroupList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltGroupList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltGroupList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltGroupList_descriptor_;
}

const CltGroupList& CltGroupList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltGroupList* CltGroupList::default_instance_ = NULL;

CltGroupList* CltGroupList::New() const {
  return new CltGroupList;
}

void CltGroupList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltGroupList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltGroup list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltGroupList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltGroup list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltGroupList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltGroup list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltGroupList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltGroup list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltGroupList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltGroupList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltGroupList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltGroupList::MergeFrom(const CltGroupList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltGroupList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltGroupList::CopyFrom(const CltGroupList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltGroupList::IsInitialized() const {
  
  return true;
}

void CltGroupList::Swap(CltGroupList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltGroupList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltGroupList_descriptor_;
  metadata.reflection = CltGroupList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltShareInfo::kNetnameFieldNumber;
const int CltShareInfo::kTypeFieldNumber;
const int CltShareInfo::kRemarkFieldNumber;
const int CltShareInfo::kCurrentUsesFieldNumber;
const int CltShareInfo::kPathFieldNumber;
#endif  // !_MSC_VER

CltShareInfo::CltShareInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltShareInfo::InitAsDefaultInstance() {
}

CltShareInfo::CltShareInfo(const CltShareInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltShareInfo::SharedCtor() {
  _cached_size_ = 0;
  netname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  current_uses_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltShareInfo::~CltShareInfo() {
  SharedDtor();
}

void CltShareInfo::SharedDtor() {
  if (netname_ != &::google::protobuf::internal::kEmptyString) {
    delete netname_;
  }
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void CltShareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltShareInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltShareInfo_descriptor_;
}

const CltShareInfo& CltShareInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltShareInfo* CltShareInfo::default_instance_ = NULL;

CltShareInfo* CltShareInfo::New() const {
  return new CltShareInfo;
}

void CltShareInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_netname()) {
      if (netname_ != &::google::protobuf::internal::kEmptyString) {
        netname_->clear();
      }
    }
    type_ = 0;
    if (has_remark()) {
      if (remark_ != &::google::protobuf::internal::kEmptyString) {
        remark_->clear();
      }
    }
    current_uses_ = 0;
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltShareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string netname = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_netname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->netname().data(), this->netname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // optional int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_remark;
        break;
      }
      
      // optional string remark = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remark()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->remark().data(), this->remark().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_current_uses;
        break;
      }
      
      // optional int32 current_uses = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_current_uses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_uses_)));
          set_has_current_uses();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_path;
        break;
      }
      
      // optional string path = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltShareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string netname = 1;
  if (has_netname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->netname().data(), this->netname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->netname(), output);
  }
  
  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }
  
  // optional string remark = 3;
  if (has_remark()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->remark().data(), this->remark().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->remark(), output);
  }
  
  // optional int32 current_uses = 4;
  if (has_current_uses()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->current_uses(), output);
  }
  
  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltShareInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string netname = 1;
  if (has_netname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->netname().data(), this->netname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->netname(), target);
  }
  
  // optional int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }
  
  // optional string remark = 3;
  if (has_remark()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->remark().data(), this->remark().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->remark(), target);
  }
  
  // optional int32 current_uses = 4;
  if (has_current_uses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->current_uses(), target);
  }
  
  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltShareInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string netname = 1;
    if (has_netname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->netname());
    }
    
    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // optional string remark = 3;
    if (has_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remark());
    }
    
    // optional int32 current_uses = 4;
    if (has_current_uses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current_uses());
    }
    
    // optional string path = 5;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltShareInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltShareInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltShareInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltShareInfo::MergeFrom(const CltShareInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_netname()) {
      set_netname(from.netname());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_remark()) {
      set_remark(from.remark());
    }
    if (from.has_current_uses()) {
      set_current_uses(from.current_uses());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltShareInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltShareInfo::CopyFrom(const CltShareInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltShareInfo::IsInitialized() const {
  
  return true;
}

void CltShareInfo::Swap(CltShareInfo* other) {
  if (other != this) {
    std::swap(netname_, other->netname_);
    std::swap(type_, other->type_);
    std::swap(remark_, other->remark_);
    std::swap(current_uses_, other->current_uses_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltShareInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltShareInfo_descriptor_;
  metadata.reflection = CltShareInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltShareList::kListFieldNumber;
#endif  // !_MSC_VER

CltShareList::CltShareList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltShareList::InitAsDefaultInstance() {
}

CltShareList::CltShareList(const CltShareList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltShareList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltShareList::~CltShareList() {
  SharedDtor();
}

void CltShareList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltShareList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltShareList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltShareList_descriptor_;
}

const CltShareList& CltShareList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltShareList* CltShareList::default_instance_ = NULL;

CltShareList* CltShareList::New() const {
  return new CltShareList;
}

void CltShareList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltShareList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltShareInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltShareList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltShareInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltShareList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltShareInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltShareList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltShareInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltShareList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltShareList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltShareList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltShareList::MergeFrom(const CltShareList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltShareList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltShareList::CopyFrom(const CltShareList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltShareList::IsInitialized() const {
  
  return true;
}

void CltShareList::Swap(CltShareList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltShareList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltShareList_descriptor_;
  metadata.reflection = CltShareList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltStartItem::kNameFieldNumber;
const int CltStartItem::kValFieldNumber;
const int CltStartItem::kPathFieldNumber;
#endif  // !_MSC_VER

CltStartItem::CltStartItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltStartItem::InitAsDefaultInstance() {
}

CltStartItem::CltStartItem(const CltStartItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltStartItem::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltStartItem::~CltStartItem() {
  SharedDtor();
}

void CltStartItem::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (val_ != &::google::protobuf::internal::kEmptyString) {
    delete val_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void CltStartItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltStartItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltStartItem_descriptor_;
}

const CltStartItem& CltStartItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltStartItem* CltStartItem::default_instance_ = NULL;

CltStartItem* CltStartItem::New() const {
  return new CltStartItem;
}

void CltStartItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_val()) {
      if (val_ != &::google::protobuf::internal::kEmptyString) {
        val_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltStartItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }
      
      // optional string val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_val()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->val().data(), this->val().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }
      
      // optional string path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltStartItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->val().data(), this->val().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->val(), output);
  }
  
  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltStartItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->val().data(), this->val().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->val(), target);
  }
  
  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltStartItem::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->val());
    }
    
    // optional string path = 3;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltStartItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltStartItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltStartItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltStartItem::MergeFrom(const CltStartItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_val()) {
      set_val(from.val());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltStartItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltStartItem::CopyFrom(const CltStartItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltStartItem::IsInitialized() const {
  
  return true;
}

void CltStartItem::Swap(CltStartItem* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(val_, other->val_);
    std::swap(path_, other->path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltStartItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltStartItem_descriptor_;
  metadata.reflection = CltStartItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltStartList::kListFieldNumber;
#endif  // !_MSC_VER

CltStartList::CltStartList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltStartList::InitAsDefaultInstance() {
}

CltStartList::CltStartList(const CltStartList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltStartList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltStartList::~CltStartList() {
  SharedDtor();
}

void CltStartList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltStartList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltStartList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltStartList_descriptor_;
}

const CltStartList& CltStartList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltStartList* CltStartList::default_instance_ = NULL;

CltStartList* CltStartList::New() const {
  return new CltStartList;
}

void CltStartList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltStartList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltStartItem list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltStartList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltStartItem list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltStartList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltStartItem list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltStartList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltStartItem list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltStartList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltStartList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltStartList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltStartList::MergeFrom(const CltStartList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltStartList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltStartList::CopyFrom(const CltStartList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltStartList::IsInitialized() const {
  
  return true;
}

void CltStartList::Swap(CltStartList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltStartList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltStartList_descriptor_;
  metadata.reflection = CltStartList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltDiskInfo::kNameFieldNumber;
const int CltDiskInfo::kTotalSizeFieldNumber;
const int CltDiskInfo::kFreeSizeFieldNumber;
const int CltDiskInfo::kTypeFieldNumber;
const int CltDiskInfo::kVolNameFieldNumber;
const int CltDiskInfo::kFileTypeFieldNumber;
const int CltDiskInfo::kFileSnoFieldNumber;
const int CltDiskInfo::kFileMaxFieldNumber;
const int CltDiskInfo::kFileFlagFieldNumber;
#endif  // !_MSC_VER

CltDiskInfo::CltDiskInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltDiskInfo::InitAsDefaultInstance() {
}

CltDiskInfo::CltDiskInfo(const CltDiskInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltDiskInfo::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  total_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  free_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0u;
  vol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_sno_ = 0u;
  file_max_ = 0u;
  file_flag_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltDiskInfo::~CltDiskInfo() {
  SharedDtor();
}

void CltDiskInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (total_size_ != &::google::protobuf::internal::kEmptyString) {
    delete total_size_;
  }
  if (free_size_ != &::google::protobuf::internal::kEmptyString) {
    delete free_size_;
  }
  if (vol_name_ != &::google::protobuf::internal::kEmptyString) {
    delete vol_name_;
  }
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    delete file_type_;
  }
  if (this != default_instance_) {
  }
}

void CltDiskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltDiskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltDiskInfo_descriptor_;
}

const CltDiskInfo& CltDiskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltDiskInfo* CltDiskInfo::default_instance_ = NULL;

CltDiskInfo* CltDiskInfo::New() const {
  return new CltDiskInfo;
}

void CltDiskInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_total_size()) {
      if (total_size_ != &::google::protobuf::internal::kEmptyString) {
        total_size_->clear();
      }
    }
    if (has_free_size()) {
      if (free_size_ != &::google::protobuf::internal::kEmptyString) {
        free_size_->clear();
      }
    }
    type_ = 0u;
    if (has_vol_name()) {
      if (vol_name_ != &::google::protobuf::internal::kEmptyString) {
        vol_name_->clear();
      }
    }
    if (has_file_type()) {
      if (file_type_ != &::google::protobuf::internal::kEmptyString) {
        file_type_->clear();
      }
    }
    file_sno_ = 0u;
    file_max_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    file_flag_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltDiskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_total_size;
        break;
      }
      
      // optional string total_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_total_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_total_size()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->total_size().data(), this->total_size().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_free_size;
        break;
      }
      
      // optional string free_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_free_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_free_size()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->free_size().data(), this->free_size().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }
      
      // optional uint32 type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_vol_name;
        break;
      }
      
      // optional string vol_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vol_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vol_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->vol_name().data(), this->vol_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_file_type;
        break;
      }
      
      // optional string file_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->file_type().data(), this->file_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_file_sno;
        break;
      }
      
      // optional uint32 file_sno = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_sno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_sno_)));
          set_has_file_sno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_file_max;
        break;
      }
      
      // optional uint32 file_max = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_max_)));
          set_has_file_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_file_flag;
        break;
      }
      
      // optional uint32 file_flag = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_flag_)));
          set_has_file_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltDiskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string total_size = 2;
  if (has_total_size()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->total_size().data(), this->total_size().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->total_size(), output);
  }
  
  // optional string free_size = 3;
  if (has_free_size()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->free_size().data(), this->free_size().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->free_size(), output);
  }
  
  // optional uint32 type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
  }
  
  // optional string vol_name = 5;
  if (has_vol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vol_name().data(), this->vol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->vol_name(), output);
  }
  
  // optional string file_type = 6;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_type().data(), this->file_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->file_type(), output);
  }
  
  // optional uint32 file_sno = 7;
  if (has_file_sno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->file_sno(), output);
  }
  
  // optional uint32 file_max = 8;
  if (has_file_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->file_max(), output);
  }
  
  // optional uint32 file_flag = 9;
  if (has_file_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->file_flag(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltDiskInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string total_size = 2;
  if (has_total_size()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->total_size().data(), this->total_size().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->total_size(), target);
  }
  
  // optional string free_size = 3;
  if (has_free_size()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->free_size().data(), this->free_size().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->free_size(), target);
  }
  
  // optional uint32 type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
  }
  
  // optional string vol_name = 5;
  if (has_vol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vol_name().data(), this->vol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->vol_name(), target);
  }
  
  // optional string file_type = 6;
  if (has_file_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_type().data(), this->file_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->file_type(), target);
  }
  
  // optional uint32 file_sno = 7;
  if (has_file_sno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->file_sno(), target);
  }
  
  // optional uint32 file_max = 8;
  if (has_file_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->file_max(), target);
  }
  
  // optional uint32 file_flag = 9;
  if (has_file_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->file_flag(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltDiskInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string total_size = 2;
    if (has_total_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->total_size());
    }
    
    // optional string free_size = 3;
    if (has_free_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->free_size());
    }
    
    // optional uint32 type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }
    
    // optional string vol_name = 5;
    if (has_vol_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vol_name());
    }
    
    // optional string file_type = 6;
    if (has_file_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_type());
    }
    
    // optional uint32 file_sno = 7;
    if (has_file_sno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_sno());
    }
    
    // optional uint32 file_max = 8;
    if (has_file_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_max());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 file_flag = 9;
    if (has_file_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_flag());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltDiskInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltDiskInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltDiskInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltDiskInfo::MergeFrom(const CltDiskInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_total_size()) {
      set_total_size(from.total_size());
    }
    if (from.has_free_size()) {
      set_free_size(from.free_size());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_vol_name()) {
      set_vol_name(from.vol_name());
    }
    if (from.has_file_type()) {
      set_file_type(from.file_type());
    }
    if (from.has_file_sno()) {
      set_file_sno(from.file_sno());
    }
    if (from.has_file_max()) {
      set_file_max(from.file_max());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_file_flag()) {
      set_file_flag(from.file_flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltDiskInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltDiskInfo::CopyFrom(const CltDiskInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltDiskInfo::IsInitialized() const {
  
  return true;
}

void CltDiskInfo::Swap(CltDiskInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(total_size_, other->total_size_);
    std::swap(free_size_, other->free_size_);
    std::swap(type_, other->type_);
    std::swap(vol_name_, other->vol_name_);
    std::swap(file_type_, other->file_type_);
    std::swap(file_sno_, other->file_sno_);
    std::swap(file_max_, other->file_max_);
    std::swap(file_flag_, other->file_flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltDiskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltDiskInfo_descriptor_;
  metadata.reflection = CltDiskInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CltDiskList::kListFieldNumber;
#endif  // !_MSC_VER

CltDiskList::CltDiskList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CltDiskList::InitAsDefaultInstance() {
}

CltDiskList::CltDiskList(const CltDiskList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CltDiskList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CltDiskList::~CltDiskList() {
  SharedDtor();
}

void CltDiskList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CltDiskList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CltDiskList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CltDiskList_descriptor_;
}

const CltDiskList& CltDiskList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

CltDiskList* CltDiskList::default_instance_ = NULL;

CltDiskList* CltDiskList::New() const {
  return new CltDiskList;
}

void CltDiskList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CltDiskList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.CltDiskInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CltDiskList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.CltDiskInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CltDiskList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.CltDiskInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CltDiskList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.CltDiskInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CltDiskList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CltDiskList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CltDiskList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CltDiskList::MergeFrom(const CltDiskList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CltDiskList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CltDiskList::CopyFrom(const CltDiskList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CltDiskList::IsInitialized() const {
  
  return true;
}

void CltDiskList::Swap(CltDiskList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CltDiskList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CltDiskList_descriptor_;
  metadata.reflection = CltDiskList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceControlInfo::kIndexFieldNumber;
const int DeviceControlInfo::kEnabledFieldNumber;
const int DeviceControlInfo::kDeviceDescFieldNumber;
const int DeviceControlInfo::kStatusFieldNumber;
#endif  // !_MSC_VER

DeviceControlInfo::DeviceControlInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DeviceControlInfo::InitAsDefaultInstance() {
}

DeviceControlInfo::DeviceControlInfo(const DeviceControlInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DeviceControlInfo::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  enabled_ = 0;
  devicedesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceControlInfo::~DeviceControlInfo() {
  SharedDtor();
}

void DeviceControlInfo::SharedDtor() {
  if (devicedesc_ != &::google::protobuf::internal::kEmptyString) {
    delete devicedesc_;
  }
  if (this != default_instance_) {
  }
}

void DeviceControlInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceControlInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceControlInfo_descriptor_;
}

const DeviceControlInfo& DeviceControlInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DeviceControlInfo* DeviceControlInfo::default_instance_ = NULL;

DeviceControlInfo* DeviceControlInfo::New() const {
  return new DeviceControlInfo;
}

void DeviceControlInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0;
    enabled_ = 0;
    if (has_devicedesc()) {
      if (devicedesc_ != &::google::protobuf::internal::kEmptyString) {
        devicedesc_->clear();
      }
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceControlInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_enabled;
        break;
      }
      
      // optional int32 enabled = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_deviceDesc;
        break;
      }
      
      // optional string deviceDesc = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deviceDesc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_devicedesc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->devicedesc().data(), this->devicedesc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_status;
        break;
      }
      
      // optional int32 status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeviceControlInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }
  
  // optional int32 enabled = 2;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->enabled(), output);
  }
  
  // optional string deviceDesc = 3;
  if (has_devicedesc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicedesc().data(), this->devicedesc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->devicedesc(), output);
  }
  
  // optional int32 status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->status(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DeviceControlInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }
  
  // optional int32 enabled = 2;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->enabled(), target);
  }
  
  // optional string deviceDesc = 3;
  if (has_devicedesc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->devicedesc().data(), this->devicedesc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->devicedesc(), target);
  }
  
  // optional int32 status = 4;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->status(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DeviceControlInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }
    
    // optional int32 enabled = 2;
    if (has_enabled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enabled());
    }
    
    // optional string deviceDesc = 3;
    if (has_devicedesc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->devicedesc());
    }
    
    // optional int32 status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceControlInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceControlInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceControlInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceControlInfo::MergeFrom(const DeviceControlInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_devicedesc()) {
      set_devicedesc(from.devicedesc());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceControlInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceControlInfo::CopyFrom(const DeviceControlInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceControlInfo::IsInitialized() const {
  
  return true;
}

void DeviceControlInfo::Swap(DeviceControlInfo* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(enabled_, other->enabled_);
    std::swap(devicedesc_, other->devicedesc_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceControlInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceControlInfo_descriptor_;
  metadata.reflection = DeviceControlInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceControlClassInfo::kClassNameFieldNumber;
const int DeviceControlClassInfo::kGuidFieldNumber;
const int DeviceControlClassInfo::kImageIndexFieldNumber;
const int DeviceControlClassInfo::kDeviceInfolistFieldNumber;
#endif  // !_MSC_VER

DeviceControlClassInfo::DeviceControlClassInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DeviceControlClassInfo::InitAsDefaultInstance() {
}

DeviceControlClassInfo::DeviceControlClassInfo(const DeviceControlClassInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DeviceControlClassInfo::SharedCtor() {
  _cached_size_ = 0;
  classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  imageindex_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceControlClassInfo::~DeviceControlClassInfo() {
  SharedDtor();
}

void DeviceControlClassInfo::SharedDtor() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (this != default_instance_) {
  }
}

void DeviceControlClassInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceControlClassInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceControlClassInfo_descriptor_;
}

const DeviceControlClassInfo& DeviceControlClassInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DeviceControlClassInfo* DeviceControlClassInfo::default_instance_ = NULL;

DeviceControlClassInfo* DeviceControlClassInfo::New() const {
  return new DeviceControlClassInfo;
}

void DeviceControlClassInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_classname()) {
      if (classname_ != &::google::protobuf::internal::kEmptyString) {
        classname_->clear();
      }
    }
    if (has_guid()) {
      if (guid_ != &::google::protobuf::internal::kEmptyString) {
        guid_->clear();
      }
    }
    imageindex_ = 0;
  }
  deviceinfolist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceControlClassInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string className = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_classname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->classname().data(), this->classname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_guid;
        break;
      }
      
      // optional string guid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->guid().data(), this->guid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_imageIndex;
        break;
      }
      
      // optional int32 imageIndex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_imageIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &imageindex_)));
          set_has_imageindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_DeviceInfolist;
        break;
      }
      
      // repeated .isafetec.DeviceControlInfo DeviceInfolist = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DeviceInfolist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_deviceinfolist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_DeviceInfolist;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeviceControlClassInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string className = 1;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->classname(), output);
  }
  
  // optional string guid = 2;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guid().data(), this->guid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->guid(), output);
  }
  
  // optional int32 imageIndex = 3;
  if (has_imageindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->imageindex(), output);
  }
  
  // repeated .isafetec.DeviceControlInfo DeviceInfolist = 4;
  for (int i = 0; i < this->deviceinfolist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->deviceinfolist(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DeviceControlClassInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string className = 1;
  if (has_classname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->classname().data(), this->classname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->classname(), target);
  }
  
  // optional string guid = 2;
  if (has_guid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guid().data(), this->guid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->guid(), target);
  }
  
  // optional int32 imageIndex = 3;
  if (has_imageindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->imageindex(), target);
  }
  
  // repeated .isafetec.DeviceControlInfo DeviceInfolist = 4;
  for (int i = 0; i < this->deviceinfolist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->deviceinfolist(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DeviceControlClassInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string className = 1;
    if (has_classname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->classname());
    }
    
    // optional string guid = 2;
    if (has_guid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guid());
    }
    
    // optional int32 imageIndex = 3;
    if (has_imageindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->imageindex());
    }
    
  }
  // repeated .isafetec.DeviceControlInfo DeviceInfolist = 4;
  total_size += 1 * this->deviceinfolist_size();
  for (int i = 0; i < this->deviceinfolist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->deviceinfolist(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceControlClassInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceControlClassInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceControlClassInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceControlClassInfo::MergeFrom(const DeviceControlClassInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  deviceinfolist_.MergeFrom(from.deviceinfolist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_classname()) {
      set_classname(from.classname());
    }
    if (from.has_guid()) {
      set_guid(from.guid());
    }
    if (from.has_imageindex()) {
      set_imageindex(from.imageindex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceControlClassInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceControlClassInfo::CopyFrom(const DeviceControlClassInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceControlClassInfo::IsInitialized() const {
  
  return true;
}

void DeviceControlClassInfo::Swap(DeviceControlClassInfo* other) {
  if (other != this) {
    std::swap(classname_, other->classname_);
    std::swap(guid_, other->guid_);
    std::swap(imageindex_, other->imageindex_);
    deviceinfolist_.Swap(&other->deviceinfolist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceControlClassInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceControlClassInfo_descriptor_;
  metadata.reflection = DeviceControlClassInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DeviceControlClassList::kComputerNameFieldNumber;
const int DeviceControlClassList::kDeviceClasslistFieldNumber;
#endif  // !_MSC_VER

DeviceControlClassList::DeviceControlClassList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DeviceControlClassList::InitAsDefaultInstance() {
}

DeviceControlClassList::DeviceControlClassList(const DeviceControlClassList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DeviceControlClassList::SharedCtor() {
  _cached_size_ = 0;
  computername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceControlClassList::~DeviceControlClassList() {
  SharedDtor();
}

void DeviceControlClassList::SharedDtor() {
  if (computername_ != &::google::protobuf::internal::kEmptyString) {
    delete computername_;
  }
  if (this != default_instance_) {
  }
}

void DeviceControlClassList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeviceControlClassList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeviceControlClassList_descriptor_;
}

const DeviceControlClassList& DeviceControlClassList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DeviceControlClassList* DeviceControlClassList::default_instance_ = NULL;

DeviceControlClassList* DeviceControlClassList::New() const {
  return new DeviceControlClassList;
}

void DeviceControlClassList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_computername()) {
      if (computername_ != &::google::protobuf::internal::kEmptyString) {
        computername_->clear();
      }
    }
  }
  deviceclasslist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeviceControlClassList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string computerName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_computername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->computername().data(), this->computername().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_DeviceClasslist;
        break;
      }
      
      // repeated .isafetec.DeviceControlClassInfo DeviceClasslist = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DeviceClasslist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_deviceclasslist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_DeviceClasslist;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DeviceControlClassList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string computerName = 1;
  if (has_computername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->computername().data(), this->computername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->computername(), output);
  }
  
  // repeated .isafetec.DeviceControlClassInfo DeviceClasslist = 2;
  for (int i = 0; i < this->deviceclasslist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->deviceclasslist(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DeviceControlClassList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string computerName = 1;
  if (has_computername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->computername().data(), this->computername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->computername(), target);
  }
  
  // repeated .isafetec.DeviceControlClassInfo DeviceClasslist = 2;
  for (int i = 0; i < this->deviceclasslist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->deviceclasslist(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DeviceControlClassList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string computerName = 1;
    if (has_computername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->computername());
    }
    
  }
  // repeated .isafetec.DeviceControlClassInfo DeviceClasslist = 2;
  total_size += 1 * this->deviceclasslist_size();
  for (int i = 0; i < this->deviceclasslist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->deviceclasslist(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceControlClassList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeviceControlClassList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeviceControlClassList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeviceControlClassList::MergeFrom(const DeviceControlClassList& from) {
  GOOGLE_CHECK_NE(&from, this);
  deviceclasslist_.MergeFrom(from.deviceclasslist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_computername()) {
      set_computername(from.computername());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeviceControlClassList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceControlClassList::CopyFrom(const DeviceControlClassList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceControlClassList::IsInitialized() const {
  
  return true;
}

void DeviceControlClassList::Swap(DeviceControlClassList* other) {
  if (other != this) {
    std::swap(computername_, other->computername_);
    deviceclasslist_.Swap(&other->deviceclasslist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DeviceControlClassList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeviceControlClassList_descriptor_;
  metadata.reflection = DeviceControlClassList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FireWallInfo::kEnabledFieldNumber;
#endif  // !_MSC_VER

FireWallInfo::FireWallInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FireWallInfo::InitAsDefaultInstance() {
}

FireWallInfo::FireWallInfo(const FireWallInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FireWallInfo::SharedCtor() {
  _cached_size_ = 0;
  enabled_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FireWallInfo::~FireWallInfo() {
  SharedDtor();
}

void FireWallInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FireWallInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FireWallInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FireWallInfo_descriptor_;
}

const FireWallInfo& FireWallInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

FireWallInfo* FireWallInfo::default_instance_ = NULL;

FireWallInfo* FireWallInfo::New() const {
  return new FireWallInfo;
}

void FireWallInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enabled_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FireWallInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 enabled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FireWallInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 enabled = 1;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->enabled(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FireWallInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 enabled = 1;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->enabled(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FireWallInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 enabled = 1;
    if (has_enabled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enabled());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FireWallInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FireWallInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FireWallInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FireWallInfo::MergeFrom(const FireWallInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FireWallInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FireWallInfo::CopyFrom(const FireWallInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FireWallInfo::IsInitialized() const {
  
  return true;
}

void FireWallInfo::Swap(FireWallInfo* other) {
  if (other != this) {
    std::swap(enabled_, other->enabled_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FireWallInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FireWallInfo_descriptor_;
  metadata.reflection = FireWallInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DataBaseInfo::kPackageCodeFieldNumber;
const int DataBaseInfo::kChecktypeFieldNumber;
const int DataBaseInfo::kScanTimeFieldNumber;
const int DataBaseInfo::kAddtimeFieldNumber;
const int DataBaseInfo::kStatusFieldNumber;
const int DataBaseInfo::kVersionFieldNumber;
#endif  // !_MSC_VER

DataBaseInfo::DataBaseInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataBaseInfo::InitAsDefaultInstance() {
}

DataBaseInfo::DataBaseInfo(const DataBaseInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataBaseInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataBaseInfo::~DataBaseInfo() {
  SharedDtor();
}

void DataBaseInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void DataBaseInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataBaseInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataBaseInfo_descriptor_;
}

const DataBaseInfo& DataBaseInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DataBaseInfo* DataBaseInfo::default_instance_ = NULL;

DataBaseInfo* DataBaseInfo::New() const {
  return new DataBaseInfo;
}

void DataBaseInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataBaseInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_status;
        break;
      }
      
      // optional string status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_version;
        break;
      }
      
      // optional string version = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataBaseInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional string status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->status(), output);
  }
  
  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->version(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataBaseInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional string status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->status(), target);
  }
  
  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->version(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataBaseInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional string status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
    // optional string version = 5;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataBaseInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataBaseInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataBaseInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataBaseInfo::MergeFrom(const DataBaseInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataBaseInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataBaseInfo::CopyFrom(const DataBaseInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataBaseInfo::IsInitialized() const {
  
  return true;
}

void DataBaseInfo::Swap(DataBaseInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(status_, other->status_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataBaseInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataBaseInfo_descriptor_;
  metadata.reflection = DataBaseInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DataBaseInfoList::kListFieldNumber;
const int DataBaseInfoList::kAlarmedFieldNumber;
const int DataBaseInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

DataBaseInfoList::DataBaseInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataBaseInfoList::InitAsDefaultInstance() {
}

DataBaseInfoList::DataBaseInfoList(const DataBaseInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataBaseInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataBaseInfoList::~DataBaseInfoList() {
  SharedDtor();
}

void DataBaseInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void DataBaseInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataBaseInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataBaseInfoList_descriptor_;
}

const DataBaseInfoList& DataBaseInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DataBaseInfoList* DataBaseInfoList::default_instance_ = NULL;

DataBaseInfoList* DataBaseInfoList::New() const {
  return new DataBaseInfoList;
}

void DataBaseInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataBaseInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.DataBaseInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataBaseInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.DataBaseInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataBaseInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.DataBaseInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataBaseInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.DataBaseInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataBaseInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataBaseInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataBaseInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataBaseInfoList::MergeFrom(const DataBaseInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataBaseInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataBaseInfoList::CopyFrom(const DataBaseInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataBaseInfoList::IsInitialized() const {
  
  return true;
}

void DataBaseInfoList::Swap(DataBaseInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataBaseInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataBaseInfoList_descriptor_;
  metadata.reflection = DataBaseInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ODBCSourceInfo::kPackageCodeFieldNumber;
const int ODBCSourceInfo::kChecktypeFieldNumber;
const int ODBCSourceInfo::kScanTimeFieldNumber;
const int ODBCSourceInfo::kAddtimeFieldNumber;
#endif  // !_MSC_VER

ODBCSourceInfo::ODBCSourceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ODBCSourceInfo::InitAsDefaultInstance() {
}

ODBCSourceInfo::ODBCSourceInfo(const ODBCSourceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ODBCSourceInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ODBCSourceInfo::~ODBCSourceInfo() {
  SharedDtor();
}

void ODBCSourceInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (this != default_instance_) {
  }
}

void ODBCSourceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ODBCSourceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ODBCSourceInfo_descriptor_;
}

const ODBCSourceInfo& ODBCSourceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ODBCSourceInfo* ODBCSourceInfo::default_instance_ = NULL;

ODBCSourceInfo* ODBCSourceInfo::New() const {
  return new ODBCSourceInfo;
}

void ODBCSourceInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ODBCSourceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ODBCSourceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ODBCSourceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ODBCSourceInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ODBCSourceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ODBCSourceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ODBCSourceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ODBCSourceInfo::MergeFrom(const ODBCSourceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ODBCSourceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ODBCSourceInfo::CopyFrom(const ODBCSourceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ODBCSourceInfo::IsInitialized() const {
  
  return true;
}

void ODBCSourceInfo::Swap(ODBCSourceInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ODBCSourceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ODBCSourceInfo_descriptor_;
  metadata.reflection = ODBCSourceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ODBCSourceInfoList::kListFieldNumber;
const int ODBCSourceInfoList::kAlarmedFieldNumber;
const int ODBCSourceInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

ODBCSourceInfoList::ODBCSourceInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ODBCSourceInfoList::InitAsDefaultInstance() {
}

ODBCSourceInfoList::ODBCSourceInfoList(const ODBCSourceInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ODBCSourceInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ODBCSourceInfoList::~ODBCSourceInfoList() {
  SharedDtor();
}

void ODBCSourceInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void ODBCSourceInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ODBCSourceInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ODBCSourceInfoList_descriptor_;
}

const ODBCSourceInfoList& ODBCSourceInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ODBCSourceInfoList* ODBCSourceInfoList::default_instance_ = NULL;

ODBCSourceInfoList* ODBCSourceInfoList::New() const {
  return new ODBCSourceInfoList;
}

void ODBCSourceInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ODBCSourceInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.ODBCSourceInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ODBCSourceInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.ODBCSourceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ODBCSourceInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.ODBCSourceInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ODBCSourceInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.ODBCSourceInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ODBCSourceInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ODBCSourceInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ODBCSourceInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ODBCSourceInfoList::MergeFrom(const ODBCSourceInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ODBCSourceInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ODBCSourceInfoList::CopyFrom(const ODBCSourceInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ODBCSourceInfoList::IsInitialized() const {
  
  return true;
}

void ODBCSourceInfoList::Swap(ODBCSourceInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ODBCSourceInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ODBCSourceInfoList_descriptor_;
  metadata.reflection = ODBCSourceInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ODBCDriverInfo::kPackageCodeFieldNumber;
const int ODBCDriverInfo::kChecktypeFieldNumber;
const int ODBCDriverInfo::kScanTimeFieldNumber;
const int ODBCDriverInfo::kAddtimeFieldNumber;
#endif  // !_MSC_VER

ODBCDriverInfo::ODBCDriverInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ODBCDriverInfo::InitAsDefaultInstance() {
}

ODBCDriverInfo::ODBCDriverInfo(const ODBCDriverInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ODBCDriverInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ODBCDriverInfo::~ODBCDriverInfo() {
  SharedDtor();
}

void ODBCDriverInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (this != default_instance_) {
  }
}

void ODBCDriverInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ODBCDriverInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ODBCDriverInfo_descriptor_;
}

const ODBCDriverInfo& ODBCDriverInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ODBCDriverInfo* ODBCDriverInfo::default_instance_ = NULL;

ODBCDriverInfo* ODBCDriverInfo::New() const {
  return new ODBCDriverInfo;
}

void ODBCDriverInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ODBCDriverInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ODBCDriverInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ODBCDriverInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ODBCDriverInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ODBCDriverInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ODBCDriverInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ODBCDriverInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ODBCDriverInfo::MergeFrom(const ODBCDriverInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ODBCDriverInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ODBCDriverInfo::CopyFrom(const ODBCDriverInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ODBCDriverInfo::IsInitialized() const {
  
  return true;
}

void ODBCDriverInfo::Swap(ODBCDriverInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ODBCDriverInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ODBCDriverInfo_descriptor_;
  metadata.reflection = ODBCDriverInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ODBCDriverInfoList::kListFieldNumber;
const int ODBCDriverInfoList::kAlarmedFieldNumber;
const int ODBCDriverInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

ODBCDriverInfoList::ODBCDriverInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ODBCDriverInfoList::InitAsDefaultInstance() {
}

ODBCDriverInfoList::ODBCDriverInfoList(const ODBCDriverInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ODBCDriverInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ODBCDriverInfoList::~ODBCDriverInfoList() {
  SharedDtor();
}

void ODBCDriverInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void ODBCDriverInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ODBCDriverInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ODBCDriverInfoList_descriptor_;
}

const ODBCDriverInfoList& ODBCDriverInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

ODBCDriverInfoList* ODBCDriverInfoList::default_instance_ = NULL;

ODBCDriverInfoList* ODBCDriverInfoList::New() const {
  return new ODBCDriverInfoList;
}

void ODBCDriverInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ODBCDriverInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.ODBCDriverInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ODBCDriverInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.ODBCDriverInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ODBCDriverInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.ODBCDriverInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ODBCDriverInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.ODBCDriverInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ODBCDriverInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ODBCDriverInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ODBCDriverInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ODBCDriverInfoList::MergeFrom(const ODBCDriverInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ODBCDriverInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ODBCDriverInfoList::CopyFrom(const ODBCDriverInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ODBCDriverInfoList::IsInitialized() const {
  
  return true;
}

void ODBCDriverInfoList::Swap(ODBCDriverInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ODBCDriverInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ODBCDriverInfoList_descriptor_;
  metadata.reflection = ODBCDriverInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AntiVirusSoftWareInfo::kPackageCodeFieldNumber;
const int AntiVirusSoftWareInfo::kChecktypeFieldNumber;
const int AntiVirusSoftWareInfo::kScanTimeFieldNumber;
const int AntiVirusSoftWareInfo::kAddtimeFieldNumber;
const int AntiVirusSoftWareInfo::kVersionNumberFieldNumber;
const int AntiVirusSoftWareInfo::kPathFieldNumber;
const int AntiVirusSoftWareInfo::kStatusFieldNumber;
#endif  // !_MSC_VER

AntiVirusSoftWareInfo::AntiVirusSoftWareInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AntiVirusSoftWareInfo::InitAsDefaultInstance() {
}

AntiVirusSoftWareInfo::AntiVirusSoftWareInfo(const AntiVirusSoftWareInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AntiVirusSoftWareInfo::SharedCtor() {
  _cached_size_ = 0;
  package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checktype_ = 0;
  scan_time_ = 0;
  addtime_ = 0;
  versionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AntiVirusSoftWareInfo::~AntiVirusSoftWareInfo() {
  SharedDtor();
}

void AntiVirusSoftWareInfo::SharedDtor() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    delete package_code_;
  }
  if (versionnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete versionnumber_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void AntiVirusSoftWareInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AntiVirusSoftWareInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AntiVirusSoftWareInfo_descriptor_;
}

const AntiVirusSoftWareInfo& AntiVirusSoftWareInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

AntiVirusSoftWareInfo* AntiVirusSoftWareInfo::default_instance_ = NULL;

AntiVirusSoftWareInfo* AntiVirusSoftWareInfo::New() const {
  return new AntiVirusSoftWareInfo;
}

void AntiVirusSoftWareInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_package_code()) {
      if (package_code_ != &::google::protobuf::internal::kEmptyString) {
        package_code_->clear();
      }
    }
    checktype_ = 0;
    scan_time_ = 0;
    addtime_ = 0;
    if (has_versionnumber()) {
      if (versionnumber_ != &::google::protobuf::internal::kEmptyString) {
        versionnumber_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AntiVirusSoftWareInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->package_code().data(), this->package_code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_checktype;
        break;
      }
      
      // optional int32 checktype = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checktype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checktype_)));
          set_has_checktype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_scan_time;
        break;
      }
      
      // optional double scan_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_scan_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scan_time_)));
          set_has_scan_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_versionNumber;
        break;
      }
      
      // optional string versionNumber = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_versionNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_versionnumber()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->versionnumber().data(), this->versionnumber().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_path;
        break;
      }
      
      // optional string path = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_status;
        break;
      }
      
      // optional int32 status = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(401)) goto parse_addtime;
        break;
      }
      
      // optional double addtime = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_addtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &addtime_)));
          set_has_addtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AntiVirusSoftWareInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_code(), output);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->checktype(), output);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->scan_time(), output);
  }
  
  // optional string versionNumber = 4;
  if (has_versionnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->versionnumber().data(), this->versionnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->versionnumber(), output);
  }
  
  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->path(), output);
  }
  
  // optional int32 status = 6;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->status(), output);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(50, this->addtime(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AntiVirusSoftWareInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string package_code = 1;
  if (has_package_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->package_code().data(), this->package_code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->package_code(), target);
  }
  
  // optional int32 checktype = 2;
  if (has_checktype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->checktype(), target);
  }
  
  // optional double scan_time = 3;
  if (has_scan_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->scan_time(), target);
  }
  
  // optional string versionNumber = 4;
  if (has_versionnumber()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->versionnumber().data(), this->versionnumber().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->versionnumber(), target);
  }
  
  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->path(), target);
  }
  
  // optional int32 status = 6;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->status(), target);
  }
  
  // optional double addtime = 50;
  if (has_addtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(50, this->addtime(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AntiVirusSoftWareInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string package_code = 1;
    if (has_package_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_code());
    }
    
    // optional int32 checktype = 2;
    if (has_checktype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checktype());
    }
    
    // optional double scan_time = 3;
    if (has_scan_time()) {
      total_size += 1 + 8;
    }
    
    // optional double addtime = 50;
    if (has_addtime()) {
      total_size += 2 + 8;
    }
    
    // optional string versionNumber = 4;
    if (has_versionnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->versionnumber());
    }
    
    // optional string path = 5;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }
    
    // optional int32 status = 6;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AntiVirusSoftWareInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AntiVirusSoftWareInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AntiVirusSoftWareInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AntiVirusSoftWareInfo::MergeFrom(const AntiVirusSoftWareInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_package_code()) {
      set_package_code(from.package_code());
    }
    if (from.has_checktype()) {
      set_checktype(from.checktype());
    }
    if (from.has_scan_time()) {
      set_scan_time(from.scan_time());
    }
    if (from.has_addtime()) {
      set_addtime(from.addtime());
    }
    if (from.has_versionnumber()) {
      set_versionnumber(from.versionnumber());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AntiVirusSoftWareInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AntiVirusSoftWareInfo::CopyFrom(const AntiVirusSoftWareInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntiVirusSoftWareInfo::IsInitialized() const {
  
  return true;
}

void AntiVirusSoftWareInfo::Swap(AntiVirusSoftWareInfo* other) {
  if (other != this) {
    std::swap(package_code_, other->package_code_);
    std::swap(checktype_, other->checktype_);
    std::swap(scan_time_, other->scan_time_);
    std::swap(addtime_, other->addtime_);
    std::swap(versionnumber_, other->versionnumber_);
    std::swap(path_, other->path_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AntiVirusSoftWareInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AntiVirusSoftWareInfo_descriptor_;
  metadata.reflection = AntiVirusSoftWareInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AntiVirusSoftWareInfoList::kListFieldNumber;
const int AntiVirusSoftWareInfoList::kAlarmedFieldNumber;
const int AntiVirusSoftWareInfoList::kWinuserFieldNumber;
#endif  // !_MSC_VER

AntiVirusSoftWareInfoList::AntiVirusSoftWareInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AntiVirusSoftWareInfoList::InitAsDefaultInstance() {
}

AntiVirusSoftWareInfoList::AntiVirusSoftWareInfoList(const AntiVirusSoftWareInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AntiVirusSoftWareInfoList::SharedCtor() {
  _cached_size_ = 0;
  alarmed_ = 0;
  winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AntiVirusSoftWareInfoList::~AntiVirusSoftWareInfoList() {
  SharedDtor();
}

void AntiVirusSoftWareInfoList::SharedDtor() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    delete winuser_;
  }
  if (this != default_instance_) {
  }
}

void AntiVirusSoftWareInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AntiVirusSoftWareInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AntiVirusSoftWareInfoList_descriptor_;
}

const AntiVirusSoftWareInfoList& AntiVirusSoftWareInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

AntiVirusSoftWareInfoList* AntiVirusSoftWareInfoList::default_instance_ = NULL;

AntiVirusSoftWareInfoList* AntiVirusSoftWareInfoList::New() const {
  return new AntiVirusSoftWareInfoList;
}

void AntiVirusSoftWareInfoList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    alarmed_ = 0;
    if (has_winuser()) {
      if (winuser_ != &::google::protobuf::internal::kEmptyString) {
        winuser_->clear();
      }
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AntiVirusSoftWareInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.AntiVirusSoftWareInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_alarmed;
        break;
      }
      
      // optional int32 alarmed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alarmed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alarmed_)));
          set_has_alarmed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_winuser;
        break;
      }
      
      // optional string winuser = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_winuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_winuser()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->winuser().data(), this->winuser().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AntiVirusSoftWareInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.AntiVirusSoftWareInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->alarmed(), output);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->winuser(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AntiVirusSoftWareInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.AntiVirusSoftWareInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  // optional int32 alarmed = 2;
  if (has_alarmed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->alarmed(), target);
  }
  
  // optional string winuser = 3;
  if (has_winuser()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->winuser().data(), this->winuser().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->winuser(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AntiVirusSoftWareInfoList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 alarmed = 2;
    if (has_alarmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alarmed());
    }
    
    // optional string winuser = 3;
    if (has_winuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->winuser());
    }
    
  }
  // repeated .isafetec.AntiVirusSoftWareInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AntiVirusSoftWareInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AntiVirusSoftWareInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AntiVirusSoftWareInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AntiVirusSoftWareInfoList::MergeFrom(const AntiVirusSoftWareInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_alarmed()) {
      set_alarmed(from.alarmed());
    }
    if (from.has_winuser()) {
      set_winuser(from.winuser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AntiVirusSoftWareInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AntiVirusSoftWareInfoList::CopyFrom(const AntiVirusSoftWareInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AntiVirusSoftWareInfoList::IsInitialized() const {
  
  return true;
}

void AntiVirusSoftWareInfoList::Swap(AntiVirusSoftWareInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(alarmed_, other->alarmed_);
    std::swap(winuser_, other->winuser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AntiVirusSoftWareInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AntiVirusSoftWareInfoList_descriptor_;
  metadata.reflection = AntiVirusSoftWareInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DisposeSoftInfo::kIdFieldNumber;
const int DisposeSoftInfo::kZipPacknameFieldNumber;
const int DisposeSoftInfo::kUnzipPathFieldNumber;
const int DisposeSoftInfo::kRunFileNameFieldNumber;
#endif  // !_MSC_VER

DisposeSoftInfo::DisposeSoftInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DisposeSoftInfo::InitAsDefaultInstance() {
}

DisposeSoftInfo::DisposeSoftInfo(const DisposeSoftInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DisposeSoftInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  zippackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  unzippath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  runfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisposeSoftInfo::~DisposeSoftInfo() {
  SharedDtor();
}

void DisposeSoftInfo::SharedDtor() {
  if (zippackname_ != &::google::protobuf::internal::kEmptyString) {
    delete zippackname_;
  }
  if (unzippath_ != &::google::protobuf::internal::kEmptyString) {
    delete unzippath_;
  }
  if (runfilename_ != &::google::protobuf::internal::kEmptyString) {
    delete runfilename_;
  }
  if (this != default_instance_) {
  }
}

void DisposeSoftInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisposeSoftInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisposeSoftInfo_descriptor_;
}

const DisposeSoftInfo& DisposeSoftInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DisposeSoftInfo* DisposeSoftInfo::default_instance_ = NULL;

DisposeSoftInfo* DisposeSoftInfo::New() const {
  return new DisposeSoftInfo;
}

void DisposeSoftInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_zippackname()) {
      if (zippackname_ != &::google::protobuf::internal::kEmptyString) {
        zippackname_->clear();
      }
    }
    if (has_unzippath()) {
      if (unzippath_ != &::google::protobuf::internal::kEmptyString) {
        unzippath_->clear();
      }
    }
    if (has_runfilename()) {
      if (runfilename_ != &::google::protobuf::internal::kEmptyString) {
        runfilename_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DisposeSoftInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_zipPackname;
        break;
      }
      
      // optional string zipPackname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_zipPackname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_zippackname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->zippackname().data(), this->zippackname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_unzipPath;
        break;
      }
      
      // optional string unzipPath = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_unzipPath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unzippath()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->unzippath().data(), this->unzippath().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_runFileName;
        break;
      }
      
      // optional string runFileName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_runFileName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_runfilename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->runfilename().data(), this->runfilename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DisposeSoftInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // optional string zipPackname = 2;
  if (has_zippackname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->zippackname().data(), this->zippackname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->zippackname(), output);
  }
  
  // optional string unzipPath = 3;
  if (has_unzippath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->unzippath().data(), this->unzippath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->unzippath(), output);
  }
  
  // optional string runFileName = 4;
  if (has_runfilename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->runfilename().data(), this->runfilename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->runfilename(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DisposeSoftInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // optional string zipPackname = 2;
  if (has_zippackname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->zippackname().data(), this->zippackname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->zippackname(), target);
  }
  
  // optional string unzipPath = 3;
  if (has_unzippath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->unzippath().data(), this->unzippath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->unzippath(), target);
  }
  
  // optional string runFileName = 4;
  if (has_runfilename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->runfilename().data(), this->runfilename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->runfilename(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DisposeSoftInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // optional string zipPackname = 2;
    if (has_zippackname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->zippackname());
    }
    
    // optional string unzipPath = 3;
    if (has_unzippath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unzippath());
    }
    
    // optional string runFileName = 4;
    if (has_runfilename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->runfilename());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisposeSoftInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DisposeSoftInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DisposeSoftInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DisposeSoftInfo::MergeFrom(const DisposeSoftInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_zippackname()) {
      set_zippackname(from.zippackname());
    }
    if (from.has_unzippath()) {
      set_unzippath(from.unzippath());
    }
    if (from.has_runfilename()) {
      set_runfilename(from.runfilename());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DisposeSoftInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisposeSoftInfo::CopyFrom(const DisposeSoftInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisposeSoftInfo::IsInitialized() const {
  
  return true;
}

void DisposeSoftInfo::Swap(DisposeSoftInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(zippackname_, other->zippackname_);
    std::swap(unzippath_, other->unzippath_);
    std::swap(runfilename_, other->runfilename_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DisposeSoftInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisposeSoftInfo_descriptor_;
  metadata.reflection = DisposeSoftInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DisposeSoftInfoList::kListFieldNumber;
#endif  // !_MSC_VER

DisposeSoftInfoList::DisposeSoftInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DisposeSoftInfoList::InitAsDefaultInstance() {
}

DisposeSoftInfoList::DisposeSoftInfoList(const DisposeSoftInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DisposeSoftInfoList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisposeSoftInfoList::~DisposeSoftInfoList() {
  SharedDtor();
}

void DisposeSoftInfoList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DisposeSoftInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisposeSoftInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisposeSoftInfoList_descriptor_;
}

const DisposeSoftInfoList& DisposeSoftInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_appmessage_2eproto();  return *default_instance_;
}

DisposeSoftInfoList* DisposeSoftInfoList::default_instance_ = NULL;

DisposeSoftInfoList* DisposeSoftInfoList::New() const {
  return new DisposeSoftInfoList;
}

void DisposeSoftInfoList::Clear() {
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DisposeSoftInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .isafetec.DisposeSoftInfo list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DisposeSoftInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .isafetec.DisposeSoftInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DisposeSoftInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .isafetec.DisposeSoftInfo list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DisposeSoftInfoList::ByteSize() const {
  int total_size = 0;
  
  // repeated .isafetec.DisposeSoftInfo list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisposeSoftInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DisposeSoftInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DisposeSoftInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DisposeSoftInfoList::MergeFrom(const DisposeSoftInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DisposeSoftInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisposeSoftInfoList::CopyFrom(const DisposeSoftInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisposeSoftInfoList::IsInitialized() const {
  
  return true;
}

void DisposeSoftInfoList::Swap(DisposeSoftInfoList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DisposeSoftInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisposeSoftInfoList_descriptor_;
  metadata.reflection = DisposeSoftInfoList_reflection_;
  return metadata;
}

// CPUInfo

// optional string package_code = 1;
inline bool CPUInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPUInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPUInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPUInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& CPUInfo::package_code() const {
  return *package_code_;
}
inline void CPUInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void CPUInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void CPUInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* CPUInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool CPUInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPUInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPUInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 CPUInfo::checktype() const {
  return checktype_;
}
inline void CPUInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool CPUInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPUInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPUInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPUInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double CPUInfo::scan_time() const {
  return scan_time_;
}
inline void CPUInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool CPUInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPUInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPUInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPUInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double CPUInfo::addtime() const {
  return addtime_;
}
inline void CPUInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 Architecture = 4;
inline bool CPUInfo::has_architecture() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CPUInfo::set_has_architecture() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CPUInfo::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CPUInfo::clear_architecture() {
  architecture_ = 0;
  clear_has_architecture();
}
inline ::google::protobuf::int32 CPUInfo::architecture() const {
  return architecture_;
}
inline void CPUInfo::set_architecture(::google::protobuf::int32 value) {
  set_has_architecture();
  architecture_ = value;
}

// optional int32 Availability = 5;
inline bool CPUInfo::has_availability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CPUInfo::set_has_availability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CPUInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CPUInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 CPUInfo::availability() const {
  return availability_;
}
inline void CPUInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 CurrentClockSpeed = 6;
inline bool CPUInfo::has_currentclockspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CPUInfo::set_has_currentclockspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CPUInfo::clear_has_currentclockspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CPUInfo::clear_currentclockspeed() {
  currentclockspeed_ = 0;
  clear_has_currentclockspeed();
}
inline ::google::protobuf::int32 CPUInfo::currentclockspeed() const {
  return currentclockspeed_;
}
inline void CPUInfo::set_currentclockspeed(::google::protobuf::int32 value) {
  set_has_currentclockspeed();
  currentclockspeed_ = value;
}

// optional int32 CurrentVoltage = 7;
inline bool CPUInfo::has_currentvoltage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CPUInfo::set_has_currentvoltage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CPUInfo::clear_has_currentvoltage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CPUInfo::clear_currentvoltage() {
  currentvoltage_ = 0;
  clear_has_currentvoltage();
}
inline ::google::protobuf::int32 CPUInfo::currentvoltage() const {
  return currentvoltage_;
}
inline void CPUInfo::set_currentvoltage(::google::protobuf::int32 value) {
  set_has_currentvoltage();
  currentvoltage_ = value;
}

// optional int32 DataWidth = 8;
inline bool CPUInfo::has_datawidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CPUInfo::set_has_datawidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CPUInfo::clear_has_datawidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CPUInfo::clear_datawidth() {
  datawidth_ = 0;
  clear_has_datawidth();
}
inline ::google::protobuf::int32 CPUInfo::datawidth() const {
  return datawidth_;
}
inline void CPUInfo::set_datawidth(::google::protobuf::int32 value) {
  set_has_datawidth();
  datawidth_ = value;
}

// optional int32 ExtClock = 9;
inline bool CPUInfo::has_extclock() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CPUInfo::set_has_extclock() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CPUInfo::clear_has_extclock() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CPUInfo::clear_extclock() {
  extclock_ = 0;
  clear_has_extclock();
}
inline ::google::protobuf::int32 CPUInfo::extclock() const {
  return extclock_;
}
inline void CPUInfo::set_extclock(::google::protobuf::int32 value) {
  set_has_extclock();
  extclock_ = value;
}

// optional int32 Family = 10;
inline bool CPUInfo::has_family() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CPUInfo::set_has_family() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CPUInfo::clear_has_family() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CPUInfo::clear_family() {
  family_ = 0;
  clear_has_family();
}
inline ::google::protobuf::int32 CPUInfo::family() const {
  return family_;
}
inline void CPUInfo::set_family(::google::protobuf::int32 value) {
  set_has_family();
  family_ = value;
}

// optional int32 L2CacheSpeed = 11;
inline bool CPUInfo::has_l2cachespeed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CPUInfo::set_has_l2cachespeed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CPUInfo::clear_has_l2cachespeed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CPUInfo::clear_l2cachespeed() {
  l2cachespeed_ = 0;
  clear_has_l2cachespeed();
}
inline ::google::protobuf::int32 CPUInfo::l2cachespeed() const {
  return l2cachespeed_;
}
inline void CPUInfo::set_l2cachespeed(::google::protobuf::int32 value) {
  set_has_l2cachespeed();
  l2cachespeed_ = value;
}

// optional int32 L3CacheSize = 12;
inline bool CPUInfo::has_l3cachesize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CPUInfo::set_has_l3cachesize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CPUInfo::clear_has_l3cachesize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CPUInfo::clear_l3cachesize() {
  l3cachesize_ = 0;
  clear_has_l3cachesize();
}
inline ::google::protobuf::int32 CPUInfo::l3cachesize() const {
  return l3cachesize_;
}
inline void CPUInfo::set_l3cachesize(::google::protobuf::int32 value) {
  set_has_l3cachesize();
  l3cachesize_ = value;
}

// optional int32 L3CacheSpeed = 13;
inline bool CPUInfo::has_l3cachespeed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CPUInfo::set_has_l3cachespeed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CPUInfo::clear_has_l3cachespeed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CPUInfo::clear_l3cachespeed() {
  l3cachespeed_ = 0;
  clear_has_l3cachespeed();
}
inline ::google::protobuf::int32 CPUInfo::l3cachespeed() const {
  return l3cachespeed_;
}
inline void CPUInfo::set_l3cachespeed(::google::protobuf::int32 value) {
  set_has_l3cachespeed();
  l3cachespeed_ = value;
}

// optional int32 MaxClockSpeed = 14;
inline bool CPUInfo::has_maxclockspeed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CPUInfo::set_has_maxclockspeed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CPUInfo::clear_has_maxclockspeed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CPUInfo::clear_maxclockspeed() {
  maxclockspeed_ = 0;
  clear_has_maxclockspeed();
}
inline ::google::protobuf::int32 CPUInfo::maxclockspeed() const {
  return maxclockspeed_;
}
inline void CPUInfo::set_maxclockspeed(::google::protobuf::int32 value) {
  set_has_maxclockspeed();
  maxclockspeed_ = value;
}

// optional int32 LoadPercentage = 15;
inline bool CPUInfo::has_loadpercentage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CPUInfo::set_has_loadpercentage() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CPUInfo::clear_has_loadpercentage() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CPUInfo::clear_loadpercentage() {
  loadpercentage_ = 0;
  clear_has_loadpercentage();
}
inline ::google::protobuf::int32 CPUInfo::loadpercentage() const {
  return loadpercentage_;
}
inline void CPUInfo::set_loadpercentage(::google::protobuf::int32 value) {
  set_has_loadpercentage();
  loadpercentage_ = value;
}

// optional int32 ProcessorType = 16;
inline bool CPUInfo::has_processortype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CPUInfo::set_has_processortype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CPUInfo::clear_has_processortype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CPUInfo::clear_processortype() {
  processortype_ = 0;
  clear_has_processortype();
}
inline ::google::protobuf::int32 CPUInfo::processortype() const {
  return processortype_;
}
inline void CPUInfo::set_processortype(::google::protobuf::int32 value) {
  set_has_processortype();
  processortype_ = value;
}

// optional int32 L2CacheSize = 17;
inline bool CPUInfo::has_l2cachesize() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CPUInfo::set_has_l2cachesize() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CPUInfo::clear_has_l2cachesize() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CPUInfo::clear_l2cachesize() {
  l2cachesize_ = 0;
  clear_has_l2cachesize();
}
inline ::google::protobuf::int32 CPUInfo::l2cachesize() const {
  return l2cachesize_;
}
inline void CPUInfo::set_l2cachesize(::google::protobuf::int32 value) {
  set_has_l2cachesize();
  l2cachesize_ = value;
}

// optional string Version = 18;
inline bool CPUInfo::has_version() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CPUInfo::set_has_version() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CPUInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CPUInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CPUInfo::version() const {
  return *version_;
}
inline void CPUInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CPUInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CPUInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CPUInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 19;
inline bool CPUInfo::has_description() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CPUInfo::set_has_description() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CPUInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CPUInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CPUInfo::description() const {
  return *description_;
}
inline void CPUInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CPUInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CPUInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CPUInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 AddressWidth = 20;
inline bool CPUInfo::has_addresswidth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CPUInfo::set_has_addresswidth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CPUInfo::clear_has_addresswidth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CPUInfo::clear_addresswidth() {
  addresswidth_ = 0;
  clear_has_addresswidth();
}
inline ::google::protobuf::int32 CPUInfo::addresswidth() const {
  return addresswidth_;
}
inline void CPUInfo::set_addresswidth(::google::protobuf::int32 value) {
  set_has_addresswidth();
  addresswidth_ = value;
}

// optional string Manufacturer = 21;
inline bool CPUInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CPUInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CPUInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CPUInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& CPUInfo::manufacturer() const {
  return *manufacturer_;
}
inline void CPUInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CPUInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CPUInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* CPUInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 22;
inline bool CPUInfo::has_name() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CPUInfo::set_has_name() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CPUInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CPUInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CPUInfo::name() const {
  return *name_;
}
inline void CPUInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPUInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPUInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CPUInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ProcessorId = 23;
inline bool CPUInfo::has_processorid() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CPUInfo::set_has_processorid() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CPUInfo::clear_has_processorid() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CPUInfo::clear_processorid() {
  if (processorid_ != &::google::protobuf::internal::kEmptyString) {
    processorid_->clear();
  }
  clear_has_processorid();
}
inline const ::std::string& CPUInfo::processorid() const {
  return *processorid_;
}
inline void CPUInfo::set_processorid(const ::std::string& value) {
  set_has_processorid();
  if (processorid_ == &::google::protobuf::internal::kEmptyString) {
    processorid_ = new ::std::string;
  }
  processorid_->assign(value);
}
inline void CPUInfo::set_processorid(const char* value) {
  set_has_processorid();
  if (processorid_ == &::google::protobuf::internal::kEmptyString) {
    processorid_ = new ::std::string;
  }
  processorid_->assign(value);
}
inline void CPUInfo::set_processorid(const char* value, size_t size) {
  set_has_processorid();
  if (processorid_ == &::google::protobuf::internal::kEmptyString) {
    processorid_ = new ::std::string;
  }
  processorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_processorid() {
  set_has_processorid();
  if (processorid_ == &::google::protobuf::internal::kEmptyString) {
    processorid_ = new ::std::string;
  }
  return processorid_;
}
inline ::std::string* CPUInfo::release_processorid() {
  clear_has_processorid();
  if (processorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processorid_;
    processorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Role = 24;
inline bool CPUInfo::has_role() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CPUInfo::set_has_role() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CPUInfo::clear_has_role() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CPUInfo::clear_role() {
  if (role_ != &::google::protobuf::internal::kEmptyString) {
    role_->clear();
  }
  clear_has_role();
}
inline const ::std::string& CPUInfo::role() const {
  return *role_;
}
inline void CPUInfo::set_role(const ::std::string& value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void CPUInfo::set_role(const char* value) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void CPUInfo::set_role(const char* value, size_t size) {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_role() {
  set_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    role_ = new ::std::string;
  }
  return role_;
}
inline ::std::string* CPUInfo::release_role() {
  clear_has_role();
  if (role_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_;
    role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SocketDesignation = 25;
inline bool CPUInfo::has_socketdesignation() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CPUInfo::set_has_socketdesignation() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CPUInfo::clear_has_socketdesignation() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CPUInfo::clear_socketdesignation() {
  if (socketdesignation_ != &::google::protobuf::internal::kEmptyString) {
    socketdesignation_->clear();
  }
  clear_has_socketdesignation();
}
inline const ::std::string& CPUInfo::socketdesignation() const {
  return *socketdesignation_;
}
inline void CPUInfo::set_socketdesignation(const ::std::string& value) {
  set_has_socketdesignation();
  if (socketdesignation_ == &::google::protobuf::internal::kEmptyString) {
    socketdesignation_ = new ::std::string;
  }
  socketdesignation_->assign(value);
}
inline void CPUInfo::set_socketdesignation(const char* value) {
  set_has_socketdesignation();
  if (socketdesignation_ == &::google::protobuf::internal::kEmptyString) {
    socketdesignation_ = new ::std::string;
  }
  socketdesignation_->assign(value);
}
inline void CPUInfo::set_socketdesignation(const char* value, size_t size) {
  set_has_socketdesignation();
  if (socketdesignation_ == &::google::protobuf::internal::kEmptyString) {
    socketdesignation_ = new ::std::string;
  }
  socketdesignation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_socketdesignation() {
  set_has_socketdesignation();
  if (socketdesignation_ == &::google::protobuf::internal::kEmptyString) {
    socketdesignation_ = new ::std::string;
  }
  return socketdesignation_;
}
inline ::std::string* CPUInfo::release_socketdesignation() {
  clear_has_socketdesignation();
  if (socketdesignation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = socketdesignation_;
    socketdesignation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 26;
inline bool CPUInfo::has_status() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CPUInfo::set_has_status() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CPUInfo::clear_has_status() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CPUInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& CPUInfo::status() const {
  return *status_;
}
inline void CPUInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CPUInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CPUInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* CPUInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Stepping = 27;
inline bool CPUInfo::has_stepping() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CPUInfo::set_has_stepping() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CPUInfo::clear_has_stepping() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CPUInfo::clear_stepping() {
  if (stepping_ != &::google::protobuf::internal::kEmptyString) {
    stepping_->clear();
  }
  clear_has_stepping();
}
inline const ::std::string& CPUInfo::stepping() const {
  return *stepping_;
}
inline void CPUInfo::set_stepping(const ::std::string& value) {
  set_has_stepping();
  if (stepping_ == &::google::protobuf::internal::kEmptyString) {
    stepping_ = new ::std::string;
  }
  stepping_->assign(value);
}
inline void CPUInfo::set_stepping(const char* value) {
  set_has_stepping();
  if (stepping_ == &::google::protobuf::internal::kEmptyString) {
    stepping_ = new ::std::string;
  }
  stepping_->assign(value);
}
inline void CPUInfo::set_stepping(const char* value, size_t size) {
  set_has_stepping();
  if (stepping_ == &::google::protobuf::internal::kEmptyString) {
    stepping_ = new ::std::string;
  }
  stepping_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_stepping() {
  set_has_stepping();
  if (stepping_ == &::google::protobuf::internal::kEmptyString) {
    stepping_ = new ::std::string;
  }
  return stepping_;
}
inline ::std::string* CPUInfo::release_stepping() {
  clear_has_stepping();
  if (stepping_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stepping_;
    stepping_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double BuyTime = 28;
inline bool CPUInfo::has_buytime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CPUInfo::set_has_buytime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CPUInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CPUInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double CPUInfo::buytime() const {
  return buytime_;
}
inline void CPUInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 29;
inline bool CPUInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CPUInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CPUInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CPUInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& CPUInfo::buyprice() const {
  return *buyprice_;
}
inline void CPUInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void CPUInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void CPUInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* CPUInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 30;
inline bool CPUInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CPUInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CPUInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CPUInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double CPUInfo::dchecktime() const {
  return dchecktime_;
}
inline void CPUInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 31;
inline bool CPUInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CPUInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CPUInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CPUInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& CPUInfo::otherinfo() const {
  return *otherinfo_;
}
inline void CPUInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void CPUInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void CPUInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* CPUInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 32;
inline bool CPUInfo::has_buyname() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CPUInfo::set_has_buyname() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CPUInfo::clear_has_buyname() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CPUInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& CPUInfo::buyname() const {
  return *buyname_;
}
inline void CPUInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void CPUInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void CPUInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* CPUInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CPUInfoList

// repeated .isafetec.CPUInfo list = 1;
inline int CPUInfoList::list_size() const {
  return list_.size();
}
inline void CPUInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CPUInfo& CPUInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CPUInfo* CPUInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CPUInfo* CPUInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CPUInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CPUInfo* CPUInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CPUInfo >&
CPUInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CPUInfo >*
CPUInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool CPUInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPUInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPUInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPUInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 CPUInfoList::alarmed() const {
  return alarmed_;
}
inline void CPUInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool CPUInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPUInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPUInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPUInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& CPUInfoList::winuser() const {
  return *winuser_;
}
inline void CPUInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void CPUInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void CPUInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPUInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* CPUInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BIOSInfo

// optional string package_code = 1;
inline bool BIOSInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BIOSInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BIOSInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BIOSInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& BIOSInfo::package_code() const {
  return *package_code_;
}
inline void BIOSInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void BIOSInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void BIOSInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* BIOSInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool BIOSInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BIOSInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BIOSInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BIOSInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 BIOSInfo::checktype() const {
  return checktype_;
}
inline void BIOSInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool BIOSInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BIOSInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BIOSInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BIOSInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double BIOSInfo::scan_time() const {
  return scan_time_;
}
inline void BIOSInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool BIOSInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BIOSInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BIOSInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BIOSInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double BIOSInfo::addtime() const {
  return addtime_;
}
inline void BIOSInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 TargetOperatingSystem = 4;
inline bool BIOSInfo::has_targetoperatingsystem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BIOSInfo::set_has_targetoperatingsystem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BIOSInfo::clear_has_targetoperatingsystem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BIOSInfo::clear_targetoperatingsystem() {
  targetoperatingsystem_ = 0;
  clear_has_targetoperatingsystem();
}
inline ::google::protobuf::int32 BIOSInfo::targetoperatingsystem() const {
  return targetoperatingsystem_;
}
inline void BIOSInfo::set_targetoperatingsystem(::google::protobuf::int32 value) {
  set_has_targetoperatingsystem();
  targetoperatingsystem_ = value;
}

// optional int32 SoftwareElementState = 5;
inline bool BIOSInfo::has_softwareelementstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BIOSInfo::set_has_softwareelementstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BIOSInfo::clear_has_softwareelementstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BIOSInfo::clear_softwareelementstate() {
  softwareelementstate_ = 0;
  clear_has_softwareelementstate();
}
inline ::google::protobuf::int32 BIOSInfo::softwareelementstate() const {
  return softwareelementstate_;
}
inline void BIOSInfo::set_softwareelementstate(::google::protobuf::int32 value) {
  set_has_softwareelementstate();
  softwareelementstate_ = value;
}

// optional int32 PrimaryBIOS = 6;
inline bool BIOSInfo::has_primarybios() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BIOSInfo::set_has_primarybios() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BIOSInfo::clear_has_primarybios() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BIOSInfo::clear_primarybios() {
  primarybios_ = 0;
  clear_has_primarybios();
}
inline ::google::protobuf::int32 BIOSInfo::primarybios() const {
  return primarybios_;
}
inline void BIOSInfo::set_primarybios(::google::protobuf::int32 value) {
  set_has_primarybios();
  primarybios_ = value;
}

// optional int32 SMBIOSPresent = 7;
inline bool BIOSInfo::has_smbiospresent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BIOSInfo::set_has_smbiospresent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BIOSInfo::clear_has_smbiospresent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BIOSInfo::clear_smbiospresent() {
  smbiospresent_ = 0;
  clear_has_smbiospresent();
}
inline ::google::protobuf::int32 BIOSInfo::smbiospresent() const {
  return smbiospresent_;
}
inline void BIOSInfo::set_smbiospresent(::google::protobuf::int32 value) {
  set_has_smbiospresent();
  smbiospresent_ = value;
}

// optional string BuildNumber = 8;
inline bool BIOSInfo::has_buildnumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BIOSInfo::set_has_buildnumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BIOSInfo::clear_has_buildnumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BIOSInfo::clear_buildnumber() {
  if (buildnumber_ != &::google::protobuf::internal::kEmptyString) {
    buildnumber_->clear();
  }
  clear_has_buildnumber();
}
inline const ::std::string& BIOSInfo::buildnumber() const {
  return *buildnumber_;
}
inline void BIOSInfo::set_buildnumber(const ::std::string& value) {
  set_has_buildnumber();
  if (buildnumber_ == &::google::protobuf::internal::kEmptyString) {
    buildnumber_ = new ::std::string;
  }
  buildnumber_->assign(value);
}
inline void BIOSInfo::set_buildnumber(const char* value) {
  set_has_buildnumber();
  if (buildnumber_ == &::google::protobuf::internal::kEmptyString) {
    buildnumber_ = new ::std::string;
  }
  buildnumber_->assign(value);
}
inline void BIOSInfo::set_buildnumber(const char* value, size_t size) {
  set_has_buildnumber();
  if (buildnumber_ == &::google::protobuf::internal::kEmptyString) {
    buildnumber_ = new ::std::string;
  }
  buildnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_buildnumber() {
  set_has_buildnumber();
  if (buildnumber_ == &::google::protobuf::internal::kEmptyString) {
    buildnumber_ = new ::std::string;
  }
  return buildnumber_;
}
inline ::std::string* BIOSInfo::release_buildnumber() {
  clear_has_buildnumber();
  if (buildnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildnumber_;
    buildnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CodeSet = 9;
inline bool BIOSInfo::has_codeset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BIOSInfo::set_has_codeset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BIOSInfo::clear_has_codeset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BIOSInfo::clear_codeset() {
  if (codeset_ != &::google::protobuf::internal::kEmptyString) {
    codeset_->clear();
  }
  clear_has_codeset();
}
inline const ::std::string& BIOSInfo::codeset() const {
  return *codeset_;
}
inline void BIOSInfo::set_codeset(const ::std::string& value) {
  set_has_codeset();
  if (codeset_ == &::google::protobuf::internal::kEmptyString) {
    codeset_ = new ::std::string;
  }
  codeset_->assign(value);
}
inline void BIOSInfo::set_codeset(const char* value) {
  set_has_codeset();
  if (codeset_ == &::google::protobuf::internal::kEmptyString) {
    codeset_ = new ::std::string;
  }
  codeset_->assign(value);
}
inline void BIOSInfo::set_codeset(const char* value, size_t size) {
  set_has_codeset();
  if (codeset_ == &::google::protobuf::internal::kEmptyString) {
    codeset_ = new ::std::string;
  }
  codeset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_codeset() {
  set_has_codeset();
  if (codeset_ == &::google::protobuf::internal::kEmptyString) {
    codeset_ = new ::std::string;
  }
  return codeset_;
}
inline ::std::string* BIOSInfo::release_codeset() {
  clear_has_codeset();
  if (codeset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = codeset_;
    codeset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CurrentLanguage = 10;
inline bool BIOSInfo::has_currentlanguage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BIOSInfo::set_has_currentlanguage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BIOSInfo::clear_has_currentlanguage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BIOSInfo::clear_currentlanguage() {
  if (currentlanguage_ != &::google::protobuf::internal::kEmptyString) {
    currentlanguage_->clear();
  }
  clear_has_currentlanguage();
}
inline const ::std::string& BIOSInfo::currentlanguage() const {
  return *currentlanguage_;
}
inline void BIOSInfo::set_currentlanguage(const ::std::string& value) {
  set_has_currentlanguage();
  if (currentlanguage_ == &::google::protobuf::internal::kEmptyString) {
    currentlanguage_ = new ::std::string;
  }
  currentlanguage_->assign(value);
}
inline void BIOSInfo::set_currentlanguage(const char* value) {
  set_has_currentlanguage();
  if (currentlanguage_ == &::google::protobuf::internal::kEmptyString) {
    currentlanguage_ = new ::std::string;
  }
  currentlanguage_->assign(value);
}
inline void BIOSInfo::set_currentlanguage(const char* value, size_t size) {
  set_has_currentlanguage();
  if (currentlanguage_ == &::google::protobuf::internal::kEmptyString) {
    currentlanguage_ = new ::std::string;
  }
  currentlanguage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_currentlanguage() {
  set_has_currentlanguage();
  if (currentlanguage_ == &::google::protobuf::internal::kEmptyString) {
    currentlanguage_ = new ::std::string;
  }
  return currentlanguage_;
}
inline ::std::string* BIOSInfo::release_currentlanguage() {
  clear_has_currentlanguage();
  if (currentlanguage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentlanguage_;
    currentlanguage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 11;
inline bool BIOSInfo::has_description() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BIOSInfo::set_has_description() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BIOSInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BIOSInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& BIOSInfo::description() const {
  return *description_;
}
inline void BIOSInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BIOSInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BIOSInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* BIOSInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IdentificationCode = 12;
inline bool BIOSInfo::has_identificationcode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BIOSInfo::set_has_identificationcode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BIOSInfo::clear_has_identificationcode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BIOSInfo::clear_identificationcode() {
  if (identificationcode_ != &::google::protobuf::internal::kEmptyString) {
    identificationcode_->clear();
  }
  clear_has_identificationcode();
}
inline const ::std::string& BIOSInfo::identificationcode() const {
  return *identificationcode_;
}
inline void BIOSInfo::set_identificationcode(const ::std::string& value) {
  set_has_identificationcode();
  if (identificationcode_ == &::google::protobuf::internal::kEmptyString) {
    identificationcode_ = new ::std::string;
  }
  identificationcode_->assign(value);
}
inline void BIOSInfo::set_identificationcode(const char* value) {
  set_has_identificationcode();
  if (identificationcode_ == &::google::protobuf::internal::kEmptyString) {
    identificationcode_ = new ::std::string;
  }
  identificationcode_->assign(value);
}
inline void BIOSInfo::set_identificationcode(const char* value, size_t size) {
  set_has_identificationcode();
  if (identificationcode_ == &::google::protobuf::internal::kEmptyString) {
    identificationcode_ = new ::std::string;
  }
  identificationcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_identificationcode() {
  set_has_identificationcode();
  if (identificationcode_ == &::google::protobuf::internal::kEmptyString) {
    identificationcode_ = new ::std::string;
  }
  return identificationcode_;
}
inline ::std::string* BIOSInfo::release_identificationcode() {
  clear_has_identificationcode();
  if (identificationcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identificationcode_;
    identificationcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string LanguageEdition = 13;
inline bool BIOSInfo::has_languageedition() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BIOSInfo::set_has_languageedition() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BIOSInfo::clear_has_languageedition() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BIOSInfo::clear_languageedition() {
  if (languageedition_ != &::google::protobuf::internal::kEmptyString) {
    languageedition_->clear();
  }
  clear_has_languageedition();
}
inline const ::std::string& BIOSInfo::languageedition() const {
  return *languageedition_;
}
inline void BIOSInfo::set_languageedition(const ::std::string& value) {
  set_has_languageedition();
  if (languageedition_ == &::google::protobuf::internal::kEmptyString) {
    languageedition_ = new ::std::string;
  }
  languageedition_->assign(value);
}
inline void BIOSInfo::set_languageedition(const char* value) {
  set_has_languageedition();
  if (languageedition_ == &::google::protobuf::internal::kEmptyString) {
    languageedition_ = new ::std::string;
  }
  languageedition_->assign(value);
}
inline void BIOSInfo::set_languageedition(const char* value, size_t size) {
  set_has_languageedition();
  if (languageedition_ == &::google::protobuf::internal::kEmptyString) {
    languageedition_ = new ::std::string;
  }
  languageedition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_languageedition() {
  set_has_languageedition();
  if (languageedition_ == &::google::protobuf::internal::kEmptyString) {
    languageedition_ = new ::std::string;
  }
  return languageedition_;
}
inline ::std::string* BIOSInfo::release_languageedition() {
  clear_has_languageedition();
  if (languageedition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = languageedition_;
    languageedition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 14;
inline bool BIOSInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BIOSInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BIOSInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BIOSInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& BIOSInfo::manufacturer() const {
  return *manufacturer_;
}
inline void BIOSInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void BIOSInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void BIOSInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* BIOSInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OtherTargetOS = 15;
inline bool BIOSInfo::has_othertargetos() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BIOSInfo::set_has_othertargetos() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BIOSInfo::clear_has_othertargetos() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BIOSInfo::clear_othertargetos() {
  if (othertargetos_ != &::google::protobuf::internal::kEmptyString) {
    othertargetos_->clear();
  }
  clear_has_othertargetos();
}
inline const ::std::string& BIOSInfo::othertargetos() const {
  return *othertargetos_;
}
inline void BIOSInfo::set_othertargetos(const ::std::string& value) {
  set_has_othertargetos();
  if (othertargetos_ == &::google::protobuf::internal::kEmptyString) {
    othertargetos_ = new ::std::string;
  }
  othertargetos_->assign(value);
}
inline void BIOSInfo::set_othertargetos(const char* value) {
  set_has_othertargetos();
  if (othertargetos_ == &::google::protobuf::internal::kEmptyString) {
    othertargetos_ = new ::std::string;
  }
  othertargetos_->assign(value);
}
inline void BIOSInfo::set_othertargetos(const char* value, size_t size) {
  set_has_othertargetos();
  if (othertargetos_ == &::google::protobuf::internal::kEmptyString) {
    othertargetos_ = new ::std::string;
  }
  othertargetos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_othertargetos() {
  set_has_othertargetos();
  if (othertargetos_ == &::google::protobuf::internal::kEmptyString) {
    othertargetos_ = new ::std::string;
  }
  return othertargetos_;
}
inline ::std::string* BIOSInfo::release_othertargetos() {
  clear_has_othertargetos();
  if (othertargetos_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = othertargetos_;
    othertargetos_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNumber = 16;
inline bool BIOSInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BIOSInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BIOSInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BIOSInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& BIOSInfo::serialnumber() const {
  return *serialnumber_;
}
inline void BIOSInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void BIOSInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void BIOSInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* BIOSInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SMBIOSBIOSVersion = 17;
inline bool BIOSInfo::has_smbiosbiosversion() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BIOSInfo::set_has_smbiosbiosversion() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BIOSInfo::clear_has_smbiosbiosversion() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BIOSInfo::clear_smbiosbiosversion() {
  if (smbiosbiosversion_ != &::google::protobuf::internal::kEmptyString) {
    smbiosbiosversion_->clear();
  }
  clear_has_smbiosbiosversion();
}
inline const ::std::string& BIOSInfo::smbiosbiosversion() const {
  return *smbiosbiosversion_;
}
inline void BIOSInfo::set_smbiosbiosversion(const ::std::string& value) {
  set_has_smbiosbiosversion();
  if (smbiosbiosversion_ == &::google::protobuf::internal::kEmptyString) {
    smbiosbiosversion_ = new ::std::string;
  }
  smbiosbiosversion_->assign(value);
}
inline void BIOSInfo::set_smbiosbiosversion(const char* value) {
  set_has_smbiosbiosversion();
  if (smbiosbiosversion_ == &::google::protobuf::internal::kEmptyString) {
    smbiosbiosversion_ = new ::std::string;
  }
  smbiosbiosversion_->assign(value);
}
inline void BIOSInfo::set_smbiosbiosversion(const char* value, size_t size) {
  set_has_smbiosbiosversion();
  if (smbiosbiosversion_ == &::google::protobuf::internal::kEmptyString) {
    smbiosbiosversion_ = new ::std::string;
  }
  smbiosbiosversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_smbiosbiosversion() {
  set_has_smbiosbiosversion();
  if (smbiosbiosversion_ == &::google::protobuf::internal::kEmptyString) {
    smbiosbiosversion_ = new ::std::string;
  }
  return smbiosbiosversion_;
}
inline ::std::string* BIOSInfo::release_smbiosbiosversion() {
  clear_has_smbiosbiosversion();
  if (smbiosbiosversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = smbiosbiosversion_;
    smbiosbiosversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SoftwareElementID = 18;
inline bool BIOSInfo::has_softwareelementid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BIOSInfo::set_has_softwareelementid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BIOSInfo::clear_has_softwareelementid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BIOSInfo::clear_softwareelementid() {
  if (softwareelementid_ != &::google::protobuf::internal::kEmptyString) {
    softwareelementid_->clear();
  }
  clear_has_softwareelementid();
}
inline const ::std::string& BIOSInfo::softwareelementid() const {
  return *softwareelementid_;
}
inline void BIOSInfo::set_softwareelementid(const ::std::string& value) {
  set_has_softwareelementid();
  if (softwareelementid_ == &::google::protobuf::internal::kEmptyString) {
    softwareelementid_ = new ::std::string;
  }
  softwareelementid_->assign(value);
}
inline void BIOSInfo::set_softwareelementid(const char* value) {
  set_has_softwareelementid();
  if (softwareelementid_ == &::google::protobuf::internal::kEmptyString) {
    softwareelementid_ = new ::std::string;
  }
  softwareelementid_->assign(value);
}
inline void BIOSInfo::set_softwareelementid(const char* value, size_t size) {
  set_has_softwareelementid();
  if (softwareelementid_ == &::google::protobuf::internal::kEmptyString) {
    softwareelementid_ = new ::std::string;
  }
  softwareelementid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_softwareelementid() {
  set_has_softwareelementid();
  if (softwareelementid_ == &::google::protobuf::internal::kEmptyString) {
    softwareelementid_ = new ::std::string;
  }
  return softwareelementid_;
}
inline ::std::string* BIOSInfo::release_softwareelementid() {
  clear_has_softwareelementid();
  if (softwareelementid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = softwareelementid_;
    softwareelementid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 19;
inline bool BIOSInfo::has_status() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BIOSInfo::set_has_status() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BIOSInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BIOSInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& BIOSInfo::status() const {
  return *status_;
}
inline void BIOSInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void BIOSInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void BIOSInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* BIOSInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Version = 20;
inline bool BIOSInfo::has_version() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BIOSInfo::set_has_version() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BIOSInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BIOSInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& BIOSInfo::version() const {
  return *version_;
}
inline void BIOSInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void BIOSInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void BIOSInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* BIOSInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 SMBIOSMajorVersion = 21;
inline bool BIOSInfo::has_smbiosmajorversion() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BIOSInfo::set_has_smbiosmajorversion() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BIOSInfo::clear_has_smbiosmajorversion() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BIOSInfo::clear_smbiosmajorversion() {
  smbiosmajorversion_ = 0;
  clear_has_smbiosmajorversion();
}
inline ::google::protobuf::int32 BIOSInfo::smbiosmajorversion() const {
  return smbiosmajorversion_;
}
inline void BIOSInfo::set_smbiosmajorversion(::google::protobuf::int32 value) {
  set_has_smbiosmajorversion();
  smbiosmajorversion_ = value;
}

// optional int32 SMBIOSMinorVersion = 22;
inline bool BIOSInfo::has_smbiosminorversion() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BIOSInfo::set_has_smbiosminorversion() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BIOSInfo::clear_has_smbiosminorversion() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BIOSInfo::clear_smbiosminorversion() {
  smbiosminorversion_ = 0;
  clear_has_smbiosminorversion();
}
inline ::google::protobuf::int32 BIOSInfo::smbiosminorversion() const {
  return smbiosminorversion_;
}
inline void BIOSInfo::set_smbiosminorversion(::google::protobuf::int32 value) {
  set_has_smbiosminorversion();
  smbiosminorversion_ = value;
}

// optional double BuyTime = 23;
inline bool BIOSInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BIOSInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BIOSInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BIOSInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double BIOSInfo::buytime() const {
  return buytime_;
}
inline void BIOSInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 24;
inline bool BIOSInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BIOSInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BIOSInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BIOSInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& BIOSInfo::buyprice() const {
  return *buyprice_;
}
inline void BIOSInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void BIOSInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void BIOSInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* BIOSInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 25;
inline bool BIOSInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BIOSInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BIOSInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BIOSInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double BIOSInfo::dchecktime() const {
  return dchecktime_;
}
inline void BIOSInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 26;
inline bool BIOSInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BIOSInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BIOSInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BIOSInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& BIOSInfo::otherinfo() const {
  return *otherinfo_;
}
inline void BIOSInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void BIOSInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void BIOSInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* BIOSInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 27;
inline bool BIOSInfo::has_buyname() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BIOSInfo::set_has_buyname() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BIOSInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BIOSInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& BIOSInfo::buyname() const {
  return *buyname_;
}
inline void BIOSInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void BIOSInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void BIOSInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* BIOSInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BIOSInfoList

// repeated .isafetec.BIOSInfo list = 1;
inline int BIOSInfoList::list_size() const {
  return list_.size();
}
inline void BIOSInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::BIOSInfo& BIOSInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::BIOSInfo* BIOSInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::BIOSInfo* BIOSInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void BIOSInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::BIOSInfo* BIOSInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::BIOSInfo >&
BIOSInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::BIOSInfo >*
BIOSInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool BIOSInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BIOSInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BIOSInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BIOSInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 BIOSInfoList::alarmed() const {
  return alarmed_;
}
inline void BIOSInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool BIOSInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BIOSInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BIOSInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BIOSInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& BIOSInfoList::winuser() const {
  return *winuser_;
}
inline void BIOSInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void BIOSInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void BIOSInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BIOSInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* BIOSInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CDRomDriveInfo

// optional string package_code = 1;
inline bool CDRomDriveInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDRomDriveInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDRomDriveInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDRomDriveInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& CDRomDriveInfo::package_code() const {
  return *package_code_;
}
inline void CDRomDriveInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void CDRomDriveInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void CDRomDriveInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* CDRomDriveInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool CDRomDriveInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDRomDriveInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDRomDriveInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDRomDriveInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 CDRomDriveInfo::checktype() const {
  return checktype_;
}
inline void CDRomDriveInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool CDRomDriveInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDRomDriveInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDRomDriveInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDRomDriveInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double CDRomDriveInfo::scan_time() const {
  return scan_time_;
}
inline void CDRomDriveInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool CDRomDriveInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CDRomDriveInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CDRomDriveInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CDRomDriveInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double CDRomDriveInfo::addtime() const {
  return addtime_;
}
inline void CDRomDriveInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 FileSystemFlagsEx = 4;
inline bool CDRomDriveInfo::has_filesystemflagsex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CDRomDriveInfo::set_has_filesystemflagsex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CDRomDriveInfo::clear_has_filesystemflagsex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CDRomDriveInfo::clear_filesystemflagsex() {
  filesystemflagsex_ = 0;
  clear_has_filesystemflagsex();
}
inline ::google::protobuf::int32 CDRomDriveInfo::filesystemflagsex() const {
  return filesystemflagsex_;
}
inline void CDRomDriveInfo::set_filesystemflagsex(::google::protobuf::int32 value) {
  set_has_filesystemflagsex();
  filesystemflagsex_ = value;
}

// optional uint64 MaxBlockSize = 5;
inline bool CDRomDriveInfo::has_maxblocksize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CDRomDriveInfo::set_has_maxblocksize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CDRomDriveInfo::clear_has_maxblocksize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CDRomDriveInfo::clear_maxblocksize() {
  maxblocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxblocksize();
}
inline ::google::protobuf::uint64 CDRomDriveInfo::maxblocksize() const {
  return maxblocksize_;
}
inline void CDRomDriveInfo::set_maxblocksize(::google::protobuf::uint64 value) {
  set_has_maxblocksize();
  maxblocksize_ = value;
}

// optional int32 MaximumComponentLength = 6;
inline bool CDRomDriveInfo::has_maximumcomponentlength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CDRomDriveInfo::set_has_maximumcomponentlength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CDRomDriveInfo::clear_has_maximumcomponentlength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CDRomDriveInfo::clear_maximumcomponentlength() {
  maximumcomponentlength_ = 0;
  clear_has_maximumcomponentlength();
}
inline ::google::protobuf::int32 CDRomDriveInfo::maximumcomponentlength() const {
  return maximumcomponentlength_;
}
inline void CDRomDriveInfo::set_maximumcomponentlength(::google::protobuf::int32 value) {
  set_has_maximumcomponentlength();
  maximumcomponentlength_ = value;
}

// optional uint64 MaxMediaSize = 7;
inline bool CDRomDriveInfo::has_maxmediasize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CDRomDriveInfo::set_has_maxmediasize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CDRomDriveInfo::clear_has_maxmediasize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CDRomDriveInfo::clear_maxmediasize() {
  maxmediasize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxmediasize();
}
inline ::google::protobuf::uint64 CDRomDriveInfo::maxmediasize() const {
  return maxmediasize_;
}
inline void CDRomDriveInfo::set_maxmediasize(::google::protobuf::uint64 value) {
  set_has_maxmediasize();
  maxmediasize_ = value;
}

// optional uint64 MinBlockSize = 8;
inline bool CDRomDriveInfo::has_minblocksize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CDRomDriveInfo::set_has_minblocksize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CDRomDriveInfo::clear_has_minblocksize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CDRomDriveInfo::clear_minblocksize() {
  minblocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_minblocksize();
}
inline ::google::protobuf::uint64 CDRomDriveInfo::minblocksize() const {
  return minblocksize_;
}
inline void CDRomDriveInfo::set_minblocksize(::google::protobuf::uint64 value) {
  set_has_minblocksize();
  minblocksize_ = value;
}

// optional int32 NumberOfMediaSupported = 9;
inline bool CDRomDriveInfo::has_numberofmediasupported() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CDRomDriveInfo::set_has_numberofmediasupported() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CDRomDriveInfo::clear_has_numberofmediasupported() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CDRomDriveInfo::clear_numberofmediasupported() {
  numberofmediasupported_ = 0;
  clear_has_numberofmediasupported();
}
inline ::google::protobuf::int32 CDRomDriveInfo::numberofmediasupported() const {
  return numberofmediasupported_;
}
inline void CDRomDriveInfo::set_numberofmediasupported(::google::protobuf::int32 value) {
  set_has_numberofmediasupported();
  numberofmediasupported_ = value;
}

// optional int32 SCSIBus = 10;
inline bool CDRomDriveInfo::has_scsibus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CDRomDriveInfo::set_has_scsibus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CDRomDriveInfo::clear_has_scsibus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CDRomDriveInfo::clear_scsibus() {
  scsibus_ = 0;
  clear_has_scsibus();
}
inline ::google::protobuf::int32 CDRomDriveInfo::scsibus() const {
  return scsibus_;
}
inline void CDRomDriveInfo::set_scsibus(::google::protobuf::int32 value) {
  set_has_scsibus();
  scsibus_ = value;
}

// optional int32 SCSILogicalUnit = 11;
inline bool CDRomDriveInfo::has_scsilogicalunit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CDRomDriveInfo::set_has_scsilogicalunit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CDRomDriveInfo::clear_has_scsilogicalunit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CDRomDriveInfo::clear_scsilogicalunit() {
  scsilogicalunit_ = 0;
  clear_has_scsilogicalunit();
}
inline ::google::protobuf::int32 CDRomDriveInfo::scsilogicalunit() const {
  return scsilogicalunit_;
}
inline void CDRomDriveInfo::set_scsilogicalunit(::google::protobuf::int32 value) {
  set_has_scsilogicalunit();
  scsilogicalunit_ = value;
}

// optional int32 SCSIPort = 12;
inline bool CDRomDriveInfo::has_scsiport() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CDRomDriveInfo::set_has_scsiport() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CDRomDriveInfo::clear_has_scsiport() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CDRomDriveInfo::clear_scsiport() {
  scsiport_ = 0;
  clear_has_scsiport();
}
inline ::google::protobuf::int32 CDRomDriveInfo::scsiport() const {
  return scsiport_;
}
inline void CDRomDriveInfo::set_scsiport(::google::protobuf::int32 value) {
  set_has_scsiport();
  scsiport_ = value;
}

// optional int32 SCSITargetId = 13;
inline bool CDRomDriveInfo::has_scsitargetid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CDRomDriveInfo::set_has_scsitargetid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CDRomDriveInfo::clear_has_scsitargetid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CDRomDriveInfo::clear_scsitargetid() {
  scsitargetid_ = 0;
  clear_has_scsitargetid();
}
inline ::google::protobuf::int32 CDRomDriveInfo::scsitargetid() const {
  return scsitargetid_;
}
inline void CDRomDriveInfo::set_scsitargetid(::google::protobuf::int32 value) {
  set_has_scsitargetid();
  scsitargetid_ = value;
}

// optional int32 SerialNumber = 14;
inline bool CDRomDriveInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CDRomDriveInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CDRomDriveInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CDRomDriveInfo::clear_serialnumber() {
  serialnumber_ = 0;
  clear_has_serialnumber();
}
inline ::google::protobuf::int32 CDRomDriveInfo::serialnumber() const {
  return serialnumber_;
}
inline void CDRomDriveInfo::set_serialnumber(::google::protobuf::int32 value) {
  set_has_serialnumber();
  serialnumber_ = value;
}

// optional uint64 Size = 15;
inline bool CDRomDriveInfo::has_size() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CDRomDriveInfo::set_has_size() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CDRomDriveInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CDRomDriveInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 CDRomDriveInfo::size() const {
  return size_;
}
inline void CDRomDriveInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional int32 TransferRate = 17;
inline bool CDRomDriveInfo::has_transferrate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CDRomDriveInfo::set_has_transferrate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CDRomDriveInfo::clear_has_transferrate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CDRomDriveInfo::clear_transferrate() {
  transferrate_ = 0;
  clear_has_transferrate();
}
inline ::google::protobuf::int32 CDRomDriveInfo::transferrate() const {
  return transferrate_;
}
inline void CDRomDriveInfo::set_transferrate(::google::protobuf::int32 value) {
  set_has_transferrate();
  transferrate_ = value;
}

// optional int32 DriveIntegrity = 18;
inline bool CDRomDriveInfo::has_driveintegrity() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CDRomDriveInfo::set_has_driveintegrity() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CDRomDriveInfo::clear_has_driveintegrity() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CDRomDriveInfo::clear_driveintegrity() {
  driveintegrity_ = 0;
  clear_has_driveintegrity();
}
inline ::google::protobuf::int32 CDRomDriveInfo::driveintegrity() const {
  return driveintegrity_;
}
inline void CDRomDriveInfo::set_driveintegrity(::google::protobuf::int32 value) {
  set_has_driveintegrity();
  driveintegrity_ = value;
}

// optional int32 MediaLoaded = 19;
inline bool CDRomDriveInfo::has_medialoaded() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CDRomDriveInfo::set_has_medialoaded() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CDRomDriveInfo::clear_has_medialoaded() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CDRomDriveInfo::clear_medialoaded() {
  medialoaded_ = 0;
  clear_has_medialoaded();
}
inline ::google::protobuf::int32 CDRomDriveInfo::medialoaded() const {
  return medialoaded_;
}
inline void CDRomDriveInfo::set_medialoaded(::google::protobuf::int32 value) {
  set_has_medialoaded();
  medialoaded_ = value;
}

// optional int32 NeedsCleaning = 20;
inline bool CDRomDriveInfo::has_needscleaning() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CDRomDriveInfo::set_has_needscleaning() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CDRomDriveInfo::clear_has_needscleaning() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CDRomDriveInfo::clear_needscleaning() {
  needscleaning_ = 0;
  clear_has_needscleaning();
}
inline ::google::protobuf::int32 CDRomDriveInfo::needscleaning() const {
  return needscleaning_;
}
inline void CDRomDriveInfo::set_needscleaning(::google::protobuf::int32 value) {
  set_has_needscleaning();
  needscleaning_ = value;
}

// optional string CompressionMethod = 21;
inline bool CDRomDriveInfo::has_compressionmethod() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CDRomDriveInfo::set_has_compressionmethod() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CDRomDriveInfo::clear_has_compressionmethod() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CDRomDriveInfo::clear_compressionmethod() {
  if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
    compressionmethod_->clear();
  }
  clear_has_compressionmethod();
}
inline const ::std::string& CDRomDriveInfo::compressionmethod() const {
  return *compressionmethod_;
}
inline void CDRomDriveInfo::set_compressionmethod(const ::std::string& value) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(value);
}
inline void CDRomDriveInfo::set_compressionmethod(const char* value) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(value);
}
inline void CDRomDriveInfo::set_compressionmethod(const char* value, size_t size) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_compressionmethod() {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  return compressionmethod_;
}
inline ::std::string* CDRomDriveInfo::release_compressionmethod() {
  clear_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compressionmethod_;
    compressionmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 22;
inline bool CDRomDriveInfo::has_description() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CDRomDriveInfo::set_has_description() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CDRomDriveInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CDRomDriveInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CDRomDriveInfo::description() const {
  return *description_;
}
inline void CDRomDriveInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CDRomDriveInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CDRomDriveInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CDRomDriveInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Drive = 23;
inline bool CDRomDriveInfo::has_drive() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CDRomDriveInfo::set_has_drive() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CDRomDriveInfo::clear_has_drive() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CDRomDriveInfo::clear_drive() {
  if (drive_ != &::google::protobuf::internal::kEmptyString) {
    drive_->clear();
  }
  clear_has_drive();
}
inline const ::std::string& CDRomDriveInfo::drive() const {
  return *drive_;
}
inline void CDRomDriveInfo::set_drive(const ::std::string& value) {
  set_has_drive();
  if (drive_ == &::google::protobuf::internal::kEmptyString) {
    drive_ = new ::std::string;
  }
  drive_->assign(value);
}
inline void CDRomDriveInfo::set_drive(const char* value) {
  set_has_drive();
  if (drive_ == &::google::protobuf::internal::kEmptyString) {
    drive_ = new ::std::string;
  }
  drive_->assign(value);
}
inline void CDRomDriveInfo::set_drive(const char* value, size_t size) {
  set_has_drive();
  if (drive_ == &::google::protobuf::internal::kEmptyString) {
    drive_ = new ::std::string;
  }
  drive_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_drive() {
  set_has_drive();
  if (drive_ == &::google::protobuf::internal::kEmptyString) {
    drive_ = new ::std::string;
  }
  return drive_;
}
inline ::std::string* CDRomDriveInfo::release_drive() {
  clear_has_drive();
  if (drive_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = drive_;
    drive_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 24;
inline bool CDRomDriveInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CDRomDriveInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CDRomDriveInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CDRomDriveInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& CDRomDriveInfo::manufacturer() const {
  return *manufacturer_;
}
inline void CDRomDriveInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CDRomDriveInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void CDRomDriveInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* CDRomDriveInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MediaType = 25;
inline bool CDRomDriveInfo::has_mediatype() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CDRomDriveInfo::set_has_mediatype() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CDRomDriveInfo::clear_has_mediatype() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CDRomDriveInfo::clear_mediatype() {
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    mediatype_->clear();
  }
  clear_has_mediatype();
}
inline const ::std::string& CDRomDriveInfo::mediatype() const {
  return *mediatype_;
}
inline void CDRomDriveInfo::set_mediatype(const ::std::string& value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void CDRomDriveInfo::set_mediatype(const char* value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void CDRomDriveInfo::set_mediatype(const char* value, size_t size) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_mediatype() {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  return mediatype_;
}
inline ::std::string* CDRomDriveInfo::release_mediatype() {
  clear_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediatype_;
    mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 26;
inline bool CDRomDriveInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CDRomDriveInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CDRomDriveInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CDRomDriveInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& CDRomDriveInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void CDRomDriveInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void CDRomDriveInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void CDRomDriveInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* CDRomDriveInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RevisionLevel = 27;
inline bool CDRomDriveInfo::has_revisionlevel() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CDRomDriveInfo::set_has_revisionlevel() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CDRomDriveInfo::clear_has_revisionlevel() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CDRomDriveInfo::clear_revisionlevel() {
  if (revisionlevel_ != &::google::protobuf::internal::kEmptyString) {
    revisionlevel_->clear();
  }
  clear_has_revisionlevel();
}
inline const ::std::string& CDRomDriveInfo::revisionlevel() const {
  return *revisionlevel_;
}
inline void CDRomDriveInfo::set_revisionlevel(const ::std::string& value) {
  set_has_revisionlevel();
  if (revisionlevel_ == &::google::protobuf::internal::kEmptyString) {
    revisionlevel_ = new ::std::string;
  }
  revisionlevel_->assign(value);
}
inline void CDRomDriveInfo::set_revisionlevel(const char* value) {
  set_has_revisionlevel();
  if (revisionlevel_ == &::google::protobuf::internal::kEmptyString) {
    revisionlevel_ = new ::std::string;
  }
  revisionlevel_->assign(value);
}
inline void CDRomDriveInfo::set_revisionlevel(const char* value, size_t size) {
  set_has_revisionlevel();
  if (revisionlevel_ == &::google::protobuf::internal::kEmptyString) {
    revisionlevel_ = new ::std::string;
  }
  revisionlevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_revisionlevel() {
  set_has_revisionlevel();
  if (revisionlevel_ == &::google::protobuf::internal::kEmptyString) {
    revisionlevel_ = new ::std::string;
  }
  return revisionlevel_;
}
inline ::std::string* CDRomDriveInfo::release_revisionlevel() {
  clear_has_revisionlevel();
  if (revisionlevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revisionlevel_;
    revisionlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 28;
inline bool CDRomDriveInfo::has_status() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CDRomDriveInfo::set_has_status() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CDRomDriveInfo::clear_has_status() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CDRomDriveInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& CDRomDriveInfo::status() const {
  return *status_;
}
inline void CDRomDriveInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CDRomDriveInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CDRomDriveInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* CDRomDriveInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VolumeName = 29;
inline bool CDRomDriveInfo::has_volumename() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CDRomDriveInfo::set_has_volumename() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CDRomDriveInfo::clear_has_volumename() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CDRomDriveInfo::clear_volumename() {
  if (volumename_ != &::google::protobuf::internal::kEmptyString) {
    volumename_->clear();
  }
  clear_has_volumename();
}
inline const ::std::string& CDRomDriveInfo::volumename() const {
  return *volumename_;
}
inline void CDRomDriveInfo::set_volumename(const ::std::string& value) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(value);
}
inline void CDRomDriveInfo::set_volumename(const char* value) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(value);
}
inline void CDRomDriveInfo::set_volumename(const char* value, size_t size) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_volumename() {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  return volumename_;
}
inline ::std::string* CDRomDriveInfo::release_volumename() {
  clear_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volumename_;
    volumename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VolumeSerialNumber = 30;
inline bool CDRomDriveInfo::has_volumeserialnumber() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CDRomDriveInfo::set_has_volumeserialnumber() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CDRomDriveInfo::clear_has_volumeserialnumber() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CDRomDriveInfo::clear_volumeserialnumber() {
  if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_->clear();
  }
  clear_has_volumeserialnumber();
}
inline const ::std::string& CDRomDriveInfo::volumeserialnumber() const {
  return *volumeserialnumber_;
}
inline void CDRomDriveInfo::set_volumeserialnumber(const ::std::string& value) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(value);
}
inline void CDRomDriveInfo::set_volumeserialnumber(const char* value) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(value);
}
inline void CDRomDriveInfo::set_volumeserialnumber(const char* value, size_t size) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_volumeserialnumber() {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  return volumeserialnumber_;
}
inline ::std::string* CDRomDriveInfo::release_volumeserialnumber() {
  clear_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volumeserialnumber_;
    volumeserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 31;
inline bool CDRomDriveInfo::has_availability() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CDRomDriveInfo::set_has_availability() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CDRomDriveInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CDRomDriveInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 CDRomDriveInfo::availability() const {
  return availability_;
}
inline void CDRomDriveInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 DefaultBlockSize = 32;
inline bool CDRomDriveInfo::has_defaultblocksize() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CDRomDriveInfo::set_has_defaultblocksize() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CDRomDriveInfo::clear_has_defaultblocksize() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CDRomDriveInfo::clear_defaultblocksize() {
  defaultblocksize_ = 0;
  clear_has_defaultblocksize();
}
inline ::google::protobuf::int32 CDRomDriveInfo::defaultblocksize() const {
  return defaultblocksize_;
}
inline void CDRomDriveInfo::set_defaultblocksize(::google::protobuf::int32 value) {
  set_has_defaultblocksize();
  defaultblocksize_ = value;
}

// optional double BuyTime = 33;
inline bool CDRomDriveInfo::has_buytime() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CDRomDriveInfo::set_has_buytime() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CDRomDriveInfo::clear_has_buytime() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CDRomDriveInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double CDRomDriveInfo::buytime() const {
  return buytime_;
}
inline void CDRomDriveInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 34;
inline bool CDRomDriveInfo::has_buyprice() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CDRomDriveInfo::set_has_buyprice() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CDRomDriveInfo::clear_has_buyprice() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CDRomDriveInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& CDRomDriveInfo::buyprice() const {
  return *buyprice_;
}
inline void CDRomDriveInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void CDRomDriveInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void CDRomDriveInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* CDRomDriveInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 35;
inline bool CDRomDriveInfo::has_dchecktime() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CDRomDriveInfo::set_has_dchecktime() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CDRomDriveInfo::clear_has_dchecktime() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CDRomDriveInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double CDRomDriveInfo::dchecktime() const {
  return dchecktime_;
}
inline void CDRomDriveInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 36;
inline bool CDRomDriveInfo::has_otherinfo() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CDRomDriveInfo::set_has_otherinfo() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CDRomDriveInfo::clear_has_otherinfo() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CDRomDriveInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& CDRomDriveInfo::otherinfo() const {
  return *otherinfo_;
}
inline void CDRomDriveInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void CDRomDriveInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void CDRomDriveInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* CDRomDriveInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 37;
inline bool CDRomDriveInfo::has_buyname() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CDRomDriveInfo::set_has_buyname() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CDRomDriveInfo::clear_has_buyname() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CDRomDriveInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& CDRomDriveInfo::buyname() const {
  return *buyname_;
}
inline void CDRomDriveInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void CDRomDriveInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void CDRomDriveInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* CDRomDriveInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CDRomDriveInfoList

// repeated .isafetec.CDRomDriveInfo list = 1;
inline int CDRomDriveInfoList::list_size() const {
  return list_.size();
}
inline void CDRomDriveInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CDRomDriveInfo& CDRomDriveInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CDRomDriveInfo* CDRomDriveInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CDRomDriveInfo* CDRomDriveInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CDRomDriveInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CDRomDriveInfo* CDRomDriveInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CDRomDriveInfo >&
CDRomDriveInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CDRomDriveInfo >*
CDRomDriveInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool CDRomDriveInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDRomDriveInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDRomDriveInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDRomDriveInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 CDRomDriveInfoList::alarmed() const {
  return alarmed_;
}
inline void CDRomDriveInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool CDRomDriveInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDRomDriveInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDRomDriveInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDRomDriveInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& CDRomDriveInfoList::winuser() const {
  return *winuser_;
}
inline void CDRomDriveInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void CDRomDriveInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void CDRomDriveInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDRomDriveInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* CDRomDriveInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ComputerSystemInfo

// optional string package_code = 1;
inline bool ComputerSystemInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputerSystemInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputerSystemInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputerSystemInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& ComputerSystemInfo::package_code() const {
  return *package_code_;
}
inline void ComputerSystemInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ComputerSystemInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ComputerSystemInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* ComputerSystemInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool ComputerSystemInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputerSystemInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputerSystemInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputerSystemInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 ComputerSystemInfo::checktype() const {
  return checktype_;
}
inline void ComputerSystemInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool ComputerSystemInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputerSystemInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputerSystemInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputerSystemInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double ComputerSystemInfo::scan_time() const {
  return scan_time_;
}
inline void ComputerSystemInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool ComputerSystemInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComputerSystemInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComputerSystemInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComputerSystemInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double ComputerSystemInfo::addtime() const {
  return addtime_;
}
inline void ComputerSystemInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 DomainRole = 4;
inline bool ComputerSystemInfo::has_domainrole() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComputerSystemInfo::set_has_domainrole() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComputerSystemInfo::clear_has_domainrole() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComputerSystemInfo::clear_domainrole() {
  domainrole_ = 0;
  clear_has_domainrole();
}
inline ::google::protobuf::int32 ComputerSystemInfo::domainrole() const {
  return domainrole_;
}
inline void ComputerSystemInfo::set_domainrole(::google::protobuf::int32 value) {
  set_has_domainrole();
  domainrole_ = value;
}

// optional int32 FrontPanelResetStatus = 5;
inline bool ComputerSystemInfo::has_frontpanelresetstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComputerSystemInfo::set_has_frontpanelresetstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComputerSystemInfo::clear_has_frontpanelresetstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComputerSystemInfo::clear_frontpanelresetstatus() {
  frontpanelresetstatus_ = 0;
  clear_has_frontpanelresetstatus();
}
inline ::google::protobuf::int32 ComputerSystemInfo::frontpanelresetstatus() const {
  return frontpanelresetstatus_;
}
inline void ComputerSystemInfo::set_frontpanelresetstatus(::google::protobuf::int32 value) {
  set_has_frontpanelresetstatus();
  frontpanelresetstatus_ = value;
}

// optional int32 KeyboardPasswordStatus = 6;
inline bool ComputerSystemInfo::has_keyboardpasswordstatus() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComputerSystemInfo::set_has_keyboardpasswordstatus() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComputerSystemInfo::clear_has_keyboardpasswordstatus() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComputerSystemInfo::clear_keyboardpasswordstatus() {
  keyboardpasswordstatus_ = 0;
  clear_has_keyboardpasswordstatus();
}
inline ::google::protobuf::int32 ComputerSystemInfo::keyboardpasswordstatus() const {
  return keyboardpasswordstatus_;
}
inline void ComputerSystemInfo::set_keyboardpasswordstatus(::google::protobuf::int32 value) {
  set_has_keyboardpasswordstatus();
  keyboardpasswordstatus_ = value;
}

// optional int32 PowerOnPasswordStatus = 7;
inline bool ComputerSystemInfo::has_poweronpasswordstatus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComputerSystemInfo::set_has_poweronpasswordstatus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComputerSystemInfo::clear_has_poweronpasswordstatus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComputerSystemInfo::clear_poweronpasswordstatus() {
  poweronpasswordstatus_ = 0;
  clear_has_poweronpasswordstatus();
}
inline ::google::protobuf::int32 ComputerSystemInfo::poweronpasswordstatus() const {
  return poweronpasswordstatus_;
}
inline void ComputerSystemInfo::set_poweronpasswordstatus(::google::protobuf::int32 value) {
  set_has_poweronpasswordstatus();
  poweronpasswordstatus_ = value;
}

// optional int32 PowerState = 8;
inline bool ComputerSystemInfo::has_powerstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComputerSystemInfo::set_has_powerstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComputerSystemInfo::clear_has_powerstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComputerSystemInfo::clear_powerstate() {
  powerstate_ = 0;
  clear_has_powerstate();
}
inline ::google::protobuf::int32 ComputerSystemInfo::powerstate() const {
  return powerstate_;
}
inline void ComputerSystemInfo::set_powerstate(::google::protobuf::int32 value) {
  set_has_powerstate();
  powerstate_ = value;
}

// optional int32 PowerSupplyState = 9;
inline bool ComputerSystemInfo::has_powersupplystate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ComputerSystemInfo::set_has_powersupplystate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ComputerSystemInfo::clear_has_powersupplystate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ComputerSystemInfo::clear_powersupplystate() {
  powersupplystate_ = 0;
  clear_has_powersupplystate();
}
inline ::google::protobuf::int32 ComputerSystemInfo::powersupplystate() const {
  return powersupplystate_;
}
inline void ComputerSystemInfo::set_powersupplystate(::google::protobuf::int32 value) {
  set_has_powersupplystate();
  powersupplystate_ = value;
}

// optional int32 ResetCapability = 10;
inline bool ComputerSystemInfo::has_resetcapability() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ComputerSystemInfo::set_has_resetcapability() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ComputerSystemInfo::clear_has_resetcapability() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ComputerSystemInfo::clear_resetcapability() {
  resetcapability_ = 0;
  clear_has_resetcapability();
}
inline ::google::protobuf::int32 ComputerSystemInfo::resetcapability() const {
  return resetcapability_;
}
inline void ComputerSystemInfo::set_resetcapability(::google::protobuf::int32 value) {
  set_has_resetcapability();
  resetcapability_ = value;
}

// optional int32 SystemStartupDelay = 11;
inline bool ComputerSystemInfo::has_systemstartupdelay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ComputerSystemInfo::set_has_systemstartupdelay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ComputerSystemInfo::clear_has_systemstartupdelay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ComputerSystemInfo::clear_systemstartupdelay() {
  systemstartupdelay_ = 0;
  clear_has_systemstartupdelay();
}
inline ::google::protobuf::int32 ComputerSystemInfo::systemstartupdelay() const {
  return systemstartupdelay_;
}
inline void ComputerSystemInfo::set_systemstartupdelay(::google::protobuf::int32 value) {
  set_has_systemstartupdelay();
  systemstartupdelay_ = value;
}

// optional int32 ThermalState = 12;
inline bool ComputerSystemInfo::has_thermalstate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ComputerSystemInfo::set_has_thermalstate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ComputerSystemInfo::clear_has_thermalstate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ComputerSystemInfo::clear_thermalstate() {
  thermalstate_ = 0;
  clear_has_thermalstate();
}
inline ::google::protobuf::int32 ComputerSystemInfo::thermalstate() const {
  return thermalstate_;
}
inline void ComputerSystemInfo::set_thermalstate(::google::protobuf::int32 value) {
  set_has_thermalstate();
  thermalstate_ = value;
}

// optional int32 WakeUpType = 13;
inline bool ComputerSystemInfo::has_wakeuptype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ComputerSystemInfo::set_has_wakeuptype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ComputerSystemInfo::clear_has_wakeuptype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ComputerSystemInfo::clear_wakeuptype() {
  wakeuptype_ = 0;
  clear_has_wakeuptype();
}
inline ::google::protobuf::int32 ComputerSystemInfo::wakeuptype() const {
  return wakeuptype_;
}
inline void ComputerSystemInfo::set_wakeuptype(::google::protobuf::int32 value) {
  set_has_wakeuptype();
  wakeuptype_ = value;
}

// optional int32 CurrentTimeZone = 14;
inline bool ComputerSystemInfo::has_currenttimezone() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ComputerSystemInfo::set_has_currenttimezone() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ComputerSystemInfo::clear_has_currenttimezone() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ComputerSystemInfo::clear_currenttimezone() {
  currenttimezone_ = 0;
  clear_has_currenttimezone();
}
inline ::google::protobuf::int32 ComputerSystemInfo::currenttimezone() const {
  return currenttimezone_;
}
inline void ComputerSystemInfo::set_currenttimezone(::google::protobuf::int32 value) {
  set_has_currenttimezone();
  currenttimezone_ = value;
}

// optional int32 ResetCount = 15;
inline bool ComputerSystemInfo::has_resetcount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ComputerSystemInfo::set_has_resetcount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ComputerSystemInfo::clear_has_resetcount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ComputerSystemInfo::clear_resetcount() {
  resetcount_ = 0;
  clear_has_resetcount();
}
inline ::google::protobuf::int32 ComputerSystemInfo::resetcount() const {
  return resetcount_;
}
inline void ComputerSystemInfo::set_resetcount(::google::protobuf::int32 value) {
  set_has_resetcount();
  resetcount_ = value;
}

// optional int32 ResetLimit = 16;
inline bool ComputerSystemInfo::has_resetlimit() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ComputerSystemInfo::set_has_resetlimit() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ComputerSystemInfo::clear_has_resetlimit() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ComputerSystemInfo::clear_resetlimit() {
  resetlimit_ = 0;
  clear_has_resetlimit();
}
inline ::google::protobuf::int32 ComputerSystemInfo::resetlimit() const {
  return resetlimit_;
}
inline void ComputerSystemInfo::set_resetlimit(::google::protobuf::int32 value) {
  set_has_resetlimit();
  resetlimit_ = value;
}

// optional int32 NumberOfProcessors = 17;
inline bool ComputerSystemInfo::has_numberofprocessors() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ComputerSystemInfo::set_has_numberofprocessors() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ComputerSystemInfo::clear_has_numberofprocessors() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ComputerSystemInfo::clear_numberofprocessors() {
  numberofprocessors_ = 0;
  clear_has_numberofprocessors();
}
inline ::google::protobuf::int32 ComputerSystemInfo::numberofprocessors() const {
  return numberofprocessors_;
}
inline void ComputerSystemInfo::set_numberofprocessors(::google::protobuf::int32 value) {
  set_has_numberofprocessors();
  numberofprocessors_ = value;
}

// optional uint64 TotalPhysicalMemory = 18;
inline bool ComputerSystemInfo::has_totalphysicalmemory() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ComputerSystemInfo::set_has_totalphysicalmemory() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ComputerSystemInfo::clear_has_totalphysicalmemory() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ComputerSystemInfo::clear_totalphysicalmemory() {
  totalphysicalmemory_ = GOOGLE_ULONGLONG(0);
  clear_has_totalphysicalmemory();
}
inline ::google::protobuf::uint64 ComputerSystemInfo::totalphysicalmemory() const {
  return totalphysicalmemory_;
}
inline void ComputerSystemInfo::set_totalphysicalmemory(::google::protobuf::uint64 value) {
  set_has_totalphysicalmemory();
  totalphysicalmemory_ = value;
}

// optional int64 PauseAfterReset = 19;
inline bool ComputerSystemInfo::has_pauseafterreset() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ComputerSystemInfo::set_has_pauseafterreset() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ComputerSystemInfo::clear_has_pauseafterreset() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ComputerSystemInfo::clear_pauseafterreset() {
  pauseafterreset_ = GOOGLE_LONGLONG(0);
  clear_has_pauseafterreset();
}
inline ::google::protobuf::int64 ComputerSystemInfo::pauseafterreset() const {
  return pauseafterreset_;
}
inline void ComputerSystemInfo::set_pauseafterreset(::google::protobuf::int64 value) {
  set_has_pauseafterreset();
  pauseafterreset_ = value;
}

// optional int32 AutomaticResetBootOption = 20;
inline bool ComputerSystemInfo::has_automaticresetbootoption() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ComputerSystemInfo::set_has_automaticresetbootoption() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ComputerSystemInfo::clear_has_automaticresetbootoption() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ComputerSystemInfo::clear_automaticresetbootoption() {
  automaticresetbootoption_ = 0;
  clear_has_automaticresetbootoption();
}
inline ::google::protobuf::int32 ComputerSystemInfo::automaticresetbootoption() const {
  return automaticresetbootoption_;
}
inline void ComputerSystemInfo::set_automaticresetbootoption(::google::protobuf::int32 value) {
  set_has_automaticresetbootoption();
  automaticresetbootoption_ = value;
}

// optional int32 AutomaticResetCapability = 21;
inline bool ComputerSystemInfo::has_automaticresetcapability() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ComputerSystemInfo::set_has_automaticresetcapability() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ComputerSystemInfo::clear_has_automaticresetcapability() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ComputerSystemInfo::clear_automaticresetcapability() {
  automaticresetcapability_ = 0;
  clear_has_automaticresetcapability();
}
inline ::google::protobuf::int32 ComputerSystemInfo::automaticresetcapability() const {
  return automaticresetcapability_;
}
inline void ComputerSystemInfo::set_automaticresetcapability(::google::protobuf::int32 value) {
  set_has_automaticresetcapability();
  automaticresetcapability_ = value;
}

// optional int32 BootROMSupported = 22;
inline bool ComputerSystemInfo::has_bootromsupported() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ComputerSystemInfo::set_has_bootromsupported() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ComputerSystemInfo::clear_has_bootromsupported() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ComputerSystemInfo::clear_bootromsupported() {
  bootromsupported_ = 0;
  clear_has_bootromsupported();
}
inline ::google::protobuf::int32 ComputerSystemInfo::bootromsupported() const {
  return bootromsupported_;
}
inline void ComputerSystemInfo::set_bootromsupported(::google::protobuf::int32 value) {
  set_has_bootromsupported();
  bootromsupported_ = value;
}

// optional int32 EnableDaylightSavingsTime = 23;
inline bool ComputerSystemInfo::has_enabledaylightsavingstime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ComputerSystemInfo::set_has_enabledaylightsavingstime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ComputerSystemInfo::clear_has_enabledaylightsavingstime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ComputerSystemInfo::clear_enabledaylightsavingstime() {
  enabledaylightsavingstime_ = 0;
  clear_has_enabledaylightsavingstime();
}
inline ::google::protobuf::int32 ComputerSystemInfo::enabledaylightsavingstime() const {
  return enabledaylightsavingstime_;
}
inline void ComputerSystemInfo::set_enabledaylightsavingstime(::google::protobuf::int32 value) {
  set_has_enabledaylightsavingstime();
  enabledaylightsavingstime_ = value;
}

// optional int32 InfraredSupported = 24;
inline bool ComputerSystemInfo::has_infraredsupported() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ComputerSystemInfo::set_has_infraredsupported() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ComputerSystemInfo::clear_has_infraredsupported() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ComputerSystemInfo::clear_infraredsupported() {
  infraredsupported_ = 0;
  clear_has_infraredsupported();
}
inline ::google::protobuf::int32 ComputerSystemInfo::infraredsupported() const {
  return infraredsupported_;
}
inline void ComputerSystemInfo::set_infraredsupported(::google::protobuf::int32 value) {
  set_has_infraredsupported();
  infraredsupported_ = value;
}

// optional int32 NetworkServerModeEnabled = 25;
inline bool ComputerSystemInfo::has_networkservermodeenabled() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ComputerSystemInfo::set_has_networkservermodeenabled() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ComputerSystemInfo::clear_has_networkservermodeenabled() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ComputerSystemInfo::clear_networkservermodeenabled() {
  networkservermodeenabled_ = 0;
  clear_has_networkservermodeenabled();
}
inline ::google::protobuf::int32 ComputerSystemInfo::networkservermodeenabled() const {
  return networkservermodeenabled_;
}
inline void ComputerSystemInfo::set_networkservermodeenabled(::google::protobuf::int32 value) {
  set_has_networkservermodeenabled();
  networkservermodeenabled_ = value;
}

// optional int32 PartOfDomain = 26;
inline bool ComputerSystemInfo::has_partofdomain() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ComputerSystemInfo::set_has_partofdomain() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ComputerSystemInfo::clear_has_partofdomain() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ComputerSystemInfo::clear_partofdomain() {
  partofdomain_ = 0;
  clear_has_partofdomain();
}
inline ::google::protobuf::int32 ComputerSystemInfo::partofdomain() const {
  return partofdomain_;
}
inline void ComputerSystemInfo::set_partofdomain(::google::protobuf::int32 value) {
  set_has_partofdomain();
  partofdomain_ = value;
}

// optional int32 SystemStartupSetting = 27;
inline bool ComputerSystemInfo::has_systemstartupsetting() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ComputerSystemInfo::set_has_systemstartupsetting() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ComputerSystemInfo::clear_has_systemstartupsetting() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ComputerSystemInfo::clear_systemstartupsetting() {
  systemstartupsetting_ = 0;
  clear_has_systemstartupsetting();
}
inline ::google::protobuf::int32 ComputerSystemInfo::systemstartupsetting() const {
  return systemstartupsetting_;
}
inline void ComputerSystemInfo::set_systemstartupsetting(::google::protobuf::int32 value) {
  set_has_systemstartupsetting();
  systemstartupsetting_ = value;
}

// optional string BootupState = 28;
inline bool ComputerSystemInfo::has_bootupstate() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ComputerSystemInfo::set_has_bootupstate() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ComputerSystemInfo::clear_has_bootupstate() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ComputerSystemInfo::clear_bootupstate() {
  if (bootupstate_ != &::google::protobuf::internal::kEmptyString) {
    bootupstate_->clear();
  }
  clear_has_bootupstate();
}
inline const ::std::string& ComputerSystemInfo::bootupstate() const {
  return *bootupstate_;
}
inline void ComputerSystemInfo::set_bootupstate(const ::std::string& value) {
  set_has_bootupstate();
  if (bootupstate_ == &::google::protobuf::internal::kEmptyString) {
    bootupstate_ = new ::std::string;
  }
  bootupstate_->assign(value);
}
inline void ComputerSystemInfo::set_bootupstate(const char* value) {
  set_has_bootupstate();
  if (bootupstate_ == &::google::protobuf::internal::kEmptyString) {
    bootupstate_ = new ::std::string;
  }
  bootupstate_->assign(value);
}
inline void ComputerSystemInfo::set_bootupstate(const char* value, size_t size) {
  set_has_bootupstate();
  if (bootupstate_ == &::google::protobuf::internal::kEmptyString) {
    bootupstate_ = new ::std::string;
  }
  bootupstate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_bootupstate() {
  set_has_bootupstate();
  if (bootupstate_ == &::google::protobuf::internal::kEmptyString) {
    bootupstate_ = new ::std::string;
  }
  return bootupstate_;
}
inline ::std::string* ComputerSystemInfo::release_bootupstate() {
  clear_has_bootupstate();
  if (bootupstate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bootupstate_;
    bootupstate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 30;
inline bool ComputerSystemInfo::has_description() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ComputerSystemInfo::set_has_description() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ComputerSystemInfo::clear_has_description() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ComputerSystemInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ComputerSystemInfo::description() const {
  return *description_;
}
inline void ComputerSystemInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ComputerSystemInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ComputerSystemInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ComputerSystemInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DNSHostName = 31;
inline bool ComputerSystemInfo::has_dnshostname() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ComputerSystemInfo::set_has_dnshostname() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ComputerSystemInfo::clear_has_dnshostname() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ComputerSystemInfo::clear_dnshostname() {
  if (dnshostname_ != &::google::protobuf::internal::kEmptyString) {
    dnshostname_->clear();
  }
  clear_has_dnshostname();
}
inline const ::std::string& ComputerSystemInfo::dnshostname() const {
  return *dnshostname_;
}
inline void ComputerSystemInfo::set_dnshostname(const ::std::string& value) {
  set_has_dnshostname();
  if (dnshostname_ == &::google::protobuf::internal::kEmptyString) {
    dnshostname_ = new ::std::string;
  }
  dnshostname_->assign(value);
}
inline void ComputerSystemInfo::set_dnshostname(const char* value) {
  set_has_dnshostname();
  if (dnshostname_ == &::google::protobuf::internal::kEmptyString) {
    dnshostname_ = new ::std::string;
  }
  dnshostname_->assign(value);
}
inline void ComputerSystemInfo::set_dnshostname(const char* value, size_t size) {
  set_has_dnshostname();
  if (dnshostname_ == &::google::protobuf::internal::kEmptyString) {
    dnshostname_ = new ::std::string;
  }
  dnshostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_dnshostname() {
  set_has_dnshostname();
  if (dnshostname_ == &::google::protobuf::internal::kEmptyString) {
    dnshostname_ = new ::std::string;
  }
  return dnshostname_;
}
inline ::std::string* ComputerSystemInfo::release_dnshostname() {
  clear_has_dnshostname();
  if (dnshostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dnshostname_;
    dnshostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Domain = 33;
inline bool ComputerSystemInfo::has_domain() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ComputerSystemInfo::set_has_domain() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ComputerSystemInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ComputerSystemInfo::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& ComputerSystemInfo::domain() const {
  return *domain_;
}
inline void ComputerSystemInfo::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ComputerSystemInfo::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void ComputerSystemInfo::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* ComputerSystemInfo::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 34;
inline bool ComputerSystemInfo::has_manufacturer() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ComputerSystemInfo::set_has_manufacturer() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ComputerSystemInfo::clear_has_manufacturer() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ComputerSystemInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& ComputerSystemInfo::manufacturer() const {
  return *manufacturer_;
}
inline void ComputerSystemInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ComputerSystemInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void ComputerSystemInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* ComputerSystemInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Model = 35;
inline bool ComputerSystemInfo::has_model() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ComputerSystemInfo::set_has_model() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ComputerSystemInfo::clear_has_model() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ComputerSystemInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& ComputerSystemInfo::model() const {
  return *model_;
}
inline void ComputerSystemInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ComputerSystemInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void ComputerSystemInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* ComputerSystemInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PrimaryOwnerName = 36;
inline bool ComputerSystemInfo::has_primaryownername() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ComputerSystemInfo::set_has_primaryownername() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ComputerSystemInfo::clear_has_primaryownername() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ComputerSystemInfo::clear_primaryownername() {
  if (primaryownername_ != &::google::protobuf::internal::kEmptyString) {
    primaryownername_->clear();
  }
  clear_has_primaryownername();
}
inline const ::std::string& ComputerSystemInfo::primaryownername() const {
  return *primaryownername_;
}
inline void ComputerSystemInfo::set_primaryownername(const ::std::string& value) {
  set_has_primaryownername();
  if (primaryownername_ == &::google::protobuf::internal::kEmptyString) {
    primaryownername_ = new ::std::string;
  }
  primaryownername_->assign(value);
}
inline void ComputerSystemInfo::set_primaryownername(const char* value) {
  set_has_primaryownername();
  if (primaryownername_ == &::google::protobuf::internal::kEmptyString) {
    primaryownername_ = new ::std::string;
  }
  primaryownername_->assign(value);
}
inline void ComputerSystemInfo::set_primaryownername(const char* value, size_t size) {
  set_has_primaryownername();
  if (primaryownername_ == &::google::protobuf::internal::kEmptyString) {
    primaryownername_ = new ::std::string;
  }
  primaryownername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_primaryownername() {
  set_has_primaryownername();
  if (primaryownername_ == &::google::protobuf::internal::kEmptyString) {
    primaryownername_ = new ::std::string;
  }
  return primaryownername_;
}
inline ::std::string* ComputerSystemInfo::release_primaryownername() {
  clear_has_primaryownername();
  if (primaryownername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primaryownername_;
    primaryownername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Roles = 37;
inline bool ComputerSystemInfo::has_roles() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ComputerSystemInfo::set_has_roles() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ComputerSystemInfo::clear_has_roles() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ComputerSystemInfo::clear_roles() {
  if (roles_ != &::google::protobuf::internal::kEmptyString) {
    roles_->clear();
  }
  clear_has_roles();
}
inline const ::std::string& ComputerSystemInfo::roles() const {
  return *roles_;
}
inline void ComputerSystemInfo::set_roles(const ::std::string& value) {
  set_has_roles();
  if (roles_ == &::google::protobuf::internal::kEmptyString) {
    roles_ = new ::std::string;
  }
  roles_->assign(value);
}
inline void ComputerSystemInfo::set_roles(const char* value) {
  set_has_roles();
  if (roles_ == &::google::protobuf::internal::kEmptyString) {
    roles_ = new ::std::string;
  }
  roles_->assign(value);
}
inline void ComputerSystemInfo::set_roles(const char* value, size_t size) {
  set_has_roles();
  if (roles_ == &::google::protobuf::internal::kEmptyString) {
    roles_ = new ::std::string;
  }
  roles_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_roles() {
  set_has_roles();
  if (roles_ == &::google::protobuf::internal::kEmptyString) {
    roles_ = new ::std::string;
  }
  return roles_;
}
inline ::std::string* ComputerSystemInfo::release_roles() {
  clear_has_roles();
  if (roles_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roles_;
    roles_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 38;
inline bool ComputerSystemInfo::has_status() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ComputerSystemInfo::set_has_status() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ComputerSystemInfo::clear_has_status() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ComputerSystemInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& ComputerSystemInfo::status() const {
  return *status_;
}
inline void ComputerSystemInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ComputerSystemInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void ComputerSystemInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* ComputerSystemInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SystemStartupOptions = 39;
inline bool ComputerSystemInfo::has_systemstartupoptions() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ComputerSystemInfo::set_has_systemstartupoptions() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ComputerSystemInfo::clear_has_systemstartupoptions() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ComputerSystemInfo::clear_systemstartupoptions() {
  if (systemstartupoptions_ != &::google::protobuf::internal::kEmptyString) {
    systemstartupoptions_->clear();
  }
  clear_has_systemstartupoptions();
}
inline const ::std::string& ComputerSystemInfo::systemstartupoptions() const {
  return *systemstartupoptions_;
}
inline void ComputerSystemInfo::set_systemstartupoptions(const ::std::string& value) {
  set_has_systemstartupoptions();
  if (systemstartupoptions_ == &::google::protobuf::internal::kEmptyString) {
    systemstartupoptions_ = new ::std::string;
  }
  systemstartupoptions_->assign(value);
}
inline void ComputerSystemInfo::set_systemstartupoptions(const char* value) {
  set_has_systemstartupoptions();
  if (systemstartupoptions_ == &::google::protobuf::internal::kEmptyString) {
    systemstartupoptions_ = new ::std::string;
  }
  systemstartupoptions_->assign(value);
}
inline void ComputerSystemInfo::set_systemstartupoptions(const char* value, size_t size) {
  set_has_systemstartupoptions();
  if (systemstartupoptions_ == &::google::protobuf::internal::kEmptyString) {
    systemstartupoptions_ = new ::std::string;
  }
  systemstartupoptions_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_systemstartupoptions() {
  set_has_systemstartupoptions();
  if (systemstartupoptions_ == &::google::protobuf::internal::kEmptyString) {
    systemstartupoptions_ = new ::std::string;
  }
  return systemstartupoptions_;
}
inline ::std::string* ComputerSystemInfo::release_systemstartupoptions() {
  clear_has_systemstartupoptions();
  if (systemstartupoptions_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemstartupoptions_;
    systemstartupoptions_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SystemType = 40;
inline bool ComputerSystemInfo::has_systemtype() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ComputerSystemInfo::set_has_systemtype() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ComputerSystemInfo::clear_has_systemtype() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ComputerSystemInfo::clear_systemtype() {
  if (systemtype_ != &::google::protobuf::internal::kEmptyString) {
    systemtype_->clear();
  }
  clear_has_systemtype();
}
inline const ::std::string& ComputerSystemInfo::systemtype() const {
  return *systemtype_;
}
inline void ComputerSystemInfo::set_systemtype(const ::std::string& value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
}
inline void ComputerSystemInfo::set_systemtype(const char* value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
}
inline void ComputerSystemInfo::set_systemtype(const char* value, size_t size) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_systemtype() {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    systemtype_ = new ::std::string;
  }
  return systemtype_;
}
inline ::std::string* ComputerSystemInfo::release_systemtype() {
  clear_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = systemtype_;
    systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UserName = 41;
inline bool ComputerSystemInfo::has_username() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ComputerSystemInfo::set_has_username() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ComputerSystemInfo::clear_has_username() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ComputerSystemInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ComputerSystemInfo::username() const {
  return *username_;
}
inline void ComputerSystemInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ComputerSystemInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ComputerSystemInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ComputerSystemInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 AdminPasswordStatus = 42;
inline bool ComputerSystemInfo::has_adminpasswordstatus() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ComputerSystemInfo::set_has_adminpasswordstatus() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ComputerSystemInfo::clear_has_adminpasswordstatus() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ComputerSystemInfo::clear_adminpasswordstatus() {
  adminpasswordstatus_ = 0;
  clear_has_adminpasswordstatus();
}
inline ::google::protobuf::int32 ComputerSystemInfo::adminpasswordstatus() const {
  return adminpasswordstatus_;
}
inline void ComputerSystemInfo::set_adminpasswordstatus(::google::protobuf::int32 value) {
  set_has_adminpasswordstatus();
  adminpasswordstatus_ = value;
}

// optional int32 ChassisBootupState = 43;
inline bool ComputerSystemInfo::has_chassisbootupstate() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ComputerSystemInfo::set_has_chassisbootupstate() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ComputerSystemInfo::clear_has_chassisbootupstate() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ComputerSystemInfo::clear_chassisbootupstate() {
  chassisbootupstate_ = 0;
  clear_has_chassisbootupstate();
}
inline ::google::protobuf::int32 ComputerSystemInfo::chassisbootupstate() const {
  return chassisbootupstate_;
}
inline void ComputerSystemInfo::set_chassisbootupstate(::google::protobuf::int32 value) {
  set_has_chassisbootupstate();
  chassisbootupstate_ = value;
}

// -------------------------------------------------------------------

// ComputerSystemInfoList

// repeated .isafetec.ComputerSystemInfo list = 1;
inline int ComputerSystemInfoList::list_size() const {
  return list_.size();
}
inline void ComputerSystemInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::ComputerSystemInfo& ComputerSystemInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::ComputerSystemInfo* ComputerSystemInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::ComputerSystemInfo* ComputerSystemInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void ComputerSystemInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::ComputerSystemInfo* ComputerSystemInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::ComputerSystemInfo >&
ComputerSystemInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::ComputerSystemInfo >*
ComputerSystemInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool ComputerSystemInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputerSystemInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputerSystemInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputerSystemInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 ComputerSystemInfoList::alarmed() const {
  return alarmed_;
}
inline void ComputerSystemInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool ComputerSystemInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputerSystemInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputerSystemInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputerSystemInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& ComputerSystemInfoList::winuser() const {
  return *winuser_;
}
inline void ComputerSystemInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ComputerSystemInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ComputerSystemInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* ComputerSystemInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ComputerSystemProductInfo

// optional string package_code = 1;
inline bool ComputerSystemProductInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputerSystemProductInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputerSystemProductInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputerSystemProductInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& ComputerSystemProductInfo::package_code() const {
  return *package_code_;
}
inline void ComputerSystemProductInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ComputerSystemProductInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ComputerSystemProductInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* ComputerSystemProductInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool ComputerSystemProductInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputerSystemProductInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputerSystemProductInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputerSystemProductInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 ComputerSystemProductInfo::checktype() const {
  return checktype_;
}
inline void ComputerSystemProductInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool ComputerSystemProductInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputerSystemProductInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputerSystemProductInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputerSystemProductInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double ComputerSystemProductInfo::scan_time() const {
  return scan_time_;
}
inline void ComputerSystemProductInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool ComputerSystemProductInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComputerSystemProductInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComputerSystemProductInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComputerSystemProductInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double ComputerSystemProductInfo::addtime() const {
  return addtime_;
}
inline void ComputerSystemProductInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional string IdentifyingNumber = 4;
inline bool ComputerSystemProductInfo::has_identifyingnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComputerSystemProductInfo::set_has_identifyingnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComputerSystemProductInfo::clear_has_identifyingnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComputerSystemProductInfo::clear_identifyingnumber() {
  if (identifyingnumber_ != &::google::protobuf::internal::kEmptyString) {
    identifyingnumber_->clear();
  }
  clear_has_identifyingnumber();
}
inline const ::std::string& ComputerSystemProductInfo::identifyingnumber() const {
  return *identifyingnumber_;
}
inline void ComputerSystemProductInfo::set_identifyingnumber(const ::std::string& value) {
  set_has_identifyingnumber();
  if (identifyingnumber_ == &::google::protobuf::internal::kEmptyString) {
    identifyingnumber_ = new ::std::string;
  }
  identifyingnumber_->assign(value);
}
inline void ComputerSystemProductInfo::set_identifyingnumber(const char* value) {
  set_has_identifyingnumber();
  if (identifyingnumber_ == &::google::protobuf::internal::kEmptyString) {
    identifyingnumber_ = new ::std::string;
  }
  identifyingnumber_->assign(value);
}
inline void ComputerSystemProductInfo::set_identifyingnumber(const char* value, size_t size) {
  set_has_identifyingnumber();
  if (identifyingnumber_ == &::google::protobuf::internal::kEmptyString) {
    identifyingnumber_ = new ::std::string;
  }
  identifyingnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_identifyingnumber() {
  set_has_identifyingnumber();
  if (identifyingnumber_ == &::google::protobuf::internal::kEmptyString) {
    identifyingnumber_ = new ::std::string;
  }
  return identifyingnumber_;
}
inline ::std::string* ComputerSystemProductInfo::release_identifyingnumber() {
  clear_has_identifyingnumber();
  if (identifyingnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifyingnumber_;
    identifyingnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 5;
inline bool ComputerSystemProductInfo::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComputerSystemProductInfo::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComputerSystemProductInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComputerSystemProductInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ComputerSystemProductInfo::name() const {
  return *name_;
}
inline void ComputerSystemProductInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ComputerSystemProductInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ComputerSystemProductInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ComputerSystemProductInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Vendor = 6;
inline bool ComputerSystemProductInfo::has_vendor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComputerSystemProductInfo::set_has_vendor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComputerSystemProductInfo::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComputerSystemProductInfo::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& ComputerSystemProductInfo::vendor() const {
  return *vendor_;
}
inline void ComputerSystemProductInfo::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void ComputerSystemProductInfo::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void ComputerSystemProductInfo::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* ComputerSystemProductInfo::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Version = 7;
inline bool ComputerSystemProductInfo::has_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComputerSystemProductInfo::set_has_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComputerSystemProductInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComputerSystemProductInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ComputerSystemProductInfo::version() const {
  return *version_;
}
inline void ComputerSystemProductInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ComputerSystemProductInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void ComputerSystemProductInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* ComputerSystemProductInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 8;
inline bool ComputerSystemProductInfo::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComputerSystemProductInfo::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComputerSystemProductInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComputerSystemProductInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ComputerSystemProductInfo::description() const {
  return *description_;
}
inline void ComputerSystemProductInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ComputerSystemProductInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ComputerSystemProductInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ComputerSystemProductInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ComputerSystemProductInfoList

// repeated .isafetec.ComputerSystemProductInfo list = 1;
inline int ComputerSystemProductInfoList::list_size() const {
  return list_.size();
}
inline void ComputerSystemProductInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::ComputerSystemProductInfo& ComputerSystemProductInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::ComputerSystemProductInfo* ComputerSystemProductInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::ComputerSystemProductInfo* ComputerSystemProductInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void ComputerSystemProductInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::ComputerSystemProductInfo* ComputerSystemProductInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::ComputerSystemProductInfo >&
ComputerSystemProductInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::ComputerSystemProductInfo >*
ComputerSystemProductInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool ComputerSystemProductInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputerSystemProductInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputerSystemProductInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputerSystemProductInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 ComputerSystemProductInfoList::alarmed() const {
  return alarmed_;
}
inline void ComputerSystemProductInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool ComputerSystemProductInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputerSystemProductInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputerSystemProductInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputerSystemProductInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& ComputerSystemProductInfoList::winuser() const {
  return *winuser_;
}
inline void ComputerSystemProductInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ComputerSystemProductInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ComputerSystemProductInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComputerSystemProductInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* ComputerSystemProductInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DiskPartitionInfo

// optional string package_code = 1;
inline bool DiskPartitionInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskPartitionInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskPartitionInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskPartitionInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& DiskPartitionInfo::package_code() const {
  return *package_code_;
}
inline void DiskPartitionInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DiskPartitionInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DiskPartitionInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* DiskPartitionInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool DiskPartitionInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskPartitionInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskPartitionInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskPartitionInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 DiskPartitionInfo::checktype() const {
  return checktype_;
}
inline void DiskPartitionInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool DiskPartitionInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskPartitionInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskPartitionInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskPartitionInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double DiskPartitionInfo::scan_time() const {
  return scan_time_;
}
inline void DiskPartitionInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool DiskPartitionInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiskPartitionInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiskPartitionInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiskPartitionInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double DiskPartitionInfo::addtime() const {
  return addtime_;
}
inline void DiskPartitionInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional uint64 BlockSize = 4;
inline bool DiskPartitionInfo::has_blocksize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiskPartitionInfo::set_has_blocksize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiskPartitionInfo::clear_has_blocksize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiskPartitionInfo::clear_blocksize() {
  blocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_blocksize();
}
inline ::google::protobuf::uint64 DiskPartitionInfo::blocksize() const {
  return blocksize_;
}
inline void DiskPartitionInfo::set_blocksize(::google::protobuf::uint64 value) {
  set_has_blocksize();
  blocksize_ = value;
}

// optional uint64 NumberOfBlocks = 5;
inline bool DiskPartitionInfo::has_numberofblocks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiskPartitionInfo::set_has_numberofblocks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiskPartitionInfo::clear_has_numberofblocks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiskPartitionInfo::clear_numberofblocks() {
  numberofblocks_ = GOOGLE_ULONGLONG(0);
  clear_has_numberofblocks();
}
inline ::google::protobuf::uint64 DiskPartitionInfo::numberofblocks() const {
  return numberofblocks_;
}
inline void DiskPartitionInfo::set_numberofblocks(::google::protobuf::uint64 value) {
  set_has_numberofblocks();
  numberofblocks_ = value;
}

// optional uint64 Size = 6;
inline bool DiskPartitionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiskPartitionInfo::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiskPartitionInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiskPartitionInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 DiskPartitionInfo::size() const {
  return size_;
}
inline void DiskPartitionInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional uint64 StartingOffset = 7;
inline bool DiskPartitionInfo::has_startingoffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DiskPartitionInfo::set_has_startingoffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DiskPartitionInfo::clear_has_startingoffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DiskPartitionInfo::clear_startingoffset() {
  startingoffset_ = GOOGLE_ULONGLONG(0);
  clear_has_startingoffset();
}
inline ::google::protobuf::uint64 DiskPartitionInfo::startingoffset() const {
  return startingoffset_;
}
inline void DiskPartitionInfo::set_startingoffset(::google::protobuf::uint64 value) {
  set_has_startingoffset();
  startingoffset_ = value;
}

// optional string Description = 10;
inline bool DiskPartitionInfo::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DiskPartitionInfo::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DiskPartitionInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DiskPartitionInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& DiskPartitionInfo::description() const {
  return *description_;
}
inline void DiskPartitionInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DiskPartitionInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DiskPartitionInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* DiskPartitionInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 11;
inline bool DiskPartitionInfo::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DiskPartitionInfo::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DiskPartitionInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DiskPartitionInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DiskPartitionInfo::name() const {
  return *name_;
}
inline void DiskPartitionInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiskPartitionInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiskPartitionInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DiskPartitionInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 DiskIndex = 12;
inline bool DiskPartitionInfo::has_diskindex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DiskPartitionInfo::set_has_diskindex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DiskPartitionInfo::clear_has_diskindex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DiskPartitionInfo::clear_diskindex() {
  diskindex_ = 0;
  clear_has_diskindex();
}
inline ::google::protobuf::int32 DiskPartitionInfo::diskindex() const {
  return diskindex_;
}
inline void DiskPartitionInfo::set_diskindex(::google::protobuf::int32 value) {
  set_has_diskindex();
  diskindex_ = value;
}

// optional int32 Index = 13;
inline bool DiskPartitionInfo::has_index() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DiskPartitionInfo::set_has_index() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DiskPartitionInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DiskPartitionInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 DiskPartitionInfo::index() const {
  return index_;
}
inline void DiskPartitionInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional double BuyTime = 14;
inline bool DiskPartitionInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DiskPartitionInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DiskPartitionInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DiskPartitionInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double DiskPartitionInfo::buytime() const {
  return buytime_;
}
inline void DiskPartitionInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 15;
inline bool DiskPartitionInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DiskPartitionInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DiskPartitionInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DiskPartitionInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& DiskPartitionInfo::buyprice() const {
  return *buyprice_;
}
inline void DiskPartitionInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void DiskPartitionInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void DiskPartitionInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* DiskPartitionInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 16;
inline bool DiskPartitionInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DiskPartitionInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DiskPartitionInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DiskPartitionInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double DiskPartitionInfo::dchecktime() const {
  return dchecktime_;
}
inline void DiskPartitionInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 17;
inline bool DiskPartitionInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DiskPartitionInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DiskPartitionInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DiskPartitionInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& DiskPartitionInfo::otherinfo() const {
  return *otherinfo_;
}
inline void DiskPartitionInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void DiskPartitionInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void DiskPartitionInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* DiskPartitionInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 18;
inline bool DiskPartitionInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DiskPartitionInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DiskPartitionInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DiskPartitionInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& DiskPartitionInfo::buyname() const {
  return *buyname_;
}
inline void DiskPartitionInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void DiskPartitionInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void DiskPartitionInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* DiskPartitionInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DiskPartitionInfoList

// repeated .isafetec.DiskPartitionInfo list = 1;
inline int DiskPartitionInfoList::list_size() const {
  return list_.size();
}
inline void DiskPartitionInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::DiskPartitionInfo& DiskPartitionInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::DiskPartitionInfo* DiskPartitionInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::DiskPartitionInfo* DiskPartitionInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void DiskPartitionInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::DiskPartitionInfo* DiskPartitionInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DiskPartitionInfo >&
DiskPartitionInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DiskPartitionInfo >*
DiskPartitionInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool DiskPartitionInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskPartitionInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskPartitionInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskPartitionInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 DiskPartitionInfoList::alarmed() const {
  return alarmed_;
}
inline void DiskPartitionInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool DiskPartitionInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskPartitionInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskPartitionInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskPartitionInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& DiskPartitionInfoList::winuser() const {
  return *winuser_;
}
inline void DiskPartitionInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DiskPartitionInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DiskPartitionInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskPartitionInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* DiskPartitionInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DisplayConfigurationInfo

// optional string package_code = 1;
inline bool DisplayConfigurationInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplayConfigurationInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisplayConfigurationInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisplayConfigurationInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& DisplayConfigurationInfo::package_code() const {
  return *package_code_;
}
inline void DisplayConfigurationInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DisplayConfigurationInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DisplayConfigurationInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* DisplayConfigurationInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool DisplayConfigurationInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayConfigurationInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplayConfigurationInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplayConfigurationInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::checktype() const {
  return checktype_;
}
inline void DisplayConfigurationInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool DisplayConfigurationInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayConfigurationInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisplayConfigurationInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisplayConfigurationInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double DisplayConfigurationInfo::scan_time() const {
  return scan_time_;
}
inline void DisplayConfigurationInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool DisplayConfigurationInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DisplayConfigurationInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DisplayConfigurationInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DisplayConfigurationInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double DisplayConfigurationInfo::addtime() const {
  return addtime_;
}
inline void DisplayConfigurationInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 DisplayFrequency = 4;
inline bool DisplayConfigurationInfo::has_displayfrequency() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DisplayConfigurationInfo::set_has_displayfrequency() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DisplayConfigurationInfo::clear_has_displayfrequency() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DisplayConfigurationInfo::clear_displayfrequency() {
  displayfrequency_ = 0;
  clear_has_displayfrequency();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::displayfrequency() const {
  return displayfrequency_;
}
inline void DisplayConfigurationInfo::set_displayfrequency(::google::protobuf::int32 value) {
  set_has_displayfrequency();
  displayfrequency_ = value;
}

// optional int32 DitherType = 5;
inline bool DisplayConfigurationInfo::has_dithertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DisplayConfigurationInfo::set_has_dithertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DisplayConfigurationInfo::clear_has_dithertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DisplayConfigurationInfo::clear_dithertype() {
  dithertype_ = 0;
  clear_has_dithertype();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::dithertype() const {
  return dithertype_;
}
inline void DisplayConfigurationInfo::set_dithertype(::google::protobuf::int32 value) {
  set_has_dithertype();
  dithertype_ = value;
}

// optional int32 ICMIntent = 6;
inline bool DisplayConfigurationInfo::has_icmintent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DisplayConfigurationInfo::set_has_icmintent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DisplayConfigurationInfo::clear_has_icmintent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DisplayConfigurationInfo::clear_icmintent() {
  icmintent_ = 0;
  clear_has_icmintent();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::icmintent() const {
  return icmintent_;
}
inline void DisplayConfigurationInfo::set_icmintent(::google::protobuf::int32 value) {
  set_has_icmintent();
  icmintent_ = value;
}

// optional int32 ICMMethod = 7;
inline bool DisplayConfigurationInfo::has_icmmethod() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DisplayConfigurationInfo::set_has_icmmethod() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DisplayConfigurationInfo::clear_has_icmmethod() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DisplayConfigurationInfo::clear_icmmethod() {
  icmmethod_ = 0;
  clear_has_icmmethod();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::icmmethod() const {
  return icmmethod_;
}
inline void DisplayConfigurationInfo::set_icmmethod(::google::protobuf::int32 value) {
  set_has_icmmethod();
  icmmethod_ = value;
}

// optional int32 LogPixels = 8;
inline bool DisplayConfigurationInfo::has_logpixels() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DisplayConfigurationInfo::set_has_logpixels() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DisplayConfigurationInfo::clear_has_logpixels() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DisplayConfigurationInfo::clear_logpixels() {
  logpixels_ = 0;
  clear_has_logpixels();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::logpixels() const {
  return logpixels_;
}
inline void DisplayConfigurationInfo::set_logpixels(::google::protobuf::int32 value) {
  set_has_logpixels();
  logpixels_ = value;
}

// optional int32 PelsHeight = 9;
inline bool DisplayConfigurationInfo::has_pelsheight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DisplayConfigurationInfo::set_has_pelsheight() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DisplayConfigurationInfo::clear_has_pelsheight() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DisplayConfigurationInfo::clear_pelsheight() {
  pelsheight_ = 0;
  clear_has_pelsheight();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::pelsheight() const {
  return pelsheight_;
}
inline void DisplayConfigurationInfo::set_pelsheight(::google::protobuf::int32 value) {
  set_has_pelsheight();
  pelsheight_ = value;
}

// optional int32 PelsWidth = 10;
inline bool DisplayConfigurationInfo::has_pelswidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DisplayConfigurationInfo::set_has_pelswidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DisplayConfigurationInfo::clear_has_pelswidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DisplayConfigurationInfo::clear_pelswidth() {
  pelswidth_ = 0;
  clear_has_pelswidth();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::pelswidth() const {
  return pelswidth_;
}
inline void DisplayConfigurationInfo::set_pelswidth(::google::protobuf::int32 value) {
  set_has_pelswidth();
  pelswidth_ = value;
}

// optional int32 SpecificationVersion = 11;
inline bool DisplayConfigurationInfo::has_specificationversion() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DisplayConfigurationInfo::set_has_specificationversion() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DisplayConfigurationInfo::clear_has_specificationversion() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DisplayConfigurationInfo::clear_specificationversion() {
  specificationversion_ = 0;
  clear_has_specificationversion();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::specificationversion() const {
  return specificationversion_;
}
inline void DisplayConfigurationInfo::set_specificationversion(::google::protobuf::int32 value) {
  set_has_specificationversion();
  specificationversion_ = value;
}

// optional string Description = 13;
inline bool DisplayConfigurationInfo::has_description() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_description() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DisplayConfigurationInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DisplayConfigurationInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& DisplayConfigurationInfo::description() const {
  return *description_;
}
inline void DisplayConfigurationInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DisplayConfigurationInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DisplayConfigurationInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* DisplayConfigurationInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeviceName = 14;
inline bool DisplayConfigurationInfo::has_devicename() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_devicename() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DisplayConfigurationInfo::clear_has_devicename() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DisplayConfigurationInfo::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& DisplayConfigurationInfo::devicename() const {
  return *devicename_;
}
inline void DisplayConfigurationInfo::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DisplayConfigurationInfo::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void DisplayConfigurationInfo::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* DisplayConfigurationInfo::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DriverVersion = 15;
inline bool DisplayConfigurationInfo::has_driverversion() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_driverversion() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DisplayConfigurationInfo::clear_has_driverversion() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DisplayConfigurationInfo::clear_driverversion() {
  if (driverversion_ != &::google::protobuf::internal::kEmptyString) {
    driverversion_->clear();
  }
  clear_has_driverversion();
}
inline const ::std::string& DisplayConfigurationInfo::driverversion() const {
  return *driverversion_;
}
inline void DisplayConfigurationInfo::set_driverversion(const ::std::string& value) {
  set_has_driverversion();
  if (driverversion_ == &::google::protobuf::internal::kEmptyString) {
    driverversion_ = new ::std::string;
  }
  driverversion_->assign(value);
}
inline void DisplayConfigurationInfo::set_driverversion(const char* value) {
  set_has_driverversion();
  if (driverversion_ == &::google::protobuf::internal::kEmptyString) {
    driverversion_ = new ::std::string;
  }
  driverversion_->assign(value);
}
inline void DisplayConfigurationInfo::set_driverversion(const char* value, size_t size) {
  set_has_driverversion();
  if (driverversion_ == &::google::protobuf::internal::kEmptyString) {
    driverversion_ = new ::std::string;
  }
  driverversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_driverversion() {
  set_has_driverversion();
  if (driverversion_ == &::google::protobuf::internal::kEmptyString) {
    driverversion_ = new ::std::string;
  }
  return driverversion_;
}
inline ::std::string* DisplayConfigurationInfo::release_driverversion() {
  clear_has_driverversion();
  if (driverversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driverversion_;
    driverversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 BitsPerPerl = 16;
inline bool DisplayConfigurationInfo::has_bitsperperl() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_bitsperperl() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DisplayConfigurationInfo::clear_has_bitsperperl() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DisplayConfigurationInfo::clear_bitsperperl() {
  bitsperperl_ = 0;
  clear_has_bitsperperl();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::bitsperperl() const {
  return bitsperperl_;
}
inline void DisplayConfigurationInfo::set_bitsperperl(::google::protobuf::int32 value) {
  set_has_bitsperperl();
  bitsperperl_ = value;
}

// optional int32 DisplayFlags = 17;
inline bool DisplayConfigurationInfo::has_displayflags() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_displayflags() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DisplayConfigurationInfo::clear_has_displayflags() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DisplayConfigurationInfo::clear_displayflags() {
  displayflags_ = 0;
  clear_has_displayflags();
}
inline ::google::protobuf::int32 DisplayConfigurationInfo::displayflags() const {
  return displayflags_;
}
inline void DisplayConfigurationInfo::set_displayflags(::google::protobuf::int32 value) {
  set_has_displayflags();
  displayflags_ = value;
}

// optional double BuyTime = 18;
inline bool DisplayConfigurationInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DisplayConfigurationInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DisplayConfigurationInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double DisplayConfigurationInfo::buytime() const {
  return buytime_;
}
inline void DisplayConfigurationInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 19;
inline bool DisplayConfigurationInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DisplayConfigurationInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DisplayConfigurationInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& DisplayConfigurationInfo::buyprice() const {
  return *buyprice_;
}
inline void DisplayConfigurationInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void DisplayConfigurationInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void DisplayConfigurationInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* DisplayConfigurationInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 20;
inline bool DisplayConfigurationInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DisplayConfigurationInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DisplayConfigurationInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double DisplayConfigurationInfo::dchecktime() const {
  return dchecktime_;
}
inline void DisplayConfigurationInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 21;
inline bool DisplayConfigurationInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DisplayConfigurationInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DisplayConfigurationInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& DisplayConfigurationInfo::otherinfo() const {
  return *otherinfo_;
}
inline void DisplayConfigurationInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void DisplayConfigurationInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void DisplayConfigurationInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* DisplayConfigurationInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 22;
inline bool DisplayConfigurationInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DisplayConfigurationInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DisplayConfigurationInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DisplayConfigurationInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& DisplayConfigurationInfo::buyname() const {
  return *buyname_;
}
inline void DisplayConfigurationInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void DisplayConfigurationInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void DisplayConfigurationInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* DisplayConfigurationInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DisplayConfigurationInfoList

// repeated .isafetec.DisplayConfigurationInfo list = 1;
inline int DisplayConfigurationInfoList::list_size() const {
  return list_.size();
}
inline void DisplayConfigurationInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::DisplayConfigurationInfo& DisplayConfigurationInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::DisplayConfigurationInfo* DisplayConfigurationInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::DisplayConfigurationInfo* DisplayConfigurationInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void DisplayConfigurationInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::DisplayConfigurationInfo* DisplayConfigurationInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DisplayConfigurationInfo >&
DisplayConfigurationInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DisplayConfigurationInfo >*
DisplayConfigurationInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool DisplayConfigurationInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayConfigurationInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplayConfigurationInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplayConfigurationInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 DisplayConfigurationInfoList::alarmed() const {
  return alarmed_;
}
inline void DisplayConfigurationInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool DisplayConfigurationInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayConfigurationInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisplayConfigurationInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisplayConfigurationInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& DisplayConfigurationInfoList::winuser() const {
  return *winuser_;
}
inline void DisplayConfigurationInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DisplayConfigurationInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DisplayConfigurationInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisplayConfigurationInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* DisplayConfigurationInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IDEControllerInfo

// optional string package_code = 1;
inline bool IDEControllerInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IDEControllerInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IDEControllerInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IDEControllerInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& IDEControllerInfo::package_code() const {
  return *package_code_;
}
inline void IDEControllerInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void IDEControllerInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void IDEControllerInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* IDEControllerInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool IDEControllerInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IDEControllerInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IDEControllerInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IDEControllerInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 IDEControllerInfo::checktype() const {
  return checktype_;
}
inline void IDEControllerInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool IDEControllerInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IDEControllerInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IDEControllerInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IDEControllerInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double IDEControllerInfo::scan_time() const {
  return scan_time_;
}
inline void IDEControllerInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool IDEControllerInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IDEControllerInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IDEControllerInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IDEControllerInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double IDEControllerInfo::addtime() const {
  return addtime_;
}
inline void IDEControllerInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 MaxNumberControlled = 7;
inline bool IDEControllerInfo::has_maxnumbercontrolled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IDEControllerInfo::set_has_maxnumbercontrolled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IDEControllerInfo::clear_has_maxnumbercontrolled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IDEControllerInfo::clear_maxnumbercontrolled() {
  maxnumbercontrolled_ = 0;
  clear_has_maxnumbercontrolled();
}
inline ::google::protobuf::int32 IDEControllerInfo::maxnumbercontrolled() const {
  return maxnumbercontrolled_;
}
inline void IDEControllerInfo::set_maxnumbercontrolled(::google::protobuf::int32 value) {
  set_has_maxnumbercontrolled();
  maxnumbercontrolled_ = value;
}

// optional string Description = 10;
inline bool IDEControllerInfo::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IDEControllerInfo::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IDEControllerInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IDEControllerInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& IDEControllerInfo::description() const {
  return *description_;
}
inline void IDEControllerInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void IDEControllerInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void IDEControllerInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* IDEControllerInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 12;
inline bool IDEControllerInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IDEControllerInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IDEControllerInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IDEControllerInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& IDEControllerInfo::manufacturer() const {
  return *manufacturer_;
}
inline void IDEControllerInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void IDEControllerInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void IDEControllerInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* IDEControllerInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 13;
inline bool IDEControllerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IDEControllerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IDEControllerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IDEControllerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& IDEControllerInfo::name() const {
  return *name_;
}
inline void IDEControllerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void IDEControllerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void IDEControllerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* IDEControllerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 14;
inline bool IDEControllerInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IDEControllerInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IDEControllerInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IDEControllerInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& IDEControllerInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void IDEControllerInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void IDEControllerInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void IDEControllerInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* IDEControllerInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 15;
inline bool IDEControllerInfo::has_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IDEControllerInfo::set_has_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IDEControllerInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IDEControllerInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& IDEControllerInfo::status() const {
  return *status_;
}
inline void IDEControllerInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void IDEControllerInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void IDEControllerInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* IDEControllerInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 16;
inline bool IDEControllerInfo::has_availability() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IDEControllerInfo::set_has_availability() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IDEControllerInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IDEControllerInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 IDEControllerInfo::availability() const {
  return availability_;
}
inline void IDEControllerInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 ProtocolSupported = 17;
inline bool IDEControllerInfo::has_protocolsupported() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IDEControllerInfo::set_has_protocolsupported() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IDEControllerInfo::clear_has_protocolsupported() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IDEControllerInfo::clear_protocolsupported() {
  protocolsupported_ = 0;
  clear_has_protocolsupported();
}
inline ::google::protobuf::int32 IDEControllerInfo::protocolsupported() const {
  return protocolsupported_;
}
inline void IDEControllerInfo::set_protocolsupported(::google::protobuf::int32 value) {
  set_has_protocolsupported();
  protocolsupported_ = value;
}

// optional double BuyTime = 18;
inline bool IDEControllerInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IDEControllerInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IDEControllerInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IDEControllerInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double IDEControllerInfo::buytime() const {
  return buytime_;
}
inline void IDEControllerInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 19;
inline bool IDEControllerInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void IDEControllerInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void IDEControllerInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void IDEControllerInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& IDEControllerInfo::buyprice() const {
  return *buyprice_;
}
inline void IDEControllerInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void IDEControllerInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void IDEControllerInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* IDEControllerInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 20;
inline bool IDEControllerInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void IDEControllerInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void IDEControllerInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void IDEControllerInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double IDEControllerInfo::dchecktime() const {
  return dchecktime_;
}
inline void IDEControllerInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 21;
inline bool IDEControllerInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void IDEControllerInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void IDEControllerInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void IDEControllerInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& IDEControllerInfo::otherinfo() const {
  return *otherinfo_;
}
inline void IDEControllerInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void IDEControllerInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void IDEControllerInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* IDEControllerInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 22;
inline bool IDEControllerInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void IDEControllerInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void IDEControllerInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void IDEControllerInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& IDEControllerInfo::buyname() const {
  return *buyname_;
}
inline void IDEControllerInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void IDEControllerInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void IDEControllerInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* IDEControllerInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IDEControllerInfoList

// repeated .isafetec.IDEControllerInfo list = 1;
inline int IDEControllerInfoList::list_size() const {
  return list_.size();
}
inline void IDEControllerInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::IDEControllerInfo& IDEControllerInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::IDEControllerInfo* IDEControllerInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::IDEControllerInfo* IDEControllerInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void IDEControllerInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::IDEControllerInfo* IDEControllerInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::IDEControllerInfo >&
IDEControllerInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::IDEControllerInfo >*
IDEControllerInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool IDEControllerInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IDEControllerInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IDEControllerInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IDEControllerInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 IDEControllerInfoList::alarmed() const {
  return alarmed_;
}
inline void IDEControllerInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool IDEControllerInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IDEControllerInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IDEControllerInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IDEControllerInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& IDEControllerInfoList::winuser() const {
  return *winuser_;
}
inline void IDEControllerInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void IDEControllerInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void IDEControllerInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDEControllerInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* IDEControllerInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InstalledSofteware

// optional string package_code = 1;
inline bool InstalledSofteware::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstalledSofteware::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstalledSofteware::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstalledSofteware::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& InstalledSofteware::package_code() const {
  return *package_code_;
}
inline void InstalledSofteware::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void InstalledSofteware::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void InstalledSofteware::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* InstalledSofteware::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool InstalledSofteware::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstalledSofteware::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstalledSofteware::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstalledSofteware::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 InstalledSofteware::checktype() const {
  return checktype_;
}
inline void InstalledSofteware::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool InstalledSofteware::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstalledSofteware::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstalledSofteware::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstalledSofteware::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double InstalledSofteware::scan_time() const {
  return scan_time_;
}
inline void InstalledSofteware::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool InstalledSofteware::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstalledSofteware::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstalledSofteware::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstalledSofteware::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double InstalledSofteware::addtime() const {
  return addtime_;
}
inline void InstalledSofteware::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional string manufacturer = 4;
inline bool InstalledSofteware::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstalledSofteware::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstalledSofteware::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstalledSofteware::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& InstalledSofteware::manufacturer() const {
  return *manufacturer_;
}
inline void InstalledSofteware::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void InstalledSofteware::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void InstalledSofteware::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* InstalledSofteware::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string installed_path = 5;
inline bool InstalledSofteware::has_installed_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstalledSofteware::set_has_installed_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstalledSofteware::clear_has_installed_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstalledSofteware::clear_installed_path() {
  if (installed_path_ != &::google::protobuf::internal::kEmptyString) {
    installed_path_->clear();
  }
  clear_has_installed_path();
}
inline const ::std::string& InstalledSofteware::installed_path() const {
  return *installed_path_;
}
inline void InstalledSofteware::set_installed_path(const ::std::string& value) {
  set_has_installed_path();
  if (installed_path_ == &::google::protobuf::internal::kEmptyString) {
    installed_path_ = new ::std::string;
  }
  installed_path_->assign(value);
}
inline void InstalledSofteware::set_installed_path(const char* value) {
  set_has_installed_path();
  if (installed_path_ == &::google::protobuf::internal::kEmptyString) {
    installed_path_ = new ::std::string;
  }
  installed_path_->assign(value);
}
inline void InstalledSofteware::set_installed_path(const char* value, size_t size) {
  set_has_installed_path();
  if (installed_path_ == &::google::protobuf::internal::kEmptyString) {
    installed_path_ = new ::std::string;
  }
  installed_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_installed_path() {
  set_has_installed_path();
  if (installed_path_ == &::google::protobuf::internal::kEmptyString) {
    installed_path_ = new ::std::string;
  }
  return installed_path_;
}
inline ::std::string* InstalledSofteware::release_installed_path() {
  clear_has_installed_path();
  if (installed_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = installed_path_;
    installed_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 6;
inline bool InstalledSofteware::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstalledSofteware::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstalledSofteware::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstalledSofteware::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& InstalledSofteware::version() const {
  return *version_;
}
inline void InstalledSofteware::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void InstalledSofteware::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void InstalledSofteware::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* InstalledSofteware::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string installed_time = 7;
inline bool InstalledSofteware::has_installed_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstalledSofteware::set_has_installed_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstalledSofteware::clear_has_installed_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstalledSofteware::clear_installed_time() {
  if (installed_time_ != &::google::protobuf::internal::kEmptyString) {
    installed_time_->clear();
  }
  clear_has_installed_time();
}
inline const ::std::string& InstalledSofteware::installed_time() const {
  return *installed_time_;
}
inline void InstalledSofteware::set_installed_time(const ::std::string& value) {
  set_has_installed_time();
  if (installed_time_ == &::google::protobuf::internal::kEmptyString) {
    installed_time_ = new ::std::string;
  }
  installed_time_->assign(value);
}
inline void InstalledSofteware::set_installed_time(const char* value) {
  set_has_installed_time();
  if (installed_time_ == &::google::protobuf::internal::kEmptyString) {
    installed_time_ = new ::std::string;
  }
  installed_time_->assign(value);
}
inline void InstalledSofteware::set_installed_time(const char* value, size_t size) {
  set_has_installed_time();
  if (installed_time_ == &::google::protobuf::internal::kEmptyString) {
    installed_time_ = new ::std::string;
  }
  installed_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_installed_time() {
  set_has_installed_time();
  if (installed_time_ == &::google::protobuf::internal::kEmptyString) {
    installed_time_ = new ::std::string;
  }
  return installed_time_;
}
inline ::std::string* InstalledSofteware::release_installed_time() {
  clear_has_installed_time();
  if (installed_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = installed_time_;
    installed_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string help_link = 8;
inline bool InstalledSofteware::has_help_link() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstalledSofteware::set_has_help_link() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstalledSofteware::clear_has_help_link() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstalledSofteware::clear_help_link() {
  if (help_link_ != &::google::protobuf::internal::kEmptyString) {
    help_link_->clear();
  }
  clear_has_help_link();
}
inline const ::std::string& InstalledSofteware::help_link() const {
  return *help_link_;
}
inline void InstalledSofteware::set_help_link(const ::std::string& value) {
  set_has_help_link();
  if (help_link_ == &::google::protobuf::internal::kEmptyString) {
    help_link_ = new ::std::string;
  }
  help_link_->assign(value);
}
inline void InstalledSofteware::set_help_link(const char* value) {
  set_has_help_link();
  if (help_link_ == &::google::protobuf::internal::kEmptyString) {
    help_link_ = new ::std::string;
  }
  help_link_->assign(value);
}
inline void InstalledSofteware::set_help_link(const char* value, size_t size) {
  set_has_help_link();
  if (help_link_ == &::google::protobuf::internal::kEmptyString) {
    help_link_ = new ::std::string;
  }
  help_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_help_link() {
  set_has_help_link();
  if (help_link_ == &::google::protobuf::internal::kEmptyString) {
    help_link_ = new ::std::string;
  }
  return help_link_;
}
inline ::std::string* InstalledSofteware::release_help_link() {
  clear_has_help_link();
  if (help_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = help_link_;
    help_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 9;
inline bool InstalledSofteware::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstalledSofteware::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstalledSofteware::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstalledSofteware::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstalledSofteware::name() const {
  return *name_;
}
inline void InstalledSofteware::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstalledSofteware::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstalledSofteware::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InstalledSofteware::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 10;
inline bool InstalledSofteware::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstalledSofteware::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstalledSofteware::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstalledSofteware::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& InstalledSofteware::description() const {
  return *description_;
}
inline void InstalledSofteware::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void InstalledSofteware::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void InstalledSofteware::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSofteware::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* InstalledSofteware::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InstalledSoftewareList

// repeated .isafetec.InstalledSofteware list = 1;
inline int InstalledSoftewareList::list_size() const {
  return list_.size();
}
inline void InstalledSoftewareList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::InstalledSofteware& InstalledSoftewareList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::InstalledSofteware* InstalledSoftewareList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::InstalledSofteware* InstalledSoftewareList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void InstalledSoftewareList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::InstalledSofteware* InstalledSoftewareList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::InstalledSofteware >&
InstalledSoftewareList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::InstalledSofteware >*
InstalledSoftewareList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool InstalledSoftewareList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstalledSoftewareList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstalledSoftewareList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstalledSoftewareList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 InstalledSoftewareList::alarmed() const {
  return alarmed_;
}
inline void InstalledSoftewareList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool InstalledSoftewareList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstalledSoftewareList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstalledSoftewareList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstalledSoftewareList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& InstalledSoftewareList::winuser() const {
  return *winuser_;
}
inline void InstalledSoftewareList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void InstalledSoftewareList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void InstalledSoftewareList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstalledSoftewareList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* InstalledSoftewareList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KeyboardInfo

// optional string package_code = 1;
inline bool KeyboardInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyboardInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyboardInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyboardInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& KeyboardInfo::package_code() const {
  return *package_code_;
}
inline void KeyboardInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void KeyboardInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void KeyboardInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* KeyboardInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool KeyboardInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyboardInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyboardInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyboardInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 KeyboardInfo::checktype() const {
  return checktype_;
}
inline void KeyboardInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool KeyboardInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyboardInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyboardInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyboardInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double KeyboardInfo::scan_time() const {
  return scan_time_;
}
inline void KeyboardInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool KeyboardInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyboardInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyboardInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyboardInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double KeyboardInfo::addtime() const {
  return addtime_;
}
inline void KeyboardInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 Password = 4;
inline bool KeyboardInfo::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeyboardInfo::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeyboardInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeyboardInfo::clear_password() {
  password_ = 0;
  clear_has_password();
}
inline ::google::protobuf::int32 KeyboardInfo::password() const {
  return password_;
}
inline void KeyboardInfo::set_password(::google::protobuf::int32 value) {
  set_has_password();
  password_ = value;
}

// optional int32 IsLocked = 6;
inline bool KeyboardInfo::has_islocked() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeyboardInfo::set_has_islocked() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeyboardInfo::clear_has_islocked() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeyboardInfo::clear_islocked() {
  islocked_ = 0;
  clear_has_islocked();
}
inline ::google::protobuf::int32 KeyboardInfo::islocked() const {
  return islocked_;
}
inline void KeyboardInfo::set_islocked(::google::protobuf::int32 value) {
  set_has_islocked();
  islocked_ = value;
}

// optional string Description = 7;
inline bool KeyboardInfo::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeyboardInfo::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeyboardInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeyboardInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& KeyboardInfo::description() const {
  return *description_;
}
inline void KeyboardInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void KeyboardInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void KeyboardInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* KeyboardInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Layout = 8;
inline bool KeyboardInfo::has_layout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void KeyboardInfo::set_has_layout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void KeyboardInfo::clear_has_layout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void KeyboardInfo::clear_layout() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    layout_->clear();
  }
  clear_has_layout();
}
inline const ::std::string& KeyboardInfo::layout() const {
  return *layout_;
}
inline void KeyboardInfo::set_layout(const ::std::string& value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void KeyboardInfo::set_layout(const char* value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void KeyboardInfo::set_layout(const char* value, size_t size) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_layout() {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  return layout_;
}
inline ::std::string* KeyboardInfo::release_layout() {
  clear_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = layout_;
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 9;
inline bool KeyboardInfo::has_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void KeyboardInfo::set_has_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void KeyboardInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void KeyboardInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& KeyboardInfo::name() const {
  return *name_;
}
inline void KeyboardInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void KeyboardInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void KeyboardInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* KeyboardInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 10;
inline bool KeyboardInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void KeyboardInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void KeyboardInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void KeyboardInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& KeyboardInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void KeyboardInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void KeyboardInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void KeyboardInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* KeyboardInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 11;
inline bool KeyboardInfo::has_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void KeyboardInfo::set_has_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void KeyboardInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void KeyboardInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& KeyboardInfo::status() const {
  return *status_;
}
inline void KeyboardInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void KeyboardInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void KeyboardInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* KeyboardInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 12;
inline bool KeyboardInfo::has_availability() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void KeyboardInfo::set_has_availability() {
  _has_bits_[0] |= 0x00000800u;
}
inline void KeyboardInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void KeyboardInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 KeyboardInfo::availability() const {
  return availability_;
}
inline void KeyboardInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 NumberOfFunctionKeys = 13;
inline bool KeyboardInfo::has_numberoffunctionkeys() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void KeyboardInfo::set_has_numberoffunctionkeys() {
  _has_bits_[0] |= 0x00001000u;
}
inline void KeyboardInfo::clear_has_numberoffunctionkeys() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void KeyboardInfo::clear_numberoffunctionkeys() {
  numberoffunctionkeys_ = 0;
  clear_has_numberoffunctionkeys();
}
inline ::google::protobuf::int32 KeyboardInfo::numberoffunctionkeys() const {
  return numberoffunctionkeys_;
}
inline void KeyboardInfo::set_numberoffunctionkeys(::google::protobuf::int32 value) {
  set_has_numberoffunctionkeys();
  numberoffunctionkeys_ = value;
}

// optional double BuyTime = 14;
inline bool KeyboardInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void KeyboardInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void KeyboardInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void KeyboardInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double KeyboardInfo::buytime() const {
  return buytime_;
}
inline void KeyboardInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 15;
inline bool KeyboardInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void KeyboardInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00004000u;
}
inline void KeyboardInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void KeyboardInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& KeyboardInfo::buyprice() const {
  return *buyprice_;
}
inline void KeyboardInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void KeyboardInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void KeyboardInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* KeyboardInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 16;
inline bool KeyboardInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void KeyboardInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void KeyboardInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void KeyboardInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double KeyboardInfo::dchecktime() const {
  return dchecktime_;
}
inline void KeyboardInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 17;
inline bool KeyboardInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void KeyboardInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void KeyboardInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void KeyboardInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& KeyboardInfo::otherinfo() const {
  return *otherinfo_;
}
inline void KeyboardInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void KeyboardInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void KeyboardInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* KeyboardInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 18;
inline bool KeyboardInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void KeyboardInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void KeyboardInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void KeyboardInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& KeyboardInfo::buyname() const {
  return *buyname_;
}
inline void KeyboardInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void KeyboardInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void KeyboardInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* KeyboardInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KeyboardInfoList

// repeated .isafetec.KeyboardInfo list = 1;
inline int KeyboardInfoList::list_size() const {
  return list_.size();
}
inline void KeyboardInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::KeyboardInfo& KeyboardInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::KeyboardInfo* KeyboardInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::KeyboardInfo* KeyboardInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void KeyboardInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::KeyboardInfo* KeyboardInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::KeyboardInfo >&
KeyboardInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::KeyboardInfo >*
KeyboardInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool KeyboardInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyboardInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyboardInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyboardInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 KeyboardInfoList::alarmed() const {
  return alarmed_;
}
inline void KeyboardInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool KeyboardInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyboardInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyboardInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyboardInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& KeyboardInfoList::winuser() const {
  return *winuser_;
}
inline void KeyboardInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void KeyboardInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void KeyboardInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyboardInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* KeyboardInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogicalDiskInfo

// optional string package_code = 1;
inline bool LogicalDiskInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalDiskInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalDiskInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalDiskInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& LogicalDiskInfo::package_code() const {
  return *package_code_;
}
inline void LogicalDiskInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void LogicalDiskInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void LogicalDiskInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* LogicalDiskInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool LogicalDiskInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalDiskInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalDiskInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalDiskInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 LogicalDiskInfo::checktype() const {
  return checktype_;
}
inline void LogicalDiskInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool LogicalDiskInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalDiskInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicalDiskInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicalDiskInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double LogicalDiskInfo::scan_time() const {
  return scan_time_;
}
inline void LogicalDiskInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool LogicalDiskInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogicalDiskInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogicalDiskInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogicalDiskInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double LogicalDiskInfo::addtime() const {
  return addtime_;
}
inline void LogicalDiskInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 MediaType = 4;
inline bool LogicalDiskInfo::has_mediatype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogicalDiskInfo::set_has_mediatype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogicalDiskInfo::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogicalDiskInfo::clear_mediatype() {
  mediatype_ = 0;
  clear_has_mediatype();
}
inline ::google::protobuf::int32 LogicalDiskInfo::mediatype() const {
  return mediatype_;
}
inline void LogicalDiskInfo::set_mediatype(::google::protobuf::int32 value) {
  set_has_mediatype();
  mediatype_ = value;
}

// optional uint64 FreeSpace = 5;
inline bool LogicalDiskInfo::has_freespace() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogicalDiskInfo::set_has_freespace() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogicalDiskInfo::clear_has_freespace() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogicalDiskInfo::clear_freespace() {
  freespace_ = GOOGLE_ULONGLONG(0);
  clear_has_freespace();
}
inline ::google::protobuf::uint64 LogicalDiskInfo::freespace() const {
  return freespace_;
}
inline void LogicalDiskInfo::set_freespace(::google::protobuf::uint64 value) {
  set_has_freespace();
  freespace_ = value;
}

// optional uint64 Size = 6;
inline bool LogicalDiskInfo::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogicalDiskInfo::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogicalDiskInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogicalDiskInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 LogicalDiskInfo::size() const {
  return size_;
}
inline void LogicalDiskInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional int32 QuotasDisabled = 7;
inline bool LogicalDiskInfo::has_quotasdisabled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogicalDiskInfo::set_has_quotasdisabled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogicalDiskInfo::clear_has_quotasdisabled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogicalDiskInfo::clear_quotasdisabled() {
  quotasdisabled_ = 0;
  clear_has_quotasdisabled();
}
inline ::google::protobuf::int32 LogicalDiskInfo::quotasdisabled() const {
  return quotasdisabled_;
}
inline void LogicalDiskInfo::set_quotasdisabled(::google::protobuf::int32 value) {
  set_has_quotasdisabled();
  quotasdisabled_ = value;
}

// optional int32 QuotasIncomplete = 8;
inline bool LogicalDiskInfo::has_quotasincomplete() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogicalDiskInfo::set_has_quotasincomplete() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogicalDiskInfo::clear_has_quotasincomplete() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogicalDiskInfo::clear_quotasincomplete() {
  quotasincomplete_ = 0;
  clear_has_quotasincomplete();
}
inline ::google::protobuf::int32 LogicalDiskInfo::quotasincomplete() const {
  return quotasincomplete_;
}
inline void LogicalDiskInfo::set_quotasincomplete(::google::protobuf::int32 value) {
  set_has_quotasincomplete();
  quotasincomplete_ = value;
}

// optional int32 QuotasRebuilding = 9;
inline bool LogicalDiskInfo::has_quotasrebuilding() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogicalDiskInfo::set_has_quotasrebuilding() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogicalDiskInfo::clear_has_quotasrebuilding() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogicalDiskInfo::clear_quotasrebuilding() {
  quotasrebuilding_ = 0;
  clear_has_quotasrebuilding();
}
inline ::google::protobuf::int32 LogicalDiskInfo::quotasrebuilding() const {
  return quotasrebuilding_;
}
inline void LogicalDiskInfo::set_quotasrebuilding(::google::protobuf::int32 value) {
  set_has_quotasrebuilding();
  quotasrebuilding_ = value;
}

// optional int32 SupportsDiskQuotas = 10;
inline bool LogicalDiskInfo::has_supportsdiskquotas() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogicalDiskInfo::set_has_supportsdiskquotas() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogicalDiskInfo::clear_has_supportsdiskquotas() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogicalDiskInfo::clear_supportsdiskquotas() {
  supportsdiskquotas_ = 0;
  clear_has_supportsdiskquotas();
}
inline ::google::protobuf::int32 LogicalDiskInfo::supportsdiskquotas() const {
  return supportsdiskquotas_;
}
inline void LogicalDiskInfo::set_supportsdiskquotas(::google::protobuf::int32 value) {
  set_has_supportsdiskquotas();
  supportsdiskquotas_ = value;
}

// optional int32 SupportsFileBasedCompression = 11;
inline bool LogicalDiskInfo::has_supportsfilebasedcompression() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LogicalDiskInfo::set_has_supportsfilebasedcompression() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LogicalDiskInfo::clear_has_supportsfilebasedcompression() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LogicalDiskInfo::clear_supportsfilebasedcompression() {
  supportsfilebasedcompression_ = 0;
  clear_has_supportsfilebasedcompression();
}
inline ::google::protobuf::int32 LogicalDiskInfo::supportsfilebasedcompression() const {
  return supportsfilebasedcompression_;
}
inline void LogicalDiskInfo::set_supportsfilebasedcompression(::google::protobuf::int32 value) {
  set_has_supportsfilebasedcompression();
  supportsfilebasedcompression_ = value;
}

// optional string Description = 14;
inline bool LogicalDiskInfo::has_description() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LogicalDiskInfo::set_has_description() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LogicalDiskInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LogicalDiskInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& LogicalDiskInfo::description() const {
  return *description_;
}
inline void LogicalDiskInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LogicalDiskInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LogicalDiskInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* LogicalDiskInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FileSystem = 15;
inline bool LogicalDiskInfo::has_filesystem() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LogicalDiskInfo::set_has_filesystem() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LogicalDiskInfo::clear_has_filesystem() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LogicalDiskInfo::clear_filesystem() {
  if (filesystem_ != &::google::protobuf::internal::kEmptyString) {
    filesystem_->clear();
  }
  clear_has_filesystem();
}
inline const ::std::string& LogicalDiskInfo::filesystem() const {
  return *filesystem_;
}
inline void LogicalDiskInfo::set_filesystem(const ::std::string& value) {
  set_has_filesystem();
  if (filesystem_ == &::google::protobuf::internal::kEmptyString) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(value);
}
inline void LogicalDiskInfo::set_filesystem(const char* value) {
  set_has_filesystem();
  if (filesystem_ == &::google::protobuf::internal::kEmptyString) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(value);
}
inline void LogicalDiskInfo::set_filesystem(const char* value, size_t size) {
  set_has_filesystem();
  if (filesystem_ == &::google::protobuf::internal::kEmptyString) {
    filesystem_ = new ::std::string;
  }
  filesystem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_filesystem() {
  set_has_filesystem();
  if (filesystem_ == &::google::protobuf::internal::kEmptyString) {
    filesystem_ = new ::std::string;
  }
  return filesystem_;
}
inline ::std::string* LogicalDiskInfo::release_filesystem() {
  clear_has_filesystem();
  if (filesystem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filesystem_;
    filesystem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 16;
inline bool LogicalDiskInfo::has_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LogicalDiskInfo::set_has_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LogicalDiskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LogicalDiskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LogicalDiskInfo::name() const {
  return *name_;
}
inline void LogicalDiskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalDiskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LogicalDiskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LogicalDiskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VolumeName = 19;
inline bool LogicalDiskInfo::has_volumename() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LogicalDiskInfo::set_has_volumename() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LogicalDiskInfo::clear_has_volumename() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LogicalDiskInfo::clear_volumename() {
  if (volumename_ != &::google::protobuf::internal::kEmptyString) {
    volumename_->clear();
  }
  clear_has_volumename();
}
inline const ::std::string& LogicalDiskInfo::volumename() const {
  return *volumename_;
}
inline void LogicalDiskInfo::set_volumename(const ::std::string& value) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(value);
}
inline void LogicalDiskInfo::set_volumename(const char* value) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(value);
}
inline void LogicalDiskInfo::set_volumename(const char* value, size_t size) {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  volumename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_volumename() {
  set_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    volumename_ = new ::std::string;
  }
  return volumename_;
}
inline ::std::string* LogicalDiskInfo::release_volumename() {
  clear_has_volumename();
  if (volumename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volumename_;
    volumename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VolumeSerialNumber = 20;
inline bool LogicalDiskInfo::has_volumeserialnumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LogicalDiskInfo::set_has_volumeserialnumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LogicalDiskInfo::clear_has_volumeserialnumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LogicalDiskInfo::clear_volumeserialnumber() {
  if (volumeserialnumber_ != &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_->clear();
  }
  clear_has_volumeserialnumber();
}
inline const ::std::string& LogicalDiskInfo::volumeserialnumber() const {
  return *volumeserialnumber_;
}
inline void LogicalDiskInfo::set_volumeserialnumber(const ::std::string& value) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(value);
}
inline void LogicalDiskInfo::set_volumeserialnumber(const char* value) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(value);
}
inline void LogicalDiskInfo::set_volumeserialnumber(const char* value, size_t size) {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  volumeserialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_volumeserialnumber() {
  set_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    volumeserialnumber_ = new ::std::string;
  }
  return volumeserialnumber_;
}
inline ::std::string* LogicalDiskInfo::release_volumeserialnumber() {
  clear_has_volumeserialnumber();
  if (volumeserialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volumeserialnumber_;
    volumeserialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 DriveType = 21;
inline bool LogicalDiskInfo::has_drivetype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LogicalDiskInfo::set_has_drivetype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LogicalDiskInfo::clear_has_drivetype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LogicalDiskInfo::clear_drivetype() {
  drivetype_ = 0;
  clear_has_drivetype();
}
inline ::google::protobuf::int32 LogicalDiskInfo::drivetype() const {
  return drivetype_;
}
inline void LogicalDiskInfo::set_drivetype(::google::protobuf::int32 value) {
  set_has_drivetype();
  drivetype_ = value;
}

// optional int32 MaximumComponentLength = 22;
inline bool LogicalDiskInfo::has_maximumcomponentlength() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LogicalDiskInfo::set_has_maximumcomponentlength() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LogicalDiskInfo::clear_has_maximumcomponentlength() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LogicalDiskInfo::clear_maximumcomponentlength() {
  maximumcomponentlength_ = 0;
  clear_has_maximumcomponentlength();
}
inline ::google::protobuf::int32 LogicalDiskInfo::maximumcomponentlength() const {
  return maximumcomponentlength_;
}
inline void LogicalDiskInfo::set_maximumcomponentlength(::google::protobuf::int32 value) {
  set_has_maximumcomponentlength();
  maximumcomponentlength_ = value;
}

// optional double BuyTime = 23;
inline bool LogicalDiskInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LogicalDiskInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LogicalDiskInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LogicalDiskInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double LogicalDiskInfo::buytime() const {
  return buytime_;
}
inline void LogicalDiskInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 24;
inline bool LogicalDiskInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LogicalDiskInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LogicalDiskInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LogicalDiskInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& LogicalDiskInfo::buyprice() const {
  return *buyprice_;
}
inline void LogicalDiskInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void LogicalDiskInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void LogicalDiskInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* LogicalDiskInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 25;
inline bool LogicalDiskInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LogicalDiskInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LogicalDiskInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LogicalDiskInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double LogicalDiskInfo::dchecktime() const {
  return dchecktime_;
}
inline void LogicalDiskInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 26;
inline bool LogicalDiskInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LogicalDiskInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LogicalDiskInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LogicalDiskInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& LogicalDiskInfo::otherinfo() const {
  return *otherinfo_;
}
inline void LogicalDiskInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void LogicalDiskInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void LogicalDiskInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* LogicalDiskInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 27;
inline bool LogicalDiskInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LogicalDiskInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LogicalDiskInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LogicalDiskInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& LogicalDiskInfo::buyname() const {
  return *buyname_;
}
inline void LogicalDiskInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void LogicalDiskInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void LogicalDiskInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* LogicalDiskInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogicalDiskInfoList

// repeated .isafetec.LogicalDiskInfo list = 1;
inline int LogicalDiskInfoList::list_size() const {
  return list_.size();
}
inline void LogicalDiskInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::LogicalDiskInfo& LogicalDiskInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::LogicalDiskInfo* LogicalDiskInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::LogicalDiskInfo* LogicalDiskInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void LogicalDiskInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::LogicalDiskInfo* LogicalDiskInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::LogicalDiskInfo >&
LogicalDiskInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::LogicalDiskInfo >*
LogicalDiskInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool LogicalDiskInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogicalDiskInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogicalDiskInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogicalDiskInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 LogicalDiskInfoList::alarmed() const {
  return alarmed_;
}
inline void LogicalDiskInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool LogicalDiskInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogicalDiskInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogicalDiskInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogicalDiskInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& LogicalDiskInfoList::winuser() const {
  return *winuser_;
}
inline void LogicalDiskInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void LogicalDiskInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void LogicalDiskInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogicalDiskInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* LogicalDiskInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MainBoardInfo

// optional string package_code = 1;
inline bool MainBoardInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MainBoardInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MainBoardInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MainBoardInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& MainBoardInfo::package_code() const {
  return *package_code_;
}
inline void MainBoardInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MainBoardInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MainBoardInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* MainBoardInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool MainBoardInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MainBoardInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MainBoardInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MainBoardInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 MainBoardInfo::checktype() const {
  return checktype_;
}
inline void MainBoardInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool MainBoardInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MainBoardInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MainBoardInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MainBoardInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double MainBoardInfo::scan_time() const {
  return scan_time_;
}
inline void MainBoardInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool MainBoardInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MainBoardInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MainBoardInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MainBoardInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double MainBoardInfo::addtime() const {
  return addtime_;
}
inline void MainBoardInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional string Model = 4;
inline bool MainBoardInfo::has_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MainBoardInfo::set_has_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MainBoardInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MainBoardInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& MainBoardInfo::model() const {
  return *model_;
}
inline void MainBoardInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void MainBoardInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void MainBoardInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* MainBoardInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OtherIdentifyingInfo = 5;
inline bool MainBoardInfo::has_otheridentifyinginfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MainBoardInfo::set_has_otheridentifyinginfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MainBoardInfo::clear_has_otheridentifyinginfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MainBoardInfo::clear_otheridentifyinginfo() {
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_->clear();
  }
  clear_has_otheridentifyinginfo();
}
inline const ::std::string& MainBoardInfo::otheridentifyinginfo() const {
  return *otheridentifyinginfo_;
}
inline void MainBoardInfo::set_otheridentifyinginfo(const ::std::string& value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void MainBoardInfo::set_otheridentifyinginfo(const char* value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void MainBoardInfo::set_otheridentifyinginfo(const char* value, size_t size) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_otheridentifyinginfo() {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  return otheridentifyinginfo_;
}
inline ::std::string* MainBoardInfo::release_otheridentifyinginfo() {
  clear_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otheridentifyinginfo_;
    otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PartNumber = 6;
inline bool MainBoardInfo::has_partnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MainBoardInfo::set_has_partnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MainBoardInfo::clear_has_partnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MainBoardInfo::clear_partnumber() {
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    partnumber_->clear();
  }
  clear_has_partnumber();
}
inline const ::std::string& MainBoardInfo::partnumber() const {
  return *partnumber_;
}
inline void MainBoardInfo::set_partnumber(const ::std::string& value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void MainBoardInfo::set_partnumber(const char* value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void MainBoardInfo::set_partnumber(const char* value, size_t size) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_partnumber() {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  return partnumber_;
}
inline ::std::string* MainBoardInfo::release_partnumber() {
  clear_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnumber_;
    partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Product = 7;
inline bool MainBoardInfo::has_product() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MainBoardInfo::set_has_product() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MainBoardInfo::clear_has_product() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MainBoardInfo::clear_product() {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& MainBoardInfo::product() const {
  return *product_;
}
inline void MainBoardInfo::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void MainBoardInfo::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void MainBoardInfo::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  return product_;
}
inline ::std::string* MainBoardInfo::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string RequirementsDescription = 8;
inline bool MainBoardInfo::has_requirementsdescription() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MainBoardInfo::set_has_requirementsdescription() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MainBoardInfo::clear_has_requirementsdescription() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MainBoardInfo::clear_requirementsdescription() {
  if (requirementsdescription_ != &::google::protobuf::internal::kEmptyString) {
    requirementsdescription_->clear();
  }
  clear_has_requirementsdescription();
}
inline const ::std::string& MainBoardInfo::requirementsdescription() const {
  return *requirementsdescription_;
}
inline void MainBoardInfo::set_requirementsdescription(const ::std::string& value) {
  set_has_requirementsdescription();
  if (requirementsdescription_ == &::google::protobuf::internal::kEmptyString) {
    requirementsdescription_ = new ::std::string;
  }
  requirementsdescription_->assign(value);
}
inline void MainBoardInfo::set_requirementsdescription(const char* value) {
  set_has_requirementsdescription();
  if (requirementsdescription_ == &::google::protobuf::internal::kEmptyString) {
    requirementsdescription_ = new ::std::string;
  }
  requirementsdescription_->assign(value);
}
inline void MainBoardInfo::set_requirementsdescription(const char* value, size_t size) {
  set_has_requirementsdescription();
  if (requirementsdescription_ == &::google::protobuf::internal::kEmptyString) {
    requirementsdescription_ = new ::std::string;
  }
  requirementsdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_requirementsdescription() {
  set_has_requirementsdescription();
  if (requirementsdescription_ == &::google::protobuf::internal::kEmptyString) {
    requirementsdescription_ = new ::std::string;
  }
  return requirementsdescription_;
}
inline ::std::string* MainBoardInfo::release_requirementsdescription() {
  clear_has_requirementsdescription();
  if (requirementsdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requirementsdescription_;
    requirementsdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNumber = 9;
inline bool MainBoardInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MainBoardInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MainBoardInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MainBoardInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& MainBoardInfo::serialnumber() const {
  return *serialnumber_;
}
inline void MainBoardInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void MainBoardInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void MainBoardInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* MainBoardInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SKU = 10;
inline bool MainBoardInfo::has_sku() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MainBoardInfo::set_has_sku() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MainBoardInfo::clear_has_sku() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MainBoardInfo::clear_sku() {
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    sku_->clear();
  }
  clear_has_sku();
}
inline const ::std::string& MainBoardInfo::sku() const {
  return *sku_;
}
inline void MainBoardInfo::set_sku(const ::std::string& value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void MainBoardInfo::set_sku(const char* value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void MainBoardInfo::set_sku(const char* value, size_t size) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_sku() {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  return sku_;
}
inline ::std::string* MainBoardInfo::release_sku() {
  clear_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sku_;
    sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SlotLayout = 11;
inline bool MainBoardInfo::has_slotlayout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MainBoardInfo::set_has_slotlayout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MainBoardInfo::clear_has_slotlayout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MainBoardInfo::clear_slotlayout() {
  if (slotlayout_ != &::google::protobuf::internal::kEmptyString) {
    slotlayout_->clear();
  }
  clear_has_slotlayout();
}
inline const ::std::string& MainBoardInfo::slotlayout() const {
  return *slotlayout_;
}
inline void MainBoardInfo::set_slotlayout(const ::std::string& value) {
  set_has_slotlayout();
  if (slotlayout_ == &::google::protobuf::internal::kEmptyString) {
    slotlayout_ = new ::std::string;
  }
  slotlayout_->assign(value);
}
inline void MainBoardInfo::set_slotlayout(const char* value) {
  set_has_slotlayout();
  if (slotlayout_ == &::google::protobuf::internal::kEmptyString) {
    slotlayout_ = new ::std::string;
  }
  slotlayout_->assign(value);
}
inline void MainBoardInfo::set_slotlayout(const char* value, size_t size) {
  set_has_slotlayout();
  if (slotlayout_ == &::google::protobuf::internal::kEmptyString) {
    slotlayout_ = new ::std::string;
  }
  slotlayout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_slotlayout() {
  set_has_slotlayout();
  if (slotlayout_ == &::google::protobuf::internal::kEmptyString) {
    slotlayout_ = new ::std::string;
  }
  return slotlayout_;
}
inline ::std::string* MainBoardInfo::release_slotlayout() {
  clear_has_slotlayout();
  if (slotlayout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slotlayout_;
    slotlayout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 12;
inline bool MainBoardInfo::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MainBoardInfo::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MainBoardInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MainBoardInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& MainBoardInfo::status() const {
  return *status_;
}
inline void MainBoardInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MainBoardInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MainBoardInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* MainBoardInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Version = 13;
inline bool MainBoardInfo::has_version() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MainBoardInfo::set_has_version() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MainBoardInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MainBoardInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& MainBoardInfo::version() const {
  return *version_;
}
inline void MainBoardInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MainBoardInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MainBoardInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* MainBoardInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 14;
inline bool MainBoardInfo::has_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MainBoardInfo::set_has_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MainBoardInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MainBoardInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MainBoardInfo::name() const {
  return *name_;
}
inline void MainBoardInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MainBoardInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MainBoardInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MainBoardInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 15;
inline bool MainBoardInfo::has_description() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MainBoardInfo::set_has_description() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MainBoardInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MainBoardInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MainBoardInfo::description() const {
  return *description_;
}
inline void MainBoardInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MainBoardInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MainBoardInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* MainBoardInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 16;
inline bool MainBoardInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MainBoardInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MainBoardInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MainBoardInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& MainBoardInfo::manufacturer() const {
  return *manufacturer_;
}
inline void MainBoardInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MainBoardInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MainBoardInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* MainBoardInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double BuyTime = 17;
inline bool MainBoardInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MainBoardInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MainBoardInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MainBoardInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double MainBoardInfo::buytime() const {
  return buytime_;
}
inline void MainBoardInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 18;
inline bool MainBoardInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MainBoardInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MainBoardInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MainBoardInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& MainBoardInfo::buyprice() const {
  return *buyprice_;
}
inline void MainBoardInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MainBoardInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MainBoardInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* MainBoardInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 19;
inline bool MainBoardInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MainBoardInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MainBoardInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MainBoardInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double MainBoardInfo::dchecktime() const {
  return dchecktime_;
}
inline void MainBoardInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 20;
inline bool MainBoardInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MainBoardInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MainBoardInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MainBoardInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& MainBoardInfo::otherinfo() const {
  return *otherinfo_;
}
inline void MainBoardInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MainBoardInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MainBoardInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* MainBoardInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 21;
inline bool MainBoardInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MainBoardInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MainBoardInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MainBoardInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& MainBoardInfo::buyname() const {
  return *buyname_;
}
inline void MainBoardInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MainBoardInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MainBoardInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* MainBoardInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MainBoardInfoList

// repeated .isafetec.MainBoardInfo list = 1;
inline int MainBoardInfoList::list_size() const {
  return list_.size();
}
inline void MainBoardInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::MainBoardInfo& MainBoardInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::MainBoardInfo* MainBoardInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::MainBoardInfo* MainBoardInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void MainBoardInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::MainBoardInfo* MainBoardInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::MainBoardInfo >&
MainBoardInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::MainBoardInfo >*
MainBoardInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool MainBoardInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MainBoardInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MainBoardInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MainBoardInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 MainBoardInfoList::alarmed() const {
  return alarmed_;
}
inline void MainBoardInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool MainBoardInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MainBoardInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MainBoardInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MainBoardInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& MainBoardInfoList::winuser() const {
  return *winuser_;
}
inline void MainBoardInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MainBoardInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MainBoardInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MainBoardInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* MainBoardInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MemoryDeviceInfo

// optional string package_code = 1;
inline bool MemoryDeviceInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryDeviceInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemoryDeviceInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemoryDeviceInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& MemoryDeviceInfo::package_code() const {
  return *package_code_;
}
inline void MemoryDeviceInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MemoryDeviceInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MemoryDeviceInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* MemoryDeviceInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool MemoryDeviceInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryDeviceInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryDeviceInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryDeviceInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 MemoryDeviceInfo::checktype() const {
  return checktype_;
}
inline void MemoryDeviceInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool MemoryDeviceInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryDeviceInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryDeviceInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryDeviceInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double MemoryDeviceInfo::scan_time() const {
  return scan_time_;
}
inline void MemoryDeviceInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool MemoryDeviceInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemoryDeviceInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemoryDeviceInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemoryDeviceInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double MemoryDeviceInfo::addtime() const {
  return addtime_;
}
inline void MemoryDeviceInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional uint64 EndingAddress = 4;
inline bool MemoryDeviceInfo::has_endingaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemoryDeviceInfo::set_has_endingaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemoryDeviceInfo::clear_has_endingaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemoryDeviceInfo::clear_endingaddress() {
  endingaddress_ = GOOGLE_ULONGLONG(0);
  clear_has_endingaddress();
}
inline ::google::protobuf::uint64 MemoryDeviceInfo::endingaddress() const {
  return endingaddress_;
}
inline void MemoryDeviceInfo::set_endingaddress(::google::protobuf::uint64 value) {
  set_has_endingaddress();
  endingaddress_ = value;
}

// optional uint64 StartingAddress = 5;
inline bool MemoryDeviceInfo::has_startingaddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemoryDeviceInfo::set_has_startingaddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemoryDeviceInfo::clear_has_startingaddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemoryDeviceInfo::clear_startingaddress() {
  startingaddress_ = GOOGLE_ULONGLONG(0);
  clear_has_startingaddress();
}
inline ::google::protobuf::uint64 MemoryDeviceInfo::startingaddress() const {
  return startingaddress_;
}
inline void MemoryDeviceInfo::set_startingaddress(::google::protobuf::uint64 value) {
  set_has_startingaddress();
  startingaddress_ = value;
}

// optional string Description = 6;
inline bool MemoryDeviceInfo::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemoryDeviceInfo::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemoryDeviceInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemoryDeviceInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MemoryDeviceInfo::description() const {
  return *description_;
}
inline void MemoryDeviceInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MemoryDeviceInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MemoryDeviceInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* MemoryDeviceInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 7;
inline bool MemoryDeviceInfo::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemoryDeviceInfo::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemoryDeviceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemoryDeviceInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MemoryDeviceInfo::name() const {
  return *name_;
}
inline void MemoryDeviceInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemoryDeviceInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemoryDeviceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MemoryDeviceInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double BuyTime = 8;
inline bool MemoryDeviceInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemoryDeviceInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemoryDeviceInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemoryDeviceInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double MemoryDeviceInfo::buytime() const {
  return buytime_;
}
inline void MemoryDeviceInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 9;
inline bool MemoryDeviceInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MemoryDeviceInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MemoryDeviceInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MemoryDeviceInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& MemoryDeviceInfo::buyprice() const {
  return *buyprice_;
}
inline void MemoryDeviceInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MemoryDeviceInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MemoryDeviceInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* MemoryDeviceInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 10;
inline bool MemoryDeviceInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MemoryDeviceInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MemoryDeviceInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MemoryDeviceInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double MemoryDeviceInfo::dchecktime() const {
  return dchecktime_;
}
inline void MemoryDeviceInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 11;
inline bool MemoryDeviceInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MemoryDeviceInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MemoryDeviceInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MemoryDeviceInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& MemoryDeviceInfo::otherinfo() const {
  return *otherinfo_;
}
inline void MemoryDeviceInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MemoryDeviceInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MemoryDeviceInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* MemoryDeviceInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 12;
inline bool MemoryDeviceInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MemoryDeviceInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MemoryDeviceInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MemoryDeviceInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& MemoryDeviceInfo::buyname() const {
  return *buyname_;
}
inline void MemoryDeviceInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MemoryDeviceInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MemoryDeviceInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* MemoryDeviceInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MemoryDeviceInfoList

// repeated .isafetec.MemoryDeviceInfo list = 1;
inline int MemoryDeviceInfoList::list_size() const {
  return list_.size();
}
inline void MemoryDeviceInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::MemoryDeviceInfo& MemoryDeviceInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::MemoryDeviceInfo* MemoryDeviceInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::MemoryDeviceInfo* MemoryDeviceInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void MemoryDeviceInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::MemoryDeviceInfo* MemoryDeviceInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::MemoryDeviceInfo >&
MemoryDeviceInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::MemoryDeviceInfo >*
MemoryDeviceInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool MemoryDeviceInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryDeviceInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryDeviceInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryDeviceInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 MemoryDeviceInfoList::alarmed() const {
  return alarmed_;
}
inline void MemoryDeviceInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool MemoryDeviceInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryDeviceInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryDeviceInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryDeviceInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& MemoryDeviceInfoList::winuser() const {
  return *winuser_;
}
inline void MemoryDeviceInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MemoryDeviceInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MemoryDeviceInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryDeviceInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* MemoryDeviceInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MemoryInfo

// optional string package_code = 1;
inline bool MemoryInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemoryInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemoryInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& MemoryInfo::package_code() const {
  return *package_code_;
}
inline void MemoryInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MemoryInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MemoryInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* MemoryInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool MemoryInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 MemoryInfo::checktype() const {
  return checktype_;
}
inline void MemoryInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool MemoryInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double MemoryInfo::scan_time() const {
  return scan_time_;
}
inline void MemoryInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool MemoryInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemoryInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemoryInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemoryInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double MemoryInfo::addtime() const {
  return addtime_;
}
inline void MemoryInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 FormFactor = 4;
inline bool MemoryInfo::has_formfactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemoryInfo::set_has_formfactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemoryInfo::clear_has_formfactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemoryInfo::clear_formfactor() {
  formfactor_ = 0;
  clear_has_formfactor();
}
inline ::google::protobuf::int32 MemoryInfo::formfactor() const {
  return formfactor_;
}
inline void MemoryInfo::set_formfactor(::google::protobuf::int32 value) {
  set_has_formfactor();
  formfactor_ = value;
}

// optional int32 InterleaveDataDepth = 5;
inline bool MemoryInfo::has_interleavedatadepth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemoryInfo::set_has_interleavedatadepth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemoryInfo::clear_has_interleavedatadepth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemoryInfo::clear_interleavedatadepth() {
  interleavedatadepth_ = 0;
  clear_has_interleavedatadepth();
}
inline ::google::protobuf::int32 MemoryInfo::interleavedatadepth() const {
  return interleavedatadepth_;
}
inline void MemoryInfo::set_interleavedatadepth(::google::protobuf::int32 value) {
  set_has_interleavedatadepth();
  interleavedatadepth_ = value;
}

// optional int32 InterleavePosition = 6;
inline bool MemoryInfo::has_interleaveposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemoryInfo::set_has_interleaveposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemoryInfo::clear_has_interleaveposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemoryInfo::clear_interleaveposition() {
  interleaveposition_ = 0;
  clear_has_interleaveposition();
}
inline ::google::protobuf::int32 MemoryInfo::interleaveposition() const {
  return interleaveposition_;
}
inline void MemoryInfo::set_interleaveposition(::google::protobuf::int32 value) {
  set_has_interleaveposition();
  interleaveposition_ = value;
}

// optional int32 MemoryType = 7;
inline bool MemoryInfo::has_memorytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemoryInfo::set_has_memorytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemoryInfo::clear_has_memorytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemoryInfo::clear_memorytype() {
  memorytype_ = 0;
  clear_has_memorytype();
}
inline ::google::protobuf::int32 MemoryInfo::memorytype() const {
  return memorytype_;
}
inline void MemoryInfo::set_memorytype(::google::protobuf::int32 value) {
  set_has_memorytype();
  memorytype_ = value;
}

// optional int32 PositionInRow = 8;
inline bool MemoryInfo::has_positioninrow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemoryInfo::set_has_positioninrow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemoryInfo::clear_has_positioninrow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemoryInfo::clear_positioninrow() {
  positioninrow_ = 0;
  clear_has_positioninrow();
}
inline ::google::protobuf::int32 MemoryInfo::positioninrow() const {
  return positioninrow_;
}
inline void MemoryInfo::set_positioninrow(::google::protobuf::int32 value) {
  set_has_positioninrow();
  positioninrow_ = value;
}

// optional int32 Speed = 9;
inline bool MemoryInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MemoryInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MemoryInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MemoryInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 MemoryInfo::speed() const {
  return speed_;
}
inline void MemoryInfo::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 TotalWidth = 10;
inline bool MemoryInfo::has_totalwidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MemoryInfo::set_has_totalwidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MemoryInfo::clear_has_totalwidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MemoryInfo::clear_totalwidth() {
  totalwidth_ = 0;
  clear_has_totalwidth();
}
inline ::google::protobuf::int32 MemoryInfo::totalwidth() const {
  return totalwidth_;
}
inline void MemoryInfo::set_totalwidth(::google::protobuf::int32 value) {
  set_has_totalwidth();
  totalwidth_ = value;
}

// optional int32 TypeDetail = 11;
inline bool MemoryInfo::has_typedetail() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MemoryInfo::set_has_typedetail() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MemoryInfo::clear_has_typedetail() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MemoryInfo::clear_typedetail() {
  typedetail_ = 0;
  clear_has_typedetail();
}
inline ::google::protobuf::int32 MemoryInfo::typedetail() const {
  return typedetail_;
}
inline void MemoryInfo::set_typedetail(::google::protobuf::int32 value) {
  set_has_typedetail();
  typedetail_ = value;
}

// optional int32 PoweredOn = 12;
inline bool MemoryInfo::has_poweredon() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MemoryInfo::set_has_poweredon() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MemoryInfo::clear_has_poweredon() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MemoryInfo::clear_poweredon() {
  poweredon_ = 0;
  clear_has_poweredon();
}
inline ::google::protobuf::int32 MemoryInfo::poweredon() const {
  return poweredon_;
}
inline void MemoryInfo::set_poweredon(::google::protobuf::int32 value) {
  set_has_poweredon();
  poweredon_ = value;
}

// optional string BankLabel = 13;
inline bool MemoryInfo::has_banklabel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MemoryInfo::set_has_banklabel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MemoryInfo::clear_has_banklabel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MemoryInfo::clear_banklabel() {
  if (banklabel_ != &::google::protobuf::internal::kEmptyString) {
    banklabel_->clear();
  }
  clear_has_banklabel();
}
inline const ::std::string& MemoryInfo::banklabel() const {
  return *banklabel_;
}
inline void MemoryInfo::set_banklabel(const ::std::string& value) {
  set_has_banklabel();
  if (banklabel_ == &::google::protobuf::internal::kEmptyString) {
    banklabel_ = new ::std::string;
  }
  banklabel_->assign(value);
}
inline void MemoryInfo::set_banklabel(const char* value) {
  set_has_banklabel();
  if (banklabel_ == &::google::protobuf::internal::kEmptyString) {
    banklabel_ = new ::std::string;
  }
  banklabel_->assign(value);
}
inline void MemoryInfo::set_banklabel(const char* value, size_t size) {
  set_has_banklabel();
  if (banklabel_ == &::google::protobuf::internal::kEmptyString) {
    banklabel_ = new ::std::string;
  }
  banklabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_banklabel() {
  set_has_banklabel();
  if (banklabel_ == &::google::protobuf::internal::kEmptyString) {
    banklabel_ = new ::std::string;
  }
  return banklabel_;
}
inline ::std::string* MemoryInfo::release_banklabel() {
  clear_has_banklabel();
  if (banklabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = banklabel_;
    banklabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 14;
inline bool MemoryInfo::has_description() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MemoryInfo::set_has_description() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MemoryInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MemoryInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MemoryInfo::description() const {
  return *description_;
}
inline void MemoryInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MemoryInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MemoryInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* MemoryInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeviceLocator = 15;
inline bool MemoryInfo::has_devicelocator() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MemoryInfo::set_has_devicelocator() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MemoryInfo::clear_has_devicelocator() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MemoryInfo::clear_devicelocator() {
  if (devicelocator_ != &::google::protobuf::internal::kEmptyString) {
    devicelocator_->clear();
  }
  clear_has_devicelocator();
}
inline const ::std::string& MemoryInfo::devicelocator() const {
  return *devicelocator_;
}
inline void MemoryInfo::set_devicelocator(const ::std::string& value) {
  set_has_devicelocator();
  if (devicelocator_ == &::google::protobuf::internal::kEmptyString) {
    devicelocator_ = new ::std::string;
  }
  devicelocator_->assign(value);
}
inline void MemoryInfo::set_devicelocator(const char* value) {
  set_has_devicelocator();
  if (devicelocator_ == &::google::protobuf::internal::kEmptyString) {
    devicelocator_ = new ::std::string;
  }
  devicelocator_->assign(value);
}
inline void MemoryInfo::set_devicelocator(const char* value, size_t size) {
  set_has_devicelocator();
  if (devicelocator_ == &::google::protobuf::internal::kEmptyString) {
    devicelocator_ = new ::std::string;
  }
  devicelocator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_devicelocator() {
  set_has_devicelocator();
  if (devicelocator_ == &::google::protobuf::internal::kEmptyString) {
    devicelocator_ = new ::std::string;
  }
  return devicelocator_;
}
inline ::std::string* MemoryInfo::release_devicelocator() {
  clear_has_devicelocator();
  if (devicelocator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicelocator_;
    devicelocator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 16;
inline bool MemoryInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MemoryInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MemoryInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MemoryInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& MemoryInfo::manufacturer() const {
  return *manufacturer_;
}
inline void MemoryInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MemoryInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MemoryInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* MemoryInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Model = 17;
inline bool MemoryInfo::has_model() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MemoryInfo::set_has_model() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MemoryInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MemoryInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& MemoryInfo::model() const {
  return *model_;
}
inline void MemoryInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void MemoryInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void MemoryInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* MemoryInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 18;
inline bool MemoryInfo::has_name() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MemoryInfo::set_has_name() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MemoryInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MemoryInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MemoryInfo::name() const {
  return *name_;
}
inline void MemoryInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemoryInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemoryInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MemoryInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OtherIdentifyingInfo = 19;
inline bool MemoryInfo::has_otheridentifyinginfo() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MemoryInfo::set_has_otheridentifyinginfo() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MemoryInfo::clear_has_otheridentifyinginfo() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MemoryInfo::clear_otheridentifyinginfo() {
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_->clear();
  }
  clear_has_otheridentifyinginfo();
}
inline const ::std::string& MemoryInfo::otheridentifyinginfo() const {
  return *otheridentifyinginfo_;
}
inline void MemoryInfo::set_otheridentifyinginfo(const ::std::string& value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void MemoryInfo::set_otheridentifyinginfo(const char* value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void MemoryInfo::set_otheridentifyinginfo(const char* value, size_t size) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_otheridentifyinginfo() {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  return otheridentifyinginfo_;
}
inline ::std::string* MemoryInfo::release_otheridentifyinginfo() {
  clear_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otheridentifyinginfo_;
    otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PartNumber = 20;
inline bool MemoryInfo::has_partnumber() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MemoryInfo::set_has_partnumber() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MemoryInfo::clear_has_partnumber() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MemoryInfo::clear_partnumber() {
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    partnumber_->clear();
  }
  clear_has_partnumber();
}
inline const ::std::string& MemoryInfo::partnumber() const {
  return *partnumber_;
}
inline void MemoryInfo::set_partnumber(const ::std::string& value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void MemoryInfo::set_partnumber(const char* value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void MemoryInfo::set_partnumber(const char* value, size_t size) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_partnumber() {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  return partnumber_;
}
inline ::std::string* MemoryInfo::release_partnumber() {
  clear_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnumber_;
    partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNumber = 21;
inline bool MemoryInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MemoryInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MemoryInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MemoryInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& MemoryInfo::serialnumber() const {
  return *serialnumber_;
}
inline void MemoryInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void MemoryInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void MemoryInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* MemoryInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SKU = 22;
inline bool MemoryInfo::has_sku() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MemoryInfo::set_has_sku() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MemoryInfo::clear_has_sku() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MemoryInfo::clear_sku() {
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    sku_->clear();
  }
  clear_has_sku();
}
inline const ::std::string& MemoryInfo::sku() const {
  return *sku_;
}
inline void MemoryInfo::set_sku(const ::std::string& value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void MemoryInfo::set_sku(const char* value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void MemoryInfo::set_sku(const char* value, size_t size) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_sku() {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  return sku_;
}
inline ::std::string* MemoryInfo::release_sku() {
  clear_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sku_;
    sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 23;
inline bool MemoryInfo::has_status() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MemoryInfo::set_has_status() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MemoryInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MemoryInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& MemoryInfo::status() const {
  return *status_;
}
inline void MemoryInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MemoryInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MemoryInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* MemoryInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Version = 24;
inline bool MemoryInfo::has_version() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MemoryInfo::set_has_version() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MemoryInfo::clear_has_version() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MemoryInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& MemoryInfo::version() const {
  return *version_;
}
inline void MemoryInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MemoryInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void MemoryInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* MemoryInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 Capacity = 25;
inline bool MemoryInfo::has_capacity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MemoryInfo::set_has_capacity() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MemoryInfo::clear_has_capacity() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MemoryInfo::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 MemoryInfo::capacity() const {
  return capacity_;
}
inline void MemoryInfo::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
}

// optional int32 DataWidth = 26;
inline bool MemoryInfo::has_datawidth() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MemoryInfo::set_has_datawidth() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MemoryInfo::clear_has_datawidth() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MemoryInfo::clear_datawidth() {
  datawidth_ = 0;
  clear_has_datawidth();
}
inline ::google::protobuf::int32 MemoryInfo::datawidth() const {
  return datawidth_;
}
inline void MemoryInfo::set_datawidth(::google::protobuf::int32 value) {
  set_has_datawidth();
  datawidth_ = value;
}

// optional double BuyTime = 27;
inline bool MemoryInfo::has_buytime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MemoryInfo::set_has_buytime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MemoryInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MemoryInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double MemoryInfo::buytime() const {
  return buytime_;
}
inline void MemoryInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 28;
inline bool MemoryInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MemoryInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MemoryInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MemoryInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& MemoryInfo::buyprice() const {
  return *buyprice_;
}
inline void MemoryInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MemoryInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MemoryInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* MemoryInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 29;
inline bool MemoryInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MemoryInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MemoryInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MemoryInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double MemoryInfo::dchecktime() const {
  return dchecktime_;
}
inline void MemoryInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 30;
inline bool MemoryInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MemoryInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MemoryInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MemoryInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& MemoryInfo::otherinfo() const {
  return *otherinfo_;
}
inline void MemoryInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MemoryInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MemoryInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* MemoryInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 31;
inline bool MemoryInfo::has_buyname() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MemoryInfo::set_has_buyname() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MemoryInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MemoryInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& MemoryInfo::buyname() const {
  return *buyname_;
}
inline void MemoryInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MemoryInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MemoryInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* MemoryInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MemoryInfoList

// repeated .isafetec.MemoryInfo list = 1;
inline int MemoryInfoList::list_size() const {
  return list_.size();
}
inline void MemoryInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::MemoryInfo& MemoryInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::MemoryInfo* MemoryInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::MemoryInfo* MemoryInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void MemoryInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::MemoryInfo* MemoryInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::MemoryInfo >&
MemoryInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::MemoryInfo >*
MemoryInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool MemoryInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 MemoryInfoList::alarmed() const {
  return alarmed_;
}
inline void MemoryInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool MemoryInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& MemoryInfoList::winuser() const {
  return *winuser_;
}
inline void MemoryInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MemoryInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MemoryInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemoryInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* MemoryInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MouseInfo

// optional string package_code = 1;
inline bool MouseInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MouseInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MouseInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MouseInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& MouseInfo::package_code() const {
  return *package_code_;
}
inline void MouseInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MouseInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void MouseInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* MouseInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool MouseInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 MouseInfo::checktype() const {
  return checktype_;
}
inline void MouseInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool MouseInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MouseInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MouseInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MouseInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double MouseInfo::scan_time() const {
  return scan_time_;
}
inline void MouseInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool MouseInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MouseInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MouseInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MouseInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double MouseInfo::addtime() const {
  return addtime_;
}
inline void MouseInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 DoubleSpeedThreshold = 4;
inline bool MouseInfo::has_doublespeedthreshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MouseInfo::set_has_doublespeedthreshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MouseInfo::clear_has_doublespeedthreshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MouseInfo::clear_doublespeedthreshold() {
  doublespeedthreshold_ = 0;
  clear_has_doublespeedthreshold();
}
inline ::google::protobuf::int32 MouseInfo::doublespeedthreshold() const {
  return doublespeedthreshold_;
}
inline void MouseInfo::set_doublespeedthreshold(::google::protobuf::int32 value) {
  set_has_doublespeedthreshold();
  doublespeedthreshold_ = value;
}

// optional int32 Handedness = 5;
inline bool MouseInfo::has_handedness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MouseInfo::set_has_handedness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MouseInfo::clear_has_handedness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MouseInfo::clear_handedness() {
  handedness_ = 0;
  clear_has_handedness();
}
inline ::google::protobuf::int32 MouseInfo::handedness() const {
  return handedness_;
}
inline void MouseInfo::set_handedness(::google::protobuf::int32 value) {
  set_has_handedness();
  handedness_ = value;
}

// optional int32 NumberOfButtons = 6;
inline bool MouseInfo::has_numberofbuttons() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MouseInfo::set_has_numberofbuttons() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MouseInfo::clear_has_numberofbuttons() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MouseInfo::clear_numberofbuttons() {
  numberofbuttons_ = 0;
  clear_has_numberofbuttons();
}
inline ::google::protobuf::int32 MouseInfo::numberofbuttons() const {
  return numberofbuttons_;
}
inline void MouseInfo::set_numberofbuttons(::google::protobuf::int32 value) {
  set_has_numberofbuttons();
  numberofbuttons_ = value;
}

// optional int32 PointingType = 7;
inline bool MouseInfo::has_pointingtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MouseInfo::set_has_pointingtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MouseInfo::clear_has_pointingtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MouseInfo::clear_pointingtype() {
  pointingtype_ = 0;
  clear_has_pointingtype();
}
inline ::google::protobuf::int32 MouseInfo::pointingtype() const {
  return pointingtype_;
}
inline void MouseInfo::set_pointingtype(::google::protobuf::int32 value) {
  set_has_pointingtype();
  pointingtype_ = value;
}

// optional int32 QuadSpeedThreshold = 8;
inline bool MouseInfo::has_quadspeedthreshold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MouseInfo::set_has_quadspeedthreshold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MouseInfo::clear_has_quadspeedthreshold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MouseInfo::clear_quadspeedthreshold() {
  quadspeedthreshold_ = 0;
  clear_has_quadspeedthreshold();
}
inline ::google::protobuf::int32 MouseInfo::quadspeedthreshold() const {
  return quadspeedthreshold_;
}
inline void MouseInfo::set_quadspeedthreshold(::google::protobuf::int32 value) {
  set_has_quadspeedthreshold();
  quadspeedthreshold_ = value;
}

// optional int32 Resolution = 9;
inline bool MouseInfo::has_resolution() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MouseInfo::set_has_resolution() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MouseInfo::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MouseInfo::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline ::google::protobuf::int32 MouseInfo::resolution() const {
  return resolution_;
}
inline void MouseInfo::set_resolution(::google::protobuf::int32 value) {
  set_has_resolution();
  resolution_ = value;
}

// optional int32 SampleRate = 10;
inline bool MouseInfo::has_samplerate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MouseInfo::set_has_samplerate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MouseInfo::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MouseInfo::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline ::google::protobuf::int32 MouseInfo::samplerate() const {
  return samplerate_;
}
inline void MouseInfo::set_samplerate(::google::protobuf::int32 value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional int32 Synch = 12;
inline bool MouseInfo::has_synch() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MouseInfo::set_has_synch() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MouseInfo::clear_has_synch() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MouseInfo::clear_synch() {
  synch_ = 0;
  clear_has_synch();
}
inline ::google::protobuf::int32 MouseInfo::synch() const {
  return synch_;
}
inline void MouseInfo::set_synch(::google::protobuf::int32 value) {
  set_has_synch();
  synch_ = value;
}

// optional int32 IsLocked = 13;
inline bool MouseInfo::has_islocked() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MouseInfo::set_has_islocked() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MouseInfo::clear_has_islocked() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MouseInfo::clear_islocked() {
  islocked_ = 0;
  clear_has_islocked();
}
inline ::google::protobuf::int32 MouseInfo::islocked() const {
  return islocked_;
}
inline void MouseInfo::set_islocked(::google::protobuf::int32 value) {
  set_has_islocked();
  islocked_ = value;
}

// optional string Description = 14;
inline bool MouseInfo::has_description() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MouseInfo::set_has_description() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MouseInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MouseInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& MouseInfo::description() const {
  return *description_;
}
inline void MouseInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MouseInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void MouseInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* MouseInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string HardwareType = 16;
inline bool MouseInfo::has_hardwaretype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MouseInfo::set_has_hardwaretype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MouseInfo::clear_has_hardwaretype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MouseInfo::clear_hardwaretype() {
  if (hardwaretype_ != &::google::protobuf::internal::kEmptyString) {
    hardwaretype_->clear();
  }
  clear_has_hardwaretype();
}
inline const ::std::string& MouseInfo::hardwaretype() const {
  return *hardwaretype_;
}
inline void MouseInfo::set_hardwaretype(const ::std::string& value) {
  set_has_hardwaretype();
  if (hardwaretype_ == &::google::protobuf::internal::kEmptyString) {
    hardwaretype_ = new ::std::string;
  }
  hardwaretype_->assign(value);
}
inline void MouseInfo::set_hardwaretype(const char* value) {
  set_has_hardwaretype();
  if (hardwaretype_ == &::google::protobuf::internal::kEmptyString) {
    hardwaretype_ = new ::std::string;
  }
  hardwaretype_->assign(value);
}
inline void MouseInfo::set_hardwaretype(const char* value, size_t size) {
  set_has_hardwaretype();
  if (hardwaretype_ == &::google::protobuf::internal::kEmptyString) {
    hardwaretype_ = new ::std::string;
  }
  hardwaretype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_hardwaretype() {
  set_has_hardwaretype();
  if (hardwaretype_ == &::google::protobuf::internal::kEmptyString) {
    hardwaretype_ = new ::std::string;
  }
  return hardwaretype_;
}
inline ::std::string* MouseInfo::release_hardwaretype() {
  clear_has_hardwaretype();
  if (hardwaretype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardwaretype_;
    hardwaretype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string InfFileName = 17;
inline bool MouseInfo::has_inffilename() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MouseInfo::set_has_inffilename() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MouseInfo::clear_has_inffilename() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MouseInfo::clear_inffilename() {
  if (inffilename_ != &::google::protobuf::internal::kEmptyString) {
    inffilename_->clear();
  }
  clear_has_inffilename();
}
inline const ::std::string& MouseInfo::inffilename() const {
  return *inffilename_;
}
inline void MouseInfo::set_inffilename(const ::std::string& value) {
  set_has_inffilename();
  if (inffilename_ == &::google::protobuf::internal::kEmptyString) {
    inffilename_ = new ::std::string;
  }
  inffilename_->assign(value);
}
inline void MouseInfo::set_inffilename(const char* value) {
  set_has_inffilename();
  if (inffilename_ == &::google::protobuf::internal::kEmptyString) {
    inffilename_ = new ::std::string;
  }
  inffilename_->assign(value);
}
inline void MouseInfo::set_inffilename(const char* value, size_t size) {
  set_has_inffilename();
  if (inffilename_ == &::google::protobuf::internal::kEmptyString) {
    inffilename_ = new ::std::string;
  }
  inffilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_inffilename() {
  set_has_inffilename();
  if (inffilename_ == &::google::protobuf::internal::kEmptyString) {
    inffilename_ = new ::std::string;
  }
  return inffilename_;
}
inline ::std::string* MouseInfo::release_inffilename() {
  clear_has_inffilename();
  if (inffilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inffilename_;
    inffilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string InfSection = 18;
inline bool MouseInfo::has_infsection() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MouseInfo::set_has_infsection() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MouseInfo::clear_has_infsection() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MouseInfo::clear_infsection() {
  if (infsection_ != &::google::protobuf::internal::kEmptyString) {
    infsection_->clear();
  }
  clear_has_infsection();
}
inline const ::std::string& MouseInfo::infsection() const {
  return *infsection_;
}
inline void MouseInfo::set_infsection(const ::std::string& value) {
  set_has_infsection();
  if (infsection_ == &::google::protobuf::internal::kEmptyString) {
    infsection_ = new ::std::string;
  }
  infsection_->assign(value);
}
inline void MouseInfo::set_infsection(const char* value) {
  set_has_infsection();
  if (infsection_ == &::google::protobuf::internal::kEmptyString) {
    infsection_ = new ::std::string;
  }
  infsection_->assign(value);
}
inline void MouseInfo::set_infsection(const char* value, size_t size) {
  set_has_infsection();
  if (infsection_ == &::google::protobuf::internal::kEmptyString) {
    infsection_ = new ::std::string;
  }
  infsection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_infsection() {
  set_has_infsection();
  if (infsection_ == &::google::protobuf::internal::kEmptyString) {
    infsection_ = new ::std::string;
  }
  return infsection_;
}
inline ::std::string* MouseInfo::release_infsection() {
  clear_has_infsection();
  if (infsection_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = infsection_;
    infsection_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 19;
inline bool MouseInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MouseInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MouseInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MouseInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& MouseInfo::manufacturer() const {
  return *manufacturer_;
}
inline void MouseInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MouseInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void MouseInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* MouseInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 20;
inline bool MouseInfo::has_name() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MouseInfo::set_has_name() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MouseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MouseInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MouseInfo::name() const {
  return *name_;
}
inline void MouseInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MouseInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MouseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MouseInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 21;
inline bool MouseInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MouseInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MouseInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MouseInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& MouseInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void MouseInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void MouseInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void MouseInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* MouseInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 22;
inline bool MouseInfo::has_status() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MouseInfo::set_has_status() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MouseInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MouseInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& MouseInfo::status() const {
  return *status_;
}
inline void MouseInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MouseInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void MouseInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* MouseInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 23;
inline bool MouseInfo::has_availability() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MouseInfo::set_has_availability() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MouseInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MouseInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 MouseInfo::availability() const {
  return availability_;
}
inline void MouseInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 DeviceInterface = 24;
inline bool MouseInfo::has_deviceinterface() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MouseInfo::set_has_deviceinterface() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MouseInfo::clear_has_deviceinterface() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MouseInfo::clear_deviceinterface() {
  deviceinterface_ = 0;
  clear_has_deviceinterface();
}
inline ::google::protobuf::int32 MouseInfo::deviceinterface() const {
  return deviceinterface_;
}
inline void MouseInfo::set_deviceinterface(::google::protobuf::int32 value) {
  set_has_deviceinterface();
  deviceinterface_ = value;
}

// optional double BuyTime = 25;
inline bool MouseInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MouseInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MouseInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MouseInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double MouseInfo::buytime() const {
  return buytime_;
}
inline void MouseInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 26;
inline bool MouseInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MouseInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MouseInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MouseInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& MouseInfo::buyprice() const {
  return *buyprice_;
}
inline void MouseInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MouseInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void MouseInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* MouseInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 27;
inline bool MouseInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MouseInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MouseInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MouseInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double MouseInfo::dchecktime() const {
  return dchecktime_;
}
inline void MouseInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 28;
inline bool MouseInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MouseInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MouseInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MouseInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& MouseInfo::otherinfo() const {
  return *otherinfo_;
}
inline void MouseInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MouseInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void MouseInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* MouseInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 29;
inline bool MouseInfo::has_buyname() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MouseInfo::set_has_buyname() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MouseInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MouseInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& MouseInfo::buyname() const {
  return *buyname_;
}
inline void MouseInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MouseInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void MouseInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* MouseInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MouseInfoList

// repeated .isafetec.MouseInfo list = 1;
inline int MouseInfoList::list_size() const {
  return list_.size();
}
inline void MouseInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::MouseInfo& MouseInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::MouseInfo* MouseInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::MouseInfo* MouseInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void MouseInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::MouseInfo* MouseInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::MouseInfo >&
MouseInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::MouseInfo >*
MouseInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool MouseInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MouseInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MouseInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MouseInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 MouseInfoList::alarmed() const {
  return alarmed_;
}
inline void MouseInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool MouseInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MouseInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MouseInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MouseInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& MouseInfoList::winuser() const {
  return *winuser_;
}
inline void MouseInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MouseInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void MouseInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MouseInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* MouseInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NetWorkAdapterInfo

// optional string package_code = 1;
inline bool NetWorkAdapterInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetWorkAdapterInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetWorkAdapterInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetWorkAdapterInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& NetWorkAdapterInfo::package_code() const {
  return *package_code_;
}
inline void NetWorkAdapterInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void NetWorkAdapterInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void NetWorkAdapterInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* NetWorkAdapterInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool NetWorkAdapterInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetWorkAdapterInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetWorkAdapterInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetWorkAdapterInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 NetWorkAdapterInfo::checktype() const {
  return checktype_;
}
inline void NetWorkAdapterInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool NetWorkAdapterInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetWorkAdapterInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetWorkAdapterInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetWorkAdapterInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double NetWorkAdapterInfo::scan_time() const {
  return scan_time_;
}
inline void NetWorkAdapterInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool NetWorkAdapterInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetWorkAdapterInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetWorkAdapterInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetWorkAdapterInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double NetWorkAdapterInfo::addtime() const {
  return addtime_;
}
inline void NetWorkAdapterInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 MaxNumberControlled = 4;
inline bool NetWorkAdapterInfo::has_maxnumbercontrolled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetWorkAdapterInfo::set_has_maxnumbercontrolled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetWorkAdapterInfo::clear_has_maxnumbercontrolled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetWorkAdapterInfo::clear_maxnumbercontrolled() {
  maxnumbercontrolled_ = 0;
  clear_has_maxnumbercontrolled();
}
inline ::google::protobuf::int32 NetWorkAdapterInfo::maxnumbercontrolled() const {
  return maxnumbercontrolled_;
}
inline void NetWorkAdapterInfo::set_maxnumbercontrolled(::google::protobuf::int32 value) {
  set_has_maxnumbercontrolled();
  maxnumbercontrolled_ = value;
}

// optional string AdapterType = 5;
inline bool NetWorkAdapterInfo::has_adaptertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetWorkAdapterInfo::set_has_adaptertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetWorkAdapterInfo::clear_has_adaptertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetWorkAdapterInfo::clear_adaptertype() {
  if (adaptertype_ != &::google::protobuf::internal::kEmptyString) {
    adaptertype_->clear();
  }
  clear_has_adaptertype();
}
inline const ::std::string& NetWorkAdapterInfo::adaptertype() const {
  return *adaptertype_;
}
inline void NetWorkAdapterInfo::set_adaptertype(const ::std::string& value) {
  set_has_adaptertype();
  if (adaptertype_ == &::google::protobuf::internal::kEmptyString) {
    adaptertype_ = new ::std::string;
  }
  adaptertype_->assign(value);
}
inline void NetWorkAdapterInfo::set_adaptertype(const char* value) {
  set_has_adaptertype();
  if (adaptertype_ == &::google::protobuf::internal::kEmptyString) {
    adaptertype_ = new ::std::string;
  }
  adaptertype_->assign(value);
}
inline void NetWorkAdapterInfo::set_adaptertype(const char* value, size_t size) {
  set_has_adaptertype();
  if (adaptertype_ == &::google::protobuf::internal::kEmptyString) {
    adaptertype_ = new ::std::string;
  }
  adaptertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_adaptertype() {
  set_has_adaptertype();
  if (adaptertype_ == &::google::protobuf::internal::kEmptyString) {
    adaptertype_ = new ::std::string;
  }
  return adaptertype_;
}
inline ::std::string* NetWorkAdapterInfo::release_adaptertype() {
  clear_has_adaptertype();
  if (adaptertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adaptertype_;
    adaptertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 7;
inline bool NetWorkAdapterInfo::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetWorkAdapterInfo::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetWorkAdapterInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetWorkAdapterInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& NetWorkAdapterInfo::description() const {
  return *description_;
}
inline void NetWorkAdapterInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void NetWorkAdapterInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void NetWorkAdapterInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* NetWorkAdapterInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 8;
inline bool NetWorkAdapterInfo::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetWorkAdapterInfo::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetWorkAdapterInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetWorkAdapterInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NetWorkAdapterInfo::name() const {
  return *name_;
}
inline void NetWorkAdapterInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetWorkAdapterInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NetWorkAdapterInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NetWorkAdapterInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MACAddress = 10;
inline bool NetWorkAdapterInfo::has_macaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetWorkAdapterInfo::set_has_macaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetWorkAdapterInfo::clear_has_macaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetWorkAdapterInfo::clear_macaddress() {
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    macaddress_->clear();
  }
  clear_has_macaddress();
}
inline const ::std::string& NetWorkAdapterInfo::macaddress() const {
  return *macaddress_;
}
inline void NetWorkAdapterInfo::set_macaddress(const ::std::string& value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void NetWorkAdapterInfo::set_macaddress(const char* value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void NetWorkAdapterInfo::set_macaddress(const char* value, size_t size) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_macaddress() {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  return macaddress_;
}
inline ::std::string* NetWorkAdapterInfo::release_macaddress() {
  clear_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macaddress_;
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ProductName = 11;
inline bool NetWorkAdapterInfo::has_productname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetWorkAdapterInfo::set_has_productname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetWorkAdapterInfo::clear_has_productname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetWorkAdapterInfo::clear_productname() {
  if (productname_ != &::google::protobuf::internal::kEmptyString) {
    productname_->clear();
  }
  clear_has_productname();
}
inline const ::std::string& NetWorkAdapterInfo::productname() const {
  return *productname_;
}
inline void NetWorkAdapterInfo::set_productname(const ::std::string& value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void NetWorkAdapterInfo::set_productname(const char* value) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(value);
}
inline void NetWorkAdapterInfo::set_productname(const char* value, size_t size) {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  productname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_productname() {
  set_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    productname_ = new ::std::string;
  }
  return productname_;
}
inline ::std::string* NetWorkAdapterInfo::release_productname() {
  clear_has_productname();
  if (productname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productname_;
    productname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ServiceName = 12;
inline bool NetWorkAdapterInfo::has_servicename() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetWorkAdapterInfo::set_has_servicename() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NetWorkAdapterInfo::clear_has_servicename() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NetWorkAdapterInfo::clear_servicename() {
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    servicename_->clear();
  }
  clear_has_servicename();
}
inline const ::std::string& NetWorkAdapterInfo::servicename() const {
  return *servicename_;
}
inline void NetWorkAdapterInfo::set_servicename(const ::std::string& value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void NetWorkAdapterInfo::set_servicename(const char* value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void NetWorkAdapterInfo::set_servicename(const char* value, size_t size) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_servicename() {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  return servicename_;
}
inline ::std::string* NetWorkAdapterInfo::release_servicename() {
  clear_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servicename_;
    servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 15;
inline bool NetWorkAdapterInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetWorkAdapterInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NetWorkAdapterInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NetWorkAdapterInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& NetWorkAdapterInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void NetWorkAdapterInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void NetWorkAdapterInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void NetWorkAdapterInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* NetWorkAdapterInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 AdapterTypeID = 16;
inline bool NetWorkAdapterInfo::has_adaptertypeid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_adaptertypeid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NetWorkAdapterInfo::clear_has_adaptertypeid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NetWorkAdapterInfo::clear_adaptertypeid() {
  adaptertypeid_ = 0;
  clear_has_adaptertypeid();
}
inline ::google::protobuf::int32 NetWorkAdapterInfo::adaptertypeid() const {
  return adaptertypeid_;
}
inline void NetWorkAdapterInfo::set_adaptertypeid(::google::protobuf::int32 value) {
  set_has_adaptertypeid();
  adaptertypeid_ = value;
}

// optional int32 Index = 17;
inline bool NetWorkAdapterInfo::has_index() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_index() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NetWorkAdapterInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NetWorkAdapterInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 NetWorkAdapterInfo::index() const {
  return index_;
}
inline void NetWorkAdapterInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional double BuyTime = 18;
inline bool NetWorkAdapterInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NetWorkAdapterInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NetWorkAdapterInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double NetWorkAdapterInfo::buytime() const {
  return buytime_;
}
inline void NetWorkAdapterInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 19;
inline bool NetWorkAdapterInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NetWorkAdapterInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NetWorkAdapterInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& NetWorkAdapterInfo::buyprice() const {
  return *buyprice_;
}
inline void NetWorkAdapterInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void NetWorkAdapterInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void NetWorkAdapterInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* NetWorkAdapterInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 20;
inline bool NetWorkAdapterInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NetWorkAdapterInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NetWorkAdapterInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double NetWorkAdapterInfo::dchecktime() const {
  return dchecktime_;
}
inline void NetWorkAdapterInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 21;
inline bool NetWorkAdapterInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NetWorkAdapterInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NetWorkAdapterInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& NetWorkAdapterInfo::otherinfo() const {
  return *otherinfo_;
}
inline void NetWorkAdapterInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void NetWorkAdapterInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void NetWorkAdapterInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* NetWorkAdapterInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 22;
inline bool NetWorkAdapterInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NetWorkAdapterInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NetWorkAdapterInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NetWorkAdapterInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& NetWorkAdapterInfo::buyname() const {
  return *buyname_;
}
inline void NetWorkAdapterInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void NetWorkAdapterInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void NetWorkAdapterInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* NetWorkAdapterInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NetWorkAdapterInfoList

// repeated .isafetec.NetWorkAdapterInfo list = 1;
inline int NetWorkAdapterInfoList::list_size() const {
  return list_.size();
}
inline void NetWorkAdapterInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::NetWorkAdapterInfo& NetWorkAdapterInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::NetWorkAdapterInfo* NetWorkAdapterInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::NetWorkAdapterInfo* NetWorkAdapterInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void NetWorkAdapterInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::NetWorkAdapterInfo* NetWorkAdapterInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::NetWorkAdapterInfo >&
NetWorkAdapterInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::NetWorkAdapterInfo >*
NetWorkAdapterInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool NetWorkAdapterInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetWorkAdapterInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetWorkAdapterInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetWorkAdapterInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 NetWorkAdapterInfoList::alarmed() const {
  return alarmed_;
}
inline void NetWorkAdapterInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool NetWorkAdapterInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetWorkAdapterInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetWorkAdapterInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetWorkAdapterInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& NetWorkAdapterInfoList::winuser() const {
  return *winuser_;
}
inline void NetWorkAdapterInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void NetWorkAdapterInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void NetWorkAdapterInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetWorkAdapterInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* NetWorkAdapterInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PhysicalDiskDriversInfo

// optional string package_code = 1;
inline bool PhysicalDiskDriversInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhysicalDiskDriversInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhysicalDiskDriversInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& PhysicalDiskDriversInfo::package_code() const {
  return *package_code_;
}
inline void PhysicalDiskDriversInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool PhysicalDiskDriversInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicalDiskDriversInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicalDiskDriversInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::checktype() const {
  return checktype_;
}
inline void PhysicalDiskDriversInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool PhysicalDiskDriversInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicalDiskDriversInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicalDiskDriversInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double PhysicalDiskDriversInfo::scan_time() const {
  return scan_time_;
}
inline void PhysicalDiskDriversInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool PhysicalDiskDriversInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhysicalDiskDriversInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhysicalDiskDriversInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double PhysicalDiskDriversInfo::addtime() const {
  return addtime_;
}
inline void PhysicalDiskDriversInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional uint64 DefaultBlockSize = 4;
inline bool PhysicalDiskDriversInfo::has_defaultblocksize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_defaultblocksize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PhysicalDiskDriversInfo::clear_has_defaultblocksize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PhysicalDiskDriversInfo::clear_defaultblocksize() {
  defaultblocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_defaultblocksize();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::defaultblocksize() const {
  return defaultblocksize_;
}
inline void PhysicalDiskDriversInfo::set_defaultblocksize(::google::protobuf::uint64 value) {
  set_has_defaultblocksize();
  defaultblocksize_ = value;
}

// optional int32 Index = 5;
inline bool PhysicalDiskDriversInfo::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PhysicalDiskDriversInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PhysicalDiskDriversInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::index() const {
  return index_;
}
inline void PhysicalDiskDriversInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional uint64 MaxBlockSize = 6;
inline bool PhysicalDiskDriversInfo::has_maxblocksize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_maxblocksize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PhysicalDiskDriversInfo::clear_has_maxblocksize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PhysicalDiskDriversInfo::clear_maxblocksize() {
  maxblocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxblocksize();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::maxblocksize() const {
  return maxblocksize_;
}
inline void PhysicalDiskDriversInfo::set_maxblocksize(::google::protobuf::uint64 value) {
  set_has_maxblocksize();
  maxblocksize_ = value;
}

// optional uint64 MaxMediaSize = 7;
inline bool PhysicalDiskDriversInfo::has_maxmediasize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_maxmediasize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PhysicalDiskDriversInfo::clear_has_maxmediasize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PhysicalDiskDriversInfo::clear_maxmediasize() {
  maxmediasize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxmediasize();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::maxmediasize() const {
  return maxmediasize_;
}
inline void PhysicalDiskDriversInfo::set_maxmediasize(::google::protobuf::uint64 value) {
  set_has_maxmediasize();
  maxmediasize_ = value;
}

// optional uint64 MinBlockSize = 8;
inline bool PhysicalDiskDriversInfo::has_minblocksize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_minblocksize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PhysicalDiskDriversInfo::clear_has_minblocksize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PhysicalDiskDriversInfo::clear_minblocksize() {
  minblocksize_ = GOOGLE_ULONGLONG(0);
  clear_has_minblocksize();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::minblocksize() const {
  return minblocksize_;
}
inline void PhysicalDiskDriversInfo::set_minblocksize(::google::protobuf::uint64 value) {
  set_has_minblocksize();
  minblocksize_ = value;
}

// optional int32 NumberOfMediaSupported = 9;
inline bool PhysicalDiskDriversInfo::has_numberofmediasupported() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_numberofmediasupported() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PhysicalDiskDriversInfo::clear_has_numberofmediasupported() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PhysicalDiskDriversInfo::clear_numberofmediasupported() {
  numberofmediasupported_ = 0;
  clear_has_numberofmediasupported();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::numberofmediasupported() const {
  return numberofmediasupported_;
}
inline void PhysicalDiskDriversInfo::set_numberofmediasupported(::google::protobuf::int32 value) {
  set_has_numberofmediasupported();
  numberofmediasupported_ = value;
}

// optional int32 Partitions = 10;
inline bool PhysicalDiskDriversInfo::has_partitions() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_partitions() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PhysicalDiskDriversInfo::clear_has_partitions() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PhysicalDiskDriversInfo::clear_partitions() {
  partitions_ = 0;
  clear_has_partitions();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::partitions() const {
  return partitions_;
}
inline void PhysicalDiskDriversInfo::set_partitions(::google::protobuf::int32 value) {
  set_has_partitions();
  partitions_ = value;
}

// optional int32 SCSIBus = 11;
inline bool PhysicalDiskDriversInfo::has_scsibus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_scsibus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PhysicalDiskDriversInfo::clear_has_scsibus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PhysicalDiskDriversInfo::clear_scsibus() {
  scsibus_ = 0;
  clear_has_scsibus();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::scsibus() const {
  return scsibus_;
}
inline void PhysicalDiskDriversInfo::set_scsibus(::google::protobuf::int32 value) {
  set_has_scsibus();
  scsibus_ = value;
}

// optional int32 SCSILogicalUnit = 12;
inline bool PhysicalDiskDriversInfo::has_scsilogicalunit() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_scsilogicalunit() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PhysicalDiskDriversInfo::clear_has_scsilogicalunit() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PhysicalDiskDriversInfo::clear_scsilogicalunit() {
  scsilogicalunit_ = 0;
  clear_has_scsilogicalunit();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::scsilogicalunit() const {
  return scsilogicalunit_;
}
inline void PhysicalDiskDriversInfo::set_scsilogicalunit(::google::protobuf::int32 value) {
  set_has_scsilogicalunit();
  scsilogicalunit_ = value;
}

// optional int32 SCSIPort = 13;
inline bool PhysicalDiskDriversInfo::has_scsiport() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_scsiport() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PhysicalDiskDriversInfo::clear_has_scsiport() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PhysicalDiskDriversInfo::clear_scsiport() {
  scsiport_ = 0;
  clear_has_scsiport();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::scsiport() const {
  return scsiport_;
}
inline void PhysicalDiskDriversInfo::set_scsiport(::google::protobuf::int32 value) {
  set_has_scsiport();
  scsiport_ = value;
}

// optional int32 SCSITargetId = 14;
inline bool PhysicalDiskDriversInfo::has_scsitargetid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_scsitargetid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PhysicalDiskDriversInfo::clear_has_scsitargetid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PhysicalDiskDriversInfo::clear_scsitargetid() {
  scsitargetid_ = 0;
  clear_has_scsitargetid();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::scsitargetid() const {
  return scsitargetid_;
}
inline void PhysicalDiskDriversInfo::set_scsitargetid(::google::protobuf::int32 value) {
  set_has_scsitargetid();
  scsitargetid_ = value;
}

// optional int32 SectorsPerTrack = 15;
inline bool PhysicalDiskDriversInfo::has_sectorspertrack() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_sectorspertrack() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PhysicalDiskDriversInfo::clear_has_sectorspertrack() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PhysicalDiskDriversInfo::clear_sectorspertrack() {
  sectorspertrack_ = 0;
  clear_has_sectorspertrack();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::sectorspertrack() const {
  return sectorspertrack_;
}
inline void PhysicalDiskDriversInfo::set_sectorspertrack(::google::protobuf::int32 value) {
  set_has_sectorspertrack();
  sectorspertrack_ = value;
}

// optional int32 Signature = 16;
inline bool PhysicalDiskDriversInfo::has_signature() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_signature() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PhysicalDiskDriversInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PhysicalDiskDriversInfo::clear_signature() {
  signature_ = 0;
  clear_has_signature();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::signature() const {
  return signature_;
}
inline void PhysicalDiskDriversInfo::set_signature(::google::protobuf::int32 value) {
  set_has_signature();
  signature_ = value;
}

// optional uint64 Size = 17;
inline bool PhysicalDiskDriversInfo::has_size() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_size() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PhysicalDiskDriversInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PhysicalDiskDriversInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::size() const {
  return size_;
}
inline void PhysicalDiskDriversInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional uint64 TotalCylinders = 19;
inline bool PhysicalDiskDriversInfo::has_totalcylinders() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_totalcylinders() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PhysicalDiskDriversInfo::clear_has_totalcylinders() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PhysicalDiskDriversInfo::clear_totalcylinders() {
  totalcylinders_ = GOOGLE_ULONGLONG(0);
  clear_has_totalcylinders();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::totalcylinders() const {
  return totalcylinders_;
}
inline void PhysicalDiskDriversInfo::set_totalcylinders(::google::protobuf::uint64 value) {
  set_has_totalcylinders();
  totalcylinders_ = value;
}

// optional int32 TotalHeads = 20;
inline bool PhysicalDiskDriversInfo::has_totalheads() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_totalheads() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PhysicalDiskDriversInfo::clear_has_totalheads() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PhysicalDiskDriversInfo::clear_totalheads() {
  totalheads_ = 0;
  clear_has_totalheads();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::totalheads() const {
  return totalheads_;
}
inline void PhysicalDiskDriversInfo::set_totalheads(::google::protobuf::int32 value) {
  set_has_totalheads();
  totalheads_ = value;
}

// optional uint64 TotalSectors = 21;
inline bool PhysicalDiskDriversInfo::has_totalsectors() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_totalsectors() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PhysicalDiskDriversInfo::clear_has_totalsectors() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PhysicalDiskDriversInfo::clear_totalsectors() {
  totalsectors_ = GOOGLE_ULONGLONG(0);
  clear_has_totalsectors();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::totalsectors() const {
  return totalsectors_;
}
inline void PhysicalDiskDriversInfo::set_totalsectors(::google::protobuf::uint64 value) {
  set_has_totalsectors();
  totalsectors_ = value;
}

// optional uint64 TotalTracks = 22;
inline bool PhysicalDiskDriversInfo::has_totaltracks() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_totaltracks() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PhysicalDiskDriversInfo::clear_has_totaltracks() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PhysicalDiskDriversInfo::clear_totaltracks() {
  totaltracks_ = GOOGLE_ULONGLONG(0);
  clear_has_totaltracks();
}
inline ::google::protobuf::uint64 PhysicalDiskDriversInfo::totaltracks() const {
  return totaltracks_;
}
inline void PhysicalDiskDriversInfo::set_totaltracks(::google::protobuf::uint64 value) {
  set_has_totaltracks();
  totaltracks_ = value;
}

// optional uint32 TracksPerCylinder = 23;
inline bool PhysicalDiskDriversInfo::has_trackspercylinder() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_trackspercylinder() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PhysicalDiskDriversInfo::clear_has_trackspercylinder() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PhysicalDiskDriversInfo::clear_trackspercylinder() {
  trackspercylinder_ = 0u;
  clear_has_trackspercylinder();
}
inline ::google::protobuf::uint32 PhysicalDiskDriversInfo::trackspercylinder() const {
  return trackspercylinder_;
}
inline void PhysicalDiskDriversInfo::set_trackspercylinder(::google::protobuf::uint32 value) {
  set_has_trackspercylinder();
  trackspercylinder_ = value;
}

// optional uint32 MediaLoaded = 24;
inline bool PhysicalDiskDriversInfo::has_medialoaded() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_medialoaded() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PhysicalDiskDriversInfo::clear_has_medialoaded() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PhysicalDiskDriversInfo::clear_medialoaded() {
  medialoaded_ = 0u;
  clear_has_medialoaded();
}
inline ::google::protobuf::uint32 PhysicalDiskDriversInfo::medialoaded() const {
  return medialoaded_;
}
inline void PhysicalDiskDriversInfo::set_medialoaded(::google::protobuf::uint32 value) {
  set_has_medialoaded();
  medialoaded_ = value;
}

// optional int32 NeedsCleaning = 25;
inline bool PhysicalDiskDriversInfo::has_needscleaning() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_needscleaning() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_needscleaning() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PhysicalDiskDriversInfo::clear_needscleaning() {
  needscleaning_ = 0;
  clear_has_needscleaning();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::needscleaning() const {
  return needscleaning_;
}
inline void PhysicalDiskDriversInfo::set_needscleaning(::google::protobuf::int32 value) {
  set_has_needscleaning();
  needscleaning_ = value;
}

// optional string CompressionMethod = 26;
inline bool PhysicalDiskDriversInfo::has_compressionmethod() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_compressionmethod() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_compressionmethod() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PhysicalDiskDriversInfo::clear_compressionmethod() {
  if (compressionmethod_ != &::google::protobuf::internal::kEmptyString) {
    compressionmethod_->clear();
  }
  clear_has_compressionmethod();
}
inline const ::std::string& PhysicalDiskDriversInfo::compressionmethod() const {
  return *compressionmethod_;
}
inline void PhysicalDiskDriversInfo::set_compressionmethod(const ::std::string& value) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_compressionmethod(const char* value) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_compressionmethod(const char* value, size_t size) {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  compressionmethod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_compressionmethod() {
  set_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    compressionmethod_ = new ::std::string;
  }
  return compressionmethod_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_compressionmethod() {
  clear_has_compressionmethod();
  if (compressionmethod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compressionmethod_;
    compressionmethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 27;
inline bool PhysicalDiskDriversInfo::has_description() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_description() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_description() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PhysicalDiskDriversInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& PhysicalDiskDriversInfo::description() const {
  return *description_;
}
inline void PhysicalDiskDriversInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FirmwareRevision = 28;
inline bool PhysicalDiskDriversInfo::has_firmwarerevision() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_firmwarerevision() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_firmwarerevision() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PhysicalDiskDriversInfo::clear_firmwarerevision() {
  if (firmwarerevision_ != &::google::protobuf::internal::kEmptyString) {
    firmwarerevision_->clear();
  }
  clear_has_firmwarerevision();
}
inline const ::std::string& PhysicalDiskDriversInfo::firmwarerevision() const {
  return *firmwarerevision_;
}
inline void PhysicalDiskDriversInfo::set_firmwarerevision(const ::std::string& value) {
  set_has_firmwarerevision();
  if (firmwarerevision_ == &::google::protobuf::internal::kEmptyString) {
    firmwarerevision_ = new ::std::string;
  }
  firmwarerevision_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_firmwarerevision(const char* value) {
  set_has_firmwarerevision();
  if (firmwarerevision_ == &::google::protobuf::internal::kEmptyString) {
    firmwarerevision_ = new ::std::string;
  }
  firmwarerevision_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_firmwarerevision(const char* value, size_t size) {
  set_has_firmwarerevision();
  if (firmwarerevision_ == &::google::protobuf::internal::kEmptyString) {
    firmwarerevision_ = new ::std::string;
  }
  firmwarerevision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_firmwarerevision() {
  set_has_firmwarerevision();
  if (firmwarerevision_ == &::google::protobuf::internal::kEmptyString) {
    firmwarerevision_ = new ::std::string;
  }
  return firmwarerevision_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_firmwarerevision() {
  clear_has_firmwarerevision();
  if (firmwarerevision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firmwarerevision_;
    firmwarerevision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string InterfaceType = 29;
inline bool PhysicalDiskDriversInfo::has_interfacetype() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_interfacetype() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_interfacetype() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PhysicalDiskDriversInfo::clear_interfacetype() {
  if (interfacetype_ != &::google::protobuf::internal::kEmptyString) {
    interfacetype_->clear();
  }
  clear_has_interfacetype();
}
inline const ::std::string& PhysicalDiskDriversInfo::interfacetype() const {
  return *interfacetype_;
}
inline void PhysicalDiskDriversInfo::set_interfacetype(const ::std::string& value) {
  set_has_interfacetype();
  if (interfacetype_ == &::google::protobuf::internal::kEmptyString) {
    interfacetype_ = new ::std::string;
  }
  interfacetype_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_interfacetype(const char* value) {
  set_has_interfacetype();
  if (interfacetype_ == &::google::protobuf::internal::kEmptyString) {
    interfacetype_ = new ::std::string;
  }
  interfacetype_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_interfacetype(const char* value, size_t size) {
  set_has_interfacetype();
  if (interfacetype_ == &::google::protobuf::internal::kEmptyString) {
    interfacetype_ = new ::std::string;
  }
  interfacetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_interfacetype() {
  set_has_interfacetype();
  if (interfacetype_ == &::google::protobuf::internal::kEmptyString) {
    interfacetype_ = new ::std::string;
  }
  return interfacetype_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_interfacetype() {
  clear_has_interfacetype();
  if (interfacetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interfacetype_;
    interfacetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 30;
inline bool PhysicalDiskDriversInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PhysicalDiskDriversInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& PhysicalDiskDriversInfo::manufacturer() const {
  return *manufacturer_;
}
inline void PhysicalDiskDriversInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MediaType = 31;
inline bool PhysicalDiskDriversInfo::has_mediatype() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_mediatype() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_mediatype() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PhysicalDiskDriversInfo::clear_mediatype() {
  if (mediatype_ != &::google::protobuf::internal::kEmptyString) {
    mediatype_->clear();
  }
  clear_has_mediatype();
}
inline const ::std::string& PhysicalDiskDriversInfo::mediatype() const {
  return *mediatype_;
}
inline void PhysicalDiskDriversInfo::set_mediatype(const ::std::string& value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_mediatype(const char* value) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_mediatype(const char* value, size_t size) {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  mediatype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_mediatype() {
  set_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    mediatype_ = new ::std::string;
  }
  return mediatype_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_mediatype() {
  clear_has_mediatype();
  if (mediatype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediatype_;
    mediatype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Model = 32;
inline bool PhysicalDiskDriversInfo::has_model() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_model() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PhysicalDiskDriversInfo::clear_has_model() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PhysicalDiskDriversInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& PhysicalDiskDriversInfo::model() const {
  return *model_;
}
inline void PhysicalDiskDriversInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 33;
inline bool PhysicalDiskDriversInfo::has_name() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_name() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PhysicalDiskDriversInfo::clear_has_name() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PhysicalDiskDriversInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PhysicalDiskDriversInfo::name() const {
  return *name_;
}
inline void PhysicalDiskDriversInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 34;
inline bool PhysicalDiskDriversInfo::has_pnpdeviceid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_pnpdeviceid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PhysicalDiskDriversInfo::clear_has_pnpdeviceid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PhysicalDiskDriversInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& PhysicalDiskDriversInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void PhysicalDiskDriversInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNumber = 35;
inline bool PhysicalDiskDriversInfo::has_serialnumber() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_serialnumber() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PhysicalDiskDriversInfo::clear_has_serialnumber() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PhysicalDiskDriversInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& PhysicalDiskDriversInfo::serialnumber() const {
  return *serialnumber_;
}
inline void PhysicalDiskDriversInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 36;
inline bool PhysicalDiskDriversInfo::has_status() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_status() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PhysicalDiskDriversInfo::clear_has_status() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PhysicalDiskDriversInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& PhysicalDiskDriversInfo::status() const {
  return *status_;
}
inline void PhysicalDiskDriversInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 37;
inline bool PhysicalDiskDriversInfo::has_availability() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_availability() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PhysicalDiskDriversInfo::clear_has_availability() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PhysicalDiskDriversInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::availability() const {
  return availability_;
}
inline void PhysicalDiskDriversInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 BytesPerSector = 38;
inline bool PhysicalDiskDriversInfo::has_bytespersector() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_bytespersector() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PhysicalDiskDriversInfo::clear_has_bytespersector() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PhysicalDiskDriversInfo::clear_bytespersector() {
  bytespersector_ = 0;
  clear_has_bytespersector();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfo::bytespersector() const {
  return bytespersector_;
}
inline void PhysicalDiskDriversInfo::set_bytespersector(::google::protobuf::int32 value) {
  set_has_bytespersector();
  bytespersector_ = value;
}

// optional double BuyTime = 39;
inline bool PhysicalDiskDriversInfo::has_buytime() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_buytime() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PhysicalDiskDriversInfo::clear_has_buytime() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PhysicalDiskDriversInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double PhysicalDiskDriversInfo::buytime() const {
  return buytime_;
}
inline void PhysicalDiskDriversInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 40;
inline bool PhysicalDiskDriversInfo::has_buyprice() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_buyprice() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PhysicalDiskDriversInfo::clear_has_buyprice() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PhysicalDiskDriversInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& PhysicalDiskDriversInfo::buyprice() const {
  return *buyprice_;
}
inline void PhysicalDiskDriversInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 41;
inline bool PhysicalDiskDriversInfo::has_dchecktime() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_dchecktime() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PhysicalDiskDriversInfo::clear_has_dchecktime() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PhysicalDiskDriversInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double PhysicalDiskDriversInfo::dchecktime() const {
  return dchecktime_;
}
inline void PhysicalDiskDriversInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 42;
inline bool PhysicalDiskDriversInfo::has_otherinfo() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_otherinfo() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PhysicalDiskDriversInfo::clear_has_otherinfo() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PhysicalDiskDriversInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& PhysicalDiskDriversInfo::otherinfo() const {
  return *otherinfo_;
}
inline void PhysicalDiskDriversInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 43;
inline bool PhysicalDiskDriversInfo::has_buyname() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PhysicalDiskDriversInfo::set_has_buyname() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PhysicalDiskDriversInfo::clear_has_buyname() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PhysicalDiskDriversInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& PhysicalDiskDriversInfo::buyname() const {
  return *buyname_;
}
inline void PhysicalDiskDriversInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void PhysicalDiskDriversInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* PhysicalDiskDriversInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PhysicalDiskDriversInfoList

// repeated .isafetec.PhysicalDiskDriversInfo list = 1;
inline int PhysicalDiskDriversInfoList::list_size() const {
  return list_.size();
}
inline void PhysicalDiskDriversInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::PhysicalDiskDriversInfo& PhysicalDiskDriversInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::PhysicalDiskDriversInfo* PhysicalDiskDriversInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::PhysicalDiskDriversInfo* PhysicalDiskDriversInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void PhysicalDiskDriversInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::PhysicalDiskDriversInfo* PhysicalDiskDriversInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::PhysicalDiskDriversInfo >&
PhysicalDiskDriversInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::PhysicalDiskDriversInfo >*
PhysicalDiskDriversInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool PhysicalDiskDriversInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicalDiskDriversInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicalDiskDriversInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicalDiskDriversInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 PhysicalDiskDriversInfoList::alarmed() const {
  return alarmed_;
}
inline void PhysicalDiskDriversInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool PhysicalDiskDriversInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicalDiskDriversInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicalDiskDriversInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicalDiskDriversInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& PhysicalDiskDriversInfoList::winuser() const {
  return *winuser_;
}
inline void PhysicalDiskDriversInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void PhysicalDiskDriversInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void PhysicalDiskDriversInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalDiskDriversInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* PhysicalDiskDriversInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PhysicalMediaInfo

// optional string package_code = 1;
inline bool PhysicalMediaInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhysicalMediaInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhysicalMediaInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhysicalMediaInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& PhysicalMediaInfo::package_code() const {
  return *package_code_;
}
inline void PhysicalMediaInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void PhysicalMediaInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void PhysicalMediaInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* PhysicalMediaInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool PhysicalMediaInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicalMediaInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicalMediaInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicalMediaInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::checktype() const {
  return checktype_;
}
inline void PhysicalMediaInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool PhysicalMediaInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicalMediaInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicalMediaInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicalMediaInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double PhysicalMediaInfo::scan_time() const {
  return scan_time_;
}
inline void PhysicalMediaInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool PhysicalMediaInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhysicalMediaInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhysicalMediaInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhysicalMediaInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double PhysicalMediaInfo::addtime() const {
  return addtime_;
}
inline void PhysicalMediaInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 CleanerMedia = 4;
inline bool PhysicalMediaInfo::has_cleanermedia() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PhysicalMediaInfo::set_has_cleanermedia() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PhysicalMediaInfo::clear_has_cleanermedia() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PhysicalMediaInfo::clear_cleanermedia() {
  cleanermedia_ = 0;
  clear_has_cleanermedia();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::cleanermedia() const {
  return cleanermedia_;
}
inline void PhysicalMediaInfo::set_cleanermedia(::google::protobuf::int32 value) {
  set_has_cleanermedia();
  cleanermedia_ = value;
}

// optional int32 HotSwappable = 5;
inline bool PhysicalMediaInfo::has_hotswappable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PhysicalMediaInfo::set_has_hotswappable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PhysicalMediaInfo::clear_has_hotswappable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PhysicalMediaInfo::clear_hotswappable() {
  hotswappable_ = 0;
  clear_has_hotswappable();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::hotswappable() const {
  return hotswappable_;
}
inline void PhysicalMediaInfo::set_hotswappable(::google::protobuf::int32 value) {
  set_has_hotswappable();
  hotswappable_ = value;
}

// optional int32 PoweredOn = 6;
inline bool PhysicalMediaInfo::has_poweredon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PhysicalMediaInfo::set_has_poweredon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PhysicalMediaInfo::clear_has_poweredon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PhysicalMediaInfo::clear_poweredon() {
  poweredon_ = 0;
  clear_has_poweredon();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::poweredon() const {
  return poweredon_;
}
inline void PhysicalMediaInfo::set_poweredon(::google::protobuf::int32 value) {
  set_has_poweredon();
  poweredon_ = value;
}

// optional int32 Removable = 7;
inline bool PhysicalMediaInfo::has_removable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PhysicalMediaInfo::set_has_removable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PhysicalMediaInfo::clear_has_removable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PhysicalMediaInfo::clear_removable() {
  removable_ = 0;
  clear_has_removable();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::removable() const {
  return removable_;
}
inline void PhysicalMediaInfo::set_removable(::google::protobuf::int32 value) {
  set_has_removable();
  removable_ = value;
}

// optional int32 Replaceable = 8;
inline bool PhysicalMediaInfo::has_replaceable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PhysicalMediaInfo::set_has_replaceable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PhysicalMediaInfo::clear_has_replaceable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PhysicalMediaInfo::clear_replaceable() {
  replaceable_ = 0;
  clear_has_replaceable();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::replaceable() const {
  return replaceable_;
}
inline void PhysicalMediaInfo::set_replaceable(::google::protobuf::int32 value) {
  set_has_replaceable();
  replaceable_ = value;
}

// optional int32 WriteProtectOn = 9;
inline bool PhysicalMediaInfo::has_writeprotecton() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PhysicalMediaInfo::set_has_writeprotecton() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PhysicalMediaInfo::clear_has_writeprotecton() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PhysicalMediaInfo::clear_writeprotecton() {
  writeprotecton_ = 0;
  clear_has_writeprotecton();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::writeprotecton() const {
  return writeprotecton_;
}
inline void PhysicalMediaInfo::set_writeprotecton(::google::protobuf::int32 value) {
  set_has_writeprotecton();
  writeprotecton_ = value;
}

// optional string Description = 10;
inline bool PhysicalMediaInfo::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PhysicalMediaInfo::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PhysicalMediaInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PhysicalMediaInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& PhysicalMediaInfo::description() const {
  return *description_;
}
inline void PhysicalMediaInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void PhysicalMediaInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void PhysicalMediaInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* PhysicalMediaInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 11;
inline bool PhysicalMediaInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PhysicalMediaInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PhysicalMediaInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PhysicalMediaInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& PhysicalMediaInfo::manufacturer() const {
  return *manufacturer_;
}
inline void PhysicalMediaInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void PhysicalMediaInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void PhysicalMediaInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* PhysicalMediaInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MediaDescription = 12;
inline bool PhysicalMediaInfo::has_mediadescription() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PhysicalMediaInfo::set_has_mediadescription() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PhysicalMediaInfo::clear_has_mediadescription() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PhysicalMediaInfo::clear_mediadescription() {
  if (mediadescription_ != &::google::protobuf::internal::kEmptyString) {
    mediadescription_->clear();
  }
  clear_has_mediadescription();
}
inline const ::std::string& PhysicalMediaInfo::mediadescription() const {
  return *mediadescription_;
}
inline void PhysicalMediaInfo::set_mediadescription(const ::std::string& value) {
  set_has_mediadescription();
  if (mediadescription_ == &::google::protobuf::internal::kEmptyString) {
    mediadescription_ = new ::std::string;
  }
  mediadescription_->assign(value);
}
inline void PhysicalMediaInfo::set_mediadescription(const char* value) {
  set_has_mediadescription();
  if (mediadescription_ == &::google::protobuf::internal::kEmptyString) {
    mediadescription_ = new ::std::string;
  }
  mediadescription_->assign(value);
}
inline void PhysicalMediaInfo::set_mediadescription(const char* value, size_t size) {
  set_has_mediadescription();
  if (mediadescription_ == &::google::protobuf::internal::kEmptyString) {
    mediadescription_ = new ::std::string;
  }
  mediadescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_mediadescription() {
  set_has_mediadescription();
  if (mediadescription_ == &::google::protobuf::internal::kEmptyString) {
    mediadescription_ = new ::std::string;
  }
  return mediadescription_;
}
inline ::std::string* PhysicalMediaInfo::release_mediadescription() {
  clear_has_mediadescription();
  if (mediadescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mediadescription_;
    mediadescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Model = 13;
inline bool PhysicalMediaInfo::has_model() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PhysicalMediaInfo::set_has_model() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PhysicalMediaInfo::clear_has_model() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PhysicalMediaInfo::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& PhysicalMediaInfo::model() const {
  return *model_;
}
inline void PhysicalMediaInfo::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void PhysicalMediaInfo::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void PhysicalMediaInfo::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* PhysicalMediaInfo::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 14;
inline bool PhysicalMediaInfo::has_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PhysicalMediaInfo::set_has_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PhysicalMediaInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PhysicalMediaInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PhysicalMediaInfo::name() const {
  return *name_;
}
inline void PhysicalMediaInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PhysicalMediaInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PhysicalMediaInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PhysicalMediaInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OtherIdentifyingInfo = 15;
inline bool PhysicalMediaInfo::has_otheridentifyinginfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PhysicalMediaInfo::set_has_otheridentifyinginfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PhysicalMediaInfo::clear_has_otheridentifyinginfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PhysicalMediaInfo::clear_otheridentifyinginfo() {
  if (otheridentifyinginfo_ != &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_->clear();
  }
  clear_has_otheridentifyinginfo();
}
inline const ::std::string& PhysicalMediaInfo::otheridentifyinginfo() const {
  return *otheridentifyinginfo_;
}
inline void PhysicalMediaInfo::set_otheridentifyinginfo(const ::std::string& value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void PhysicalMediaInfo::set_otheridentifyinginfo(const char* value) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(value);
}
inline void PhysicalMediaInfo::set_otheridentifyinginfo(const char* value, size_t size) {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  otheridentifyinginfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_otheridentifyinginfo() {
  set_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    otheridentifyinginfo_ = new ::std::string;
  }
  return otheridentifyinginfo_;
}
inline ::std::string* PhysicalMediaInfo::release_otheridentifyinginfo() {
  clear_has_otheridentifyinginfo();
  if (otheridentifyinginfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otheridentifyinginfo_;
    otheridentifyinginfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PartNumber = 16;
inline bool PhysicalMediaInfo::has_partnumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PhysicalMediaInfo::set_has_partnumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PhysicalMediaInfo::clear_has_partnumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PhysicalMediaInfo::clear_partnumber() {
  if (partnumber_ != &::google::protobuf::internal::kEmptyString) {
    partnumber_->clear();
  }
  clear_has_partnumber();
}
inline const ::std::string& PhysicalMediaInfo::partnumber() const {
  return *partnumber_;
}
inline void PhysicalMediaInfo::set_partnumber(const ::std::string& value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void PhysicalMediaInfo::set_partnumber(const char* value) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(value);
}
inline void PhysicalMediaInfo::set_partnumber(const char* value, size_t size) {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  partnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_partnumber() {
  set_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    partnumber_ = new ::std::string;
  }
  return partnumber_;
}
inline ::std::string* PhysicalMediaInfo::release_partnumber() {
  clear_has_partnumber();
  if (partnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partnumber_;
    partnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SKU = 17;
inline bool PhysicalMediaInfo::has_sku() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PhysicalMediaInfo::set_has_sku() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PhysicalMediaInfo::clear_has_sku() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PhysicalMediaInfo::clear_sku() {
  if (sku_ != &::google::protobuf::internal::kEmptyString) {
    sku_->clear();
  }
  clear_has_sku();
}
inline const ::std::string& PhysicalMediaInfo::sku() const {
  return *sku_;
}
inline void PhysicalMediaInfo::set_sku(const ::std::string& value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void PhysicalMediaInfo::set_sku(const char* value) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(value);
}
inline void PhysicalMediaInfo::set_sku(const char* value, size_t size) {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  sku_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_sku() {
  set_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    sku_ = new ::std::string;
  }
  return sku_;
}
inline ::std::string* PhysicalMediaInfo::release_sku() {
  clear_has_sku();
  if (sku_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sku_;
    sku_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 18;
inline bool PhysicalMediaInfo::has_status() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PhysicalMediaInfo::set_has_status() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PhysicalMediaInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PhysicalMediaInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& PhysicalMediaInfo::status() const {
  return *status_;
}
inline void PhysicalMediaInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void PhysicalMediaInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void PhysicalMediaInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* PhysicalMediaInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Version = 19;
inline bool PhysicalMediaInfo::has_version() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PhysicalMediaInfo::set_has_version() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PhysicalMediaInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PhysicalMediaInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& PhysicalMediaInfo::version() const {
  return *version_;
}
inline void PhysicalMediaInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PhysicalMediaInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PhysicalMediaInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* PhysicalMediaInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SerialNumber = 20;
inline bool PhysicalMediaInfo::has_serialnumber() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PhysicalMediaInfo::set_has_serialnumber() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PhysicalMediaInfo::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PhysicalMediaInfo::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& PhysicalMediaInfo::serialnumber() const {
  return *serialnumber_;
}
inline void PhysicalMediaInfo::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void PhysicalMediaInfo::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void PhysicalMediaInfo::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* PhysicalMediaInfo::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Capacity = 21;
inline bool PhysicalMediaInfo::has_capacity() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PhysicalMediaInfo::set_has_capacity() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PhysicalMediaInfo::clear_has_capacity() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PhysicalMediaInfo::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::capacity() const {
  return capacity_;
}
inline void PhysicalMediaInfo::set_capacity(::google::protobuf::int32 value) {
  set_has_capacity();
  capacity_ = value;
}

// optional int32 MediaType = 22;
inline bool PhysicalMediaInfo::has_mediatype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PhysicalMediaInfo::set_has_mediatype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PhysicalMediaInfo::clear_has_mediatype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PhysicalMediaInfo::clear_mediatype() {
  mediatype_ = 0;
  clear_has_mediatype();
}
inline ::google::protobuf::int32 PhysicalMediaInfo::mediatype() const {
  return mediatype_;
}
inline void PhysicalMediaInfo::set_mediatype(::google::protobuf::int32 value) {
  set_has_mediatype();
  mediatype_ = value;
}

// optional double BuyTime = 23;
inline bool PhysicalMediaInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PhysicalMediaInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PhysicalMediaInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PhysicalMediaInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double PhysicalMediaInfo::buytime() const {
  return buytime_;
}
inline void PhysicalMediaInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 24;
inline bool PhysicalMediaInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PhysicalMediaInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PhysicalMediaInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PhysicalMediaInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& PhysicalMediaInfo::buyprice() const {
  return *buyprice_;
}
inline void PhysicalMediaInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void PhysicalMediaInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void PhysicalMediaInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* PhysicalMediaInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 25;
inline bool PhysicalMediaInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PhysicalMediaInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PhysicalMediaInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PhysicalMediaInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double PhysicalMediaInfo::dchecktime() const {
  return dchecktime_;
}
inline void PhysicalMediaInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 26;
inline bool PhysicalMediaInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PhysicalMediaInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PhysicalMediaInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PhysicalMediaInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& PhysicalMediaInfo::otherinfo() const {
  return *otherinfo_;
}
inline void PhysicalMediaInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void PhysicalMediaInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void PhysicalMediaInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* PhysicalMediaInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 27;
inline bool PhysicalMediaInfo::has_buyname() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PhysicalMediaInfo::set_has_buyname() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PhysicalMediaInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PhysicalMediaInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& PhysicalMediaInfo::buyname() const {
  return *buyname_;
}
inline void PhysicalMediaInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void PhysicalMediaInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void PhysicalMediaInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* PhysicalMediaInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PhysicalMediaInfoList

// repeated .isafetec.PhysicalMediaInfo list = 1;
inline int PhysicalMediaInfoList::list_size() const {
  return list_.size();
}
inline void PhysicalMediaInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::PhysicalMediaInfo& PhysicalMediaInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::PhysicalMediaInfo* PhysicalMediaInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::PhysicalMediaInfo* PhysicalMediaInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void PhysicalMediaInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::PhysicalMediaInfo* PhysicalMediaInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::PhysicalMediaInfo >&
PhysicalMediaInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::PhysicalMediaInfo >*
PhysicalMediaInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool PhysicalMediaInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicalMediaInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicalMediaInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicalMediaInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 PhysicalMediaInfoList::alarmed() const {
  return alarmed_;
}
inline void PhysicalMediaInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool PhysicalMediaInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicalMediaInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicalMediaInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicalMediaInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& PhysicalMediaInfoList::winuser() const {
  return *winuser_;
}
inline void PhysicalMediaInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void PhysicalMediaInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void PhysicalMediaInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PhysicalMediaInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* PhysicalMediaInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// USBControllerInfo

// optional string package_code = 1;
inline bool USBControllerInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void USBControllerInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void USBControllerInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void USBControllerInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& USBControllerInfo::package_code() const {
  return *package_code_;
}
inline void USBControllerInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void USBControllerInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void USBControllerInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* USBControllerInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool USBControllerInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void USBControllerInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void USBControllerInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void USBControllerInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 USBControllerInfo::checktype() const {
  return checktype_;
}
inline void USBControllerInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool USBControllerInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void USBControllerInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void USBControllerInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void USBControllerInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double USBControllerInfo::scan_time() const {
  return scan_time_;
}
inline void USBControllerInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool USBControllerInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void USBControllerInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void USBControllerInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void USBControllerInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double USBControllerInfo::addtime() const {
  return addtime_;
}
inline void USBControllerInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 Availability = 4;
inline bool USBControllerInfo::has_availability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void USBControllerInfo::set_has_availability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void USBControllerInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void USBControllerInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 USBControllerInfo::availability() const {
  return availability_;
}
inline void USBControllerInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 ProtocolSupported = 5;
inline bool USBControllerInfo::has_protocolsupported() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void USBControllerInfo::set_has_protocolsupported() {
  _has_bits_[0] |= 0x00000020u;
}
inline void USBControllerInfo::clear_has_protocolsupported() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void USBControllerInfo::clear_protocolsupported() {
  protocolsupported_ = 0;
  clear_has_protocolsupported();
}
inline ::google::protobuf::int32 USBControllerInfo::protocolsupported() const {
  return protocolsupported_;
}
inline void USBControllerInfo::set_protocolsupported(::google::protobuf::int32 value) {
  set_has_protocolsupported();
  protocolsupported_ = value;
}

// optional int32 MaxNumberControlled = 7;
inline bool USBControllerInfo::has_maxnumbercontrolled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void USBControllerInfo::set_has_maxnumbercontrolled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void USBControllerInfo::clear_has_maxnumbercontrolled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void USBControllerInfo::clear_maxnumbercontrolled() {
  maxnumbercontrolled_ = 0;
  clear_has_maxnumbercontrolled();
}
inline ::google::protobuf::int32 USBControllerInfo::maxnumbercontrolled() const {
  return maxnumbercontrolled_;
}
inline void USBControllerInfo::set_maxnumbercontrolled(::google::protobuf::int32 value) {
  set_has_maxnumbercontrolled();
  maxnumbercontrolled_ = value;
}

// optional string Description = 10;
inline bool USBControllerInfo::has_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void USBControllerInfo::set_has_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void USBControllerInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void USBControllerInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& USBControllerInfo::description() const {
  return *description_;
}
inline void USBControllerInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void USBControllerInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void USBControllerInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* USBControllerInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Manufacturer = 11;
inline bool USBControllerInfo::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void USBControllerInfo::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void USBControllerInfo::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void USBControllerInfo::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& USBControllerInfo::manufacturer() const {
  return *manufacturer_;
}
inline void USBControllerInfo::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void USBControllerInfo::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void USBControllerInfo::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* USBControllerInfo::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 12;
inline bool USBControllerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void USBControllerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void USBControllerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void USBControllerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& USBControllerInfo::name() const {
  return *name_;
}
inline void USBControllerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void USBControllerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void USBControllerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* USBControllerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 13;
inline bool USBControllerInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void USBControllerInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void USBControllerInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void USBControllerInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& USBControllerInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void USBControllerInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void USBControllerInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void USBControllerInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* USBControllerInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 14;
inline bool USBControllerInfo::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void USBControllerInfo::set_has_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void USBControllerInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void USBControllerInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& USBControllerInfo::status() const {
  return *status_;
}
inline void USBControllerInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void USBControllerInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void USBControllerInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* USBControllerInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double BuyTime = 15;
inline bool USBControllerInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void USBControllerInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void USBControllerInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void USBControllerInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double USBControllerInfo::buytime() const {
  return buytime_;
}
inline void USBControllerInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 16;
inline bool USBControllerInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void USBControllerInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void USBControllerInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void USBControllerInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& USBControllerInfo::buyprice() const {
  return *buyprice_;
}
inline void USBControllerInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void USBControllerInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void USBControllerInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* USBControllerInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 17;
inline bool USBControllerInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void USBControllerInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void USBControllerInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void USBControllerInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double USBControllerInfo::dchecktime() const {
  return dchecktime_;
}
inline void USBControllerInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 18;
inline bool USBControllerInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void USBControllerInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void USBControllerInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void USBControllerInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& USBControllerInfo::otherinfo() const {
  return *otherinfo_;
}
inline void USBControllerInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void USBControllerInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void USBControllerInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* USBControllerInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 19;
inline bool USBControllerInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void USBControllerInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void USBControllerInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void USBControllerInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& USBControllerInfo::buyname() const {
  return *buyname_;
}
inline void USBControllerInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void USBControllerInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void USBControllerInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* USBControllerInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// USBControllerInfoList

// repeated .isafetec.USBControllerInfo list = 1;
inline int USBControllerInfoList::list_size() const {
  return list_.size();
}
inline void USBControllerInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::USBControllerInfo& USBControllerInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::USBControllerInfo* USBControllerInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::USBControllerInfo* USBControllerInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void USBControllerInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::USBControllerInfo* USBControllerInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::USBControllerInfo >&
USBControllerInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::USBControllerInfo >*
USBControllerInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool USBControllerInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void USBControllerInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void USBControllerInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void USBControllerInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 USBControllerInfoList::alarmed() const {
  return alarmed_;
}
inline void USBControllerInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool USBControllerInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void USBControllerInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void USBControllerInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void USBControllerInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& USBControllerInfoList::winuser() const {
  return *winuser_;
}
inline void USBControllerInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void USBControllerInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void USBControllerInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* USBControllerInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* USBControllerInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VideoDisplayDeviceInfo

// optional string package_code = 1;
inline bool VideoDisplayDeviceInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoDisplayDeviceInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoDisplayDeviceInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& VideoDisplayDeviceInfo::package_code() const {
  return *package_code_;
}
inline void VideoDisplayDeviceInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool VideoDisplayDeviceInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoDisplayDeviceInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoDisplayDeviceInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::checktype() const {
  return checktype_;
}
inline void VideoDisplayDeviceInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool VideoDisplayDeviceInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoDisplayDeviceInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoDisplayDeviceInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double VideoDisplayDeviceInfo::scan_time() const {
  return scan_time_;
}
inline void VideoDisplayDeviceInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool VideoDisplayDeviceInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoDisplayDeviceInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoDisplayDeviceInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double VideoDisplayDeviceInfo::addtime() const {
  return addtime_;
}
inline void VideoDisplayDeviceInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional int32 DisplayType = 4;
inline bool VideoDisplayDeviceInfo::has_displaytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_displaytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoDisplayDeviceInfo::clear_has_displaytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoDisplayDeviceInfo::clear_displaytype() {
  displaytype_ = 0;
  clear_has_displaytype();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::displaytype() const {
  return displaytype_;
}
inline void VideoDisplayDeviceInfo::set_displaytype(::google::protobuf::int32 value) {
  set_has_displaytype();
  displaytype_ = value;
}

// optional int32 PixelsPerXLogicalInch = 5;
inline bool VideoDisplayDeviceInfo::has_pixelsperxlogicalinch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_pixelsperxlogicalinch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoDisplayDeviceInfo::clear_has_pixelsperxlogicalinch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoDisplayDeviceInfo::clear_pixelsperxlogicalinch() {
  pixelsperxlogicalinch_ = 0;
  clear_has_pixelsperxlogicalinch();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::pixelsperxlogicalinch() const {
  return pixelsperxlogicalinch_;
}
inline void VideoDisplayDeviceInfo::set_pixelsperxlogicalinch(::google::protobuf::int32 value) {
  set_has_pixelsperxlogicalinch();
  pixelsperxlogicalinch_ = value;
}

// optional int32 PixelsPerYLogicalInch = 6;
inline bool VideoDisplayDeviceInfo::has_pixelsperylogicalinch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_pixelsperylogicalinch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VideoDisplayDeviceInfo::clear_has_pixelsperylogicalinch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VideoDisplayDeviceInfo::clear_pixelsperylogicalinch() {
  pixelsperylogicalinch_ = 0;
  clear_has_pixelsperylogicalinch();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::pixelsperylogicalinch() const {
  return pixelsperylogicalinch_;
}
inline void VideoDisplayDeviceInfo::set_pixelsperylogicalinch(::google::protobuf::int32 value) {
  set_has_pixelsperylogicalinch();
  pixelsperylogicalinch_ = value;
}

// optional int32 ScreenHeight = 7;
inline bool VideoDisplayDeviceInfo::has_screenheight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_screenheight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VideoDisplayDeviceInfo::clear_has_screenheight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VideoDisplayDeviceInfo::clear_screenheight() {
  screenheight_ = 0;
  clear_has_screenheight();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::screenheight() const {
  return screenheight_;
}
inline void VideoDisplayDeviceInfo::set_screenheight(::google::protobuf::int32 value) {
  set_has_screenheight();
  screenheight_ = value;
}

// optional int32 ScreenWidth = 8;
inline bool VideoDisplayDeviceInfo::has_screenwidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_screenwidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VideoDisplayDeviceInfo::clear_has_screenwidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VideoDisplayDeviceInfo::clear_screenwidth() {
  screenwidth_ = 0;
  clear_has_screenwidth();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::screenwidth() const {
  return screenwidth_;
}
inline void VideoDisplayDeviceInfo::set_screenwidth(::google::protobuf::int32 value) {
  set_has_screenwidth();
  screenwidth_ = value;
}

// optional int32 IsLocked = 10;
inline bool VideoDisplayDeviceInfo::has_islocked() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_islocked() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VideoDisplayDeviceInfo::clear_has_islocked() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VideoDisplayDeviceInfo::clear_islocked() {
  islocked_ = 0;
  clear_has_islocked();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::islocked() const {
  return islocked_;
}
inline void VideoDisplayDeviceInfo::set_islocked(::google::protobuf::int32 value) {
  set_has_islocked();
  islocked_ = value;
}

// optional string Description = 11;
inline bool VideoDisplayDeviceInfo::has_description() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_description() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VideoDisplayDeviceInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VideoDisplayDeviceInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& VideoDisplayDeviceInfo::description() const {
  return *description_;
}
inline void VideoDisplayDeviceInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MonitorManufacturer = 12;
inline bool VideoDisplayDeviceInfo::has_monitormanufacturer() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_monitormanufacturer() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VideoDisplayDeviceInfo::clear_has_monitormanufacturer() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VideoDisplayDeviceInfo::clear_monitormanufacturer() {
  if (monitormanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    monitormanufacturer_->clear();
  }
  clear_has_monitormanufacturer();
}
inline const ::std::string& VideoDisplayDeviceInfo::monitormanufacturer() const {
  return *monitormanufacturer_;
}
inline void VideoDisplayDeviceInfo::set_monitormanufacturer(const ::std::string& value) {
  set_has_monitormanufacturer();
  if (monitormanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    monitormanufacturer_ = new ::std::string;
  }
  monitormanufacturer_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_monitormanufacturer(const char* value) {
  set_has_monitormanufacturer();
  if (monitormanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    monitormanufacturer_ = new ::std::string;
  }
  monitormanufacturer_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_monitormanufacturer(const char* value, size_t size) {
  set_has_monitormanufacturer();
  if (monitormanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    monitormanufacturer_ = new ::std::string;
  }
  monitormanufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_monitormanufacturer() {
  set_has_monitormanufacturer();
  if (monitormanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    monitormanufacturer_ = new ::std::string;
  }
  return monitormanufacturer_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_monitormanufacturer() {
  clear_has_monitormanufacturer();
  if (monitormanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monitormanufacturer_;
    monitormanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MonitorType = 13;
inline bool VideoDisplayDeviceInfo::has_monitortype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_monitortype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VideoDisplayDeviceInfo::clear_has_monitortype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VideoDisplayDeviceInfo::clear_monitortype() {
  if (monitortype_ != &::google::protobuf::internal::kEmptyString) {
    monitortype_->clear();
  }
  clear_has_monitortype();
}
inline const ::std::string& VideoDisplayDeviceInfo::monitortype() const {
  return *monitortype_;
}
inline void VideoDisplayDeviceInfo::set_monitortype(const ::std::string& value) {
  set_has_monitortype();
  if (monitortype_ == &::google::protobuf::internal::kEmptyString) {
    monitortype_ = new ::std::string;
  }
  monitortype_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_monitortype(const char* value) {
  set_has_monitortype();
  if (monitortype_ == &::google::protobuf::internal::kEmptyString) {
    monitortype_ = new ::std::string;
  }
  monitortype_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_monitortype(const char* value, size_t size) {
  set_has_monitortype();
  if (monitortype_ == &::google::protobuf::internal::kEmptyString) {
    monitortype_ = new ::std::string;
  }
  monitortype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_monitortype() {
  set_has_monitortype();
  if (monitortype_ == &::google::protobuf::internal::kEmptyString) {
    monitortype_ = new ::std::string;
  }
  return monitortype_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_monitortype() {
  clear_has_monitortype();
  if (monitortype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monitortype_;
    monitortype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Name = 14;
inline bool VideoDisplayDeviceInfo::has_name() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_name() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VideoDisplayDeviceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VideoDisplayDeviceInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VideoDisplayDeviceInfo::name() const {
  return *name_;
}
inline void VideoDisplayDeviceInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string PNPDeviceID = 15;
inline bool VideoDisplayDeviceInfo::has_pnpdeviceid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_pnpdeviceid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VideoDisplayDeviceInfo::clear_has_pnpdeviceid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VideoDisplayDeviceInfo::clear_pnpdeviceid() {
  if (pnpdeviceid_ != &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_->clear();
  }
  clear_has_pnpdeviceid();
}
inline const ::std::string& VideoDisplayDeviceInfo::pnpdeviceid() const {
  return *pnpdeviceid_;
}
inline void VideoDisplayDeviceInfo::set_pnpdeviceid(const ::std::string& value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_pnpdeviceid(const char* value) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_pnpdeviceid(const char* value, size_t size) {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  pnpdeviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_pnpdeviceid() {
  set_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    pnpdeviceid_ = new ::std::string;
  }
  return pnpdeviceid_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_pnpdeviceid() {
  clear_has_pnpdeviceid();
  if (pnpdeviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnpdeviceid_;
    pnpdeviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Status = 16;
inline bool VideoDisplayDeviceInfo::has_status() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_status() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VideoDisplayDeviceInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VideoDisplayDeviceInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& VideoDisplayDeviceInfo::status() const {
  return *status_;
}
inline void VideoDisplayDeviceInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 Availability = 17;
inline bool VideoDisplayDeviceInfo::has_availability() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_availability() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VideoDisplayDeviceInfo::clear_has_availability() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VideoDisplayDeviceInfo::clear_availability() {
  availability_ = 0;
  clear_has_availability();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::availability() const {
  return availability_;
}
inline void VideoDisplayDeviceInfo::set_availability(::google::protobuf::int32 value) {
  set_has_availability();
  availability_ = value;
}

// optional int32 Bandwidth = 18;
inline bool VideoDisplayDeviceInfo::has_bandwidth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_bandwidth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VideoDisplayDeviceInfo::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VideoDisplayDeviceInfo::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfo::bandwidth() const {
  return bandwidth_;
}
inline void VideoDisplayDeviceInfo::set_bandwidth(::google::protobuf::int32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional double BuyTime = 19;
inline bool VideoDisplayDeviceInfo::has_buytime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_buytime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VideoDisplayDeviceInfo::clear_has_buytime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VideoDisplayDeviceInfo::clear_buytime() {
  buytime_ = 0;
  clear_has_buytime();
}
inline double VideoDisplayDeviceInfo::buytime() const {
  return buytime_;
}
inline void VideoDisplayDeviceInfo::set_buytime(double value) {
  set_has_buytime();
  buytime_ = value;
}

// optional string BuyPrice = 20;
inline bool VideoDisplayDeviceInfo::has_buyprice() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_buyprice() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VideoDisplayDeviceInfo::clear_has_buyprice() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VideoDisplayDeviceInfo::clear_buyprice() {
  if (buyprice_ != &::google::protobuf::internal::kEmptyString) {
    buyprice_->clear();
  }
  clear_has_buyprice();
}
inline const ::std::string& VideoDisplayDeviceInfo::buyprice() const {
  return *buyprice_;
}
inline void VideoDisplayDeviceInfo::set_buyprice(const ::std::string& value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_buyprice(const char* value) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_buyprice(const char* value, size_t size) {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  buyprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_buyprice() {
  set_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    buyprice_ = new ::std::string;
  }
  return buyprice_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_buyprice() {
  clear_has_buyprice();
  if (buyprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyprice_;
    buyprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double DCheckTime = 21;
inline bool VideoDisplayDeviceInfo::has_dchecktime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_dchecktime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VideoDisplayDeviceInfo::clear_has_dchecktime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VideoDisplayDeviceInfo::clear_dchecktime() {
  dchecktime_ = 0;
  clear_has_dchecktime();
}
inline double VideoDisplayDeviceInfo::dchecktime() const {
  return dchecktime_;
}
inline void VideoDisplayDeviceInfo::set_dchecktime(double value) {
  set_has_dchecktime();
  dchecktime_ = value;
}

// optional string OtherInfo = 22;
inline bool VideoDisplayDeviceInfo::has_otherinfo() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_otherinfo() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VideoDisplayDeviceInfo::clear_has_otherinfo() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VideoDisplayDeviceInfo::clear_otherinfo() {
  if (otherinfo_ != &::google::protobuf::internal::kEmptyString) {
    otherinfo_->clear();
  }
  clear_has_otherinfo();
}
inline const ::std::string& VideoDisplayDeviceInfo::otherinfo() const {
  return *otherinfo_;
}
inline void VideoDisplayDeviceInfo::set_otherinfo(const ::std::string& value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_otherinfo(const char* value) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_otherinfo(const char* value, size_t size) {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  otherinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_otherinfo() {
  set_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    otherinfo_ = new ::std::string;
  }
  return otherinfo_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_otherinfo() {
  clear_has_otherinfo();
  if (otherinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otherinfo_;
    otherinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string BuyName = 23;
inline bool VideoDisplayDeviceInfo::has_buyname() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VideoDisplayDeviceInfo::set_has_buyname() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VideoDisplayDeviceInfo::clear_has_buyname() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VideoDisplayDeviceInfo::clear_buyname() {
  if (buyname_ != &::google::protobuf::internal::kEmptyString) {
    buyname_->clear();
  }
  clear_has_buyname();
}
inline const ::std::string& VideoDisplayDeviceInfo::buyname() const {
  return *buyname_;
}
inline void VideoDisplayDeviceInfo::set_buyname(const ::std::string& value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_buyname(const char* value) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(value);
}
inline void VideoDisplayDeviceInfo::set_buyname(const char* value, size_t size) {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  buyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfo::mutable_buyname() {
  set_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    buyname_ = new ::std::string;
  }
  return buyname_;
}
inline ::std::string* VideoDisplayDeviceInfo::release_buyname() {
  clear_has_buyname();
  if (buyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buyname_;
    buyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VideoDisplayDeviceInfoList

// repeated .isafetec.VideoDisplayDeviceInfo list = 1;
inline int VideoDisplayDeviceInfoList::list_size() const {
  return list_.size();
}
inline void VideoDisplayDeviceInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::VideoDisplayDeviceInfo& VideoDisplayDeviceInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::VideoDisplayDeviceInfo* VideoDisplayDeviceInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::VideoDisplayDeviceInfo* VideoDisplayDeviceInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void VideoDisplayDeviceInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::VideoDisplayDeviceInfo* VideoDisplayDeviceInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::VideoDisplayDeviceInfo >&
VideoDisplayDeviceInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::VideoDisplayDeviceInfo >*
VideoDisplayDeviceInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool VideoDisplayDeviceInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoDisplayDeviceInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoDisplayDeviceInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoDisplayDeviceInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 VideoDisplayDeviceInfoList::alarmed() const {
  return alarmed_;
}
inline void VideoDisplayDeviceInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool VideoDisplayDeviceInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoDisplayDeviceInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoDisplayDeviceInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoDisplayDeviceInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& VideoDisplayDeviceInfoList::winuser() const {
  return *winuser_;
}
inline void VideoDisplayDeviceInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void VideoDisplayDeviceInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void VideoDisplayDeviceInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoDisplayDeviceInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* VideoDisplayDeviceInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CltServiceInfo

// optional string service_name = 1;
inline bool CltServiceInfo::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltServiceInfo::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltServiceInfo::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltServiceInfo::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::kEmptyString) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& CltServiceInfo::service_name() const {
  return *service_name_;
}
inline void CltServiceInfo::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void CltServiceInfo::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
}
inline void CltServiceInfo::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltServiceInfo::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    service_name_ = new ::std::string;
  }
  return service_name_;
}
inline ::std::string* CltServiceInfo::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dispaly_name = 2;
inline bool CltServiceInfo::has_dispaly_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltServiceInfo::set_has_dispaly_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltServiceInfo::clear_has_dispaly_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltServiceInfo::clear_dispaly_name() {
  if (dispaly_name_ != &::google::protobuf::internal::kEmptyString) {
    dispaly_name_->clear();
  }
  clear_has_dispaly_name();
}
inline const ::std::string& CltServiceInfo::dispaly_name() const {
  return *dispaly_name_;
}
inline void CltServiceInfo::set_dispaly_name(const ::std::string& value) {
  set_has_dispaly_name();
  if (dispaly_name_ == &::google::protobuf::internal::kEmptyString) {
    dispaly_name_ = new ::std::string;
  }
  dispaly_name_->assign(value);
}
inline void CltServiceInfo::set_dispaly_name(const char* value) {
  set_has_dispaly_name();
  if (dispaly_name_ == &::google::protobuf::internal::kEmptyString) {
    dispaly_name_ = new ::std::string;
  }
  dispaly_name_->assign(value);
}
inline void CltServiceInfo::set_dispaly_name(const char* value, size_t size) {
  set_has_dispaly_name();
  if (dispaly_name_ == &::google::protobuf::internal::kEmptyString) {
    dispaly_name_ = new ::std::string;
  }
  dispaly_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltServiceInfo::mutable_dispaly_name() {
  set_has_dispaly_name();
  if (dispaly_name_ == &::google::protobuf::internal::kEmptyString) {
    dispaly_name_ = new ::std::string;
  }
  return dispaly_name_;
}
inline ::std::string* CltServiceInfo::release_dispaly_name() {
  clear_has_dispaly_name();
  if (dispaly_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dispaly_name_;
    dispaly_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string binary_Path = 3;
inline bool CltServiceInfo::has_binary_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltServiceInfo::set_has_binary_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltServiceInfo::clear_has_binary_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltServiceInfo::clear_binary_path() {
  if (binary_path_ != &::google::protobuf::internal::kEmptyString) {
    binary_path_->clear();
  }
  clear_has_binary_path();
}
inline const ::std::string& CltServiceInfo::binary_path() const {
  return *binary_path_;
}
inline void CltServiceInfo::set_binary_path(const ::std::string& value) {
  set_has_binary_path();
  if (binary_path_ == &::google::protobuf::internal::kEmptyString) {
    binary_path_ = new ::std::string;
  }
  binary_path_->assign(value);
}
inline void CltServiceInfo::set_binary_path(const char* value) {
  set_has_binary_path();
  if (binary_path_ == &::google::protobuf::internal::kEmptyString) {
    binary_path_ = new ::std::string;
  }
  binary_path_->assign(value);
}
inline void CltServiceInfo::set_binary_path(const char* value, size_t size) {
  set_has_binary_path();
  if (binary_path_ == &::google::protobuf::internal::kEmptyString) {
    binary_path_ = new ::std::string;
  }
  binary_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltServiceInfo::mutable_binary_path() {
  set_has_binary_path();
  if (binary_path_ == &::google::protobuf::internal::kEmptyString) {
    binary_path_ = new ::std::string;
  }
  return binary_path_;
}
inline ::std::string* CltServiceInfo::release_binary_path() {
  clear_has_binary_path();
  if (binary_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = binary_path_;
    binary_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string discription = 4;
inline bool CltServiceInfo::has_discription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltServiceInfo::set_has_discription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltServiceInfo::clear_has_discription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltServiceInfo::clear_discription() {
  if (discription_ != &::google::protobuf::internal::kEmptyString) {
    discription_->clear();
  }
  clear_has_discription();
}
inline const ::std::string& CltServiceInfo::discription() const {
  return *discription_;
}
inline void CltServiceInfo::set_discription(const ::std::string& value) {
  set_has_discription();
  if (discription_ == &::google::protobuf::internal::kEmptyString) {
    discription_ = new ::std::string;
  }
  discription_->assign(value);
}
inline void CltServiceInfo::set_discription(const char* value) {
  set_has_discription();
  if (discription_ == &::google::protobuf::internal::kEmptyString) {
    discription_ = new ::std::string;
  }
  discription_->assign(value);
}
inline void CltServiceInfo::set_discription(const char* value, size_t size) {
  set_has_discription();
  if (discription_ == &::google::protobuf::internal::kEmptyString) {
    discription_ = new ::std::string;
  }
  discription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltServiceInfo::mutable_discription() {
  set_has_discription();
  if (discription_ == &::google::protobuf::internal::kEmptyString) {
    discription_ = new ::std::string;
  }
  return discription_;
}
inline ::std::string* CltServiceInfo::release_discription() {
  clear_has_discription();
  if (discription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = discription_;
    discription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 service_type = 5;
inline bool CltServiceInfo::has_service_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltServiceInfo::set_has_service_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltServiceInfo::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltServiceInfo::clear_service_type() {
  service_type_ = 0u;
  clear_has_service_type();
}
inline ::google::protobuf::uint32 CltServiceInfo::service_type() const {
  return service_type_;
}
inline void CltServiceInfo::set_service_type(::google::protobuf::uint32 value) {
  set_has_service_type();
  service_type_ = value;
}

// optional uint32 state = 6;
inline bool CltServiceInfo::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltServiceInfo::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltServiceInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltServiceInfo::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 CltServiceInfo::state() const {
  return state_;
}
inline void CltServiceInfo::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 start_type = 7;
inline bool CltServiceInfo::has_start_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltServiceInfo::set_has_start_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltServiceInfo::clear_has_start_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltServiceInfo::clear_start_type() {
  start_type_ = 0u;
  clear_has_start_type();
}
inline ::google::protobuf::uint32 CltServiceInfo::start_type() const {
  return start_type_;
}
inline void CltServiceInfo::set_start_type(::google::protobuf::uint32 value) {
  set_has_start_type();
  start_type_ = value;
}

// optional uint32 controls_accepted = 8;
inline bool CltServiceInfo::has_controls_accepted() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltServiceInfo::set_has_controls_accepted() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltServiceInfo::clear_has_controls_accepted() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltServiceInfo::clear_controls_accepted() {
  controls_accepted_ = 0u;
  clear_has_controls_accepted();
}
inline ::google::protobuf::uint32 CltServiceInfo::controls_accepted() const {
  return controls_accepted_;
}
inline void CltServiceInfo::set_controls_accepted(::google::protobuf::uint32 value) {
  set_has_controls_accepted();
  controls_accepted_ = value;
}

// optional uint32 error_control = 9;
inline bool CltServiceInfo::has_error_control() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltServiceInfo::set_has_error_control() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltServiceInfo::clear_has_error_control() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltServiceInfo::clear_error_control() {
  error_control_ = 0u;
  clear_has_error_control();
}
inline ::google::protobuf::uint32 CltServiceInfo::error_control() const {
  return error_control_;
}
inline void CltServiceInfo::set_error_control(::google::protobuf::uint32 value) {
  set_has_error_control();
  error_control_ = value;
}

// -------------------------------------------------------------------

// CltServiceList

// repeated .isafetec.CltServiceInfo list = 1;
inline int CltServiceList::list_size() const {
  return list_.size();
}
inline void CltServiceList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltServiceInfo& CltServiceList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltServiceInfo* CltServiceList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltServiceInfo* CltServiceList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltServiceList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltServiceInfo* CltServiceList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltServiceInfo >&
CltServiceList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltServiceInfo >*
CltServiceList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltProcessInfo

// optional int32 process_id = 1;
inline bool CltProcessInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltProcessInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltProcessInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltProcessInfo::clear_process_id() {
  process_id_ = 0;
  clear_has_process_id();
}
inline ::google::protobuf::int32 CltProcessInfo::process_id() const {
  return process_id_;
}
inline void CltProcessInfo::set_process_id(::google::protobuf::int32 value) {
  set_has_process_id();
  process_id_ = value;
}

// optional int32 session_id = 2;
inline bool CltProcessInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltProcessInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltProcessInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltProcessInfo::clear_session_id() {
  session_id_ = 0;
  clear_has_session_id();
}
inline ::google::protobuf::int32 CltProcessInfo::session_id() const {
  return session_id_;
}
inline void CltProcessInfo::set_session_id(::google::protobuf::int32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional string process_path = 3;
inline bool CltProcessInfo::has_process_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltProcessInfo::set_has_process_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltProcessInfo::clear_has_process_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltProcessInfo::clear_process_path() {
  if (process_path_ != &::google::protobuf::internal::kEmptyString) {
    process_path_->clear();
  }
  clear_has_process_path();
}
inline const ::std::string& CltProcessInfo::process_path() const {
  return *process_path_;
}
inline void CltProcessInfo::set_process_path(const ::std::string& value) {
  set_has_process_path();
  if (process_path_ == &::google::protobuf::internal::kEmptyString) {
    process_path_ = new ::std::string;
  }
  process_path_->assign(value);
}
inline void CltProcessInfo::set_process_path(const char* value) {
  set_has_process_path();
  if (process_path_ == &::google::protobuf::internal::kEmptyString) {
    process_path_ = new ::std::string;
  }
  process_path_->assign(value);
}
inline void CltProcessInfo::set_process_path(const char* value, size_t size) {
  set_has_process_path();
  if (process_path_ == &::google::protobuf::internal::kEmptyString) {
    process_path_ = new ::std::string;
  }
  process_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltProcessInfo::mutable_process_path() {
  set_has_process_path();
  if (process_path_ == &::google::protobuf::internal::kEmptyString) {
    process_path_ = new ::std::string;
  }
  return process_path_;
}
inline ::std::string* CltProcessInfo::release_process_path() {
  clear_has_process_path();
  if (process_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = process_path_;
    process_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string win_user = 4;
inline bool CltProcessInfo::has_win_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltProcessInfo::set_has_win_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltProcessInfo::clear_has_win_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltProcessInfo::clear_win_user() {
  if (win_user_ != &::google::protobuf::internal::kEmptyString) {
    win_user_->clear();
  }
  clear_has_win_user();
}
inline const ::std::string& CltProcessInfo::win_user() const {
  return *win_user_;
}
inline void CltProcessInfo::set_win_user(const ::std::string& value) {
  set_has_win_user();
  if (win_user_ == &::google::protobuf::internal::kEmptyString) {
    win_user_ = new ::std::string;
  }
  win_user_->assign(value);
}
inline void CltProcessInfo::set_win_user(const char* value) {
  set_has_win_user();
  if (win_user_ == &::google::protobuf::internal::kEmptyString) {
    win_user_ = new ::std::string;
  }
  win_user_->assign(value);
}
inline void CltProcessInfo::set_win_user(const char* value, size_t size) {
  set_has_win_user();
  if (win_user_ == &::google::protobuf::internal::kEmptyString) {
    win_user_ = new ::std::string;
  }
  win_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltProcessInfo::mutable_win_user() {
  set_has_win_user();
  if (win_user_ == &::google::protobuf::internal::kEmptyString) {
    win_user_ = new ::std::string;
  }
  return win_user_;
}
inline ::std::string* CltProcessInfo::release_win_user() {
  clear_has_win_user();
  if (win_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = win_user_;
    win_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 thread_num = 5;
inline bool CltProcessInfo::has_thread_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltProcessInfo::set_has_thread_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltProcessInfo::clear_has_thread_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltProcessInfo::clear_thread_num() {
  thread_num_ = 0;
  clear_has_thread_num();
}
inline ::google::protobuf::int32 CltProcessInfo::thread_num() const {
  return thread_num_;
}
inline void CltProcessInfo::set_thread_num(::google::protobuf::int32 value) {
  set_has_thread_num();
  thread_num_ = value;
}

// optional int32 priority = 6;
inline bool CltProcessInfo::has_priority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltProcessInfo::set_has_priority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltProcessInfo::clear_has_priority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltProcessInfo::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 CltProcessInfo::priority() const {
  return priority_;
}
inline void CltProcessInfo::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
}

// optional int32 upRate = 7;
inline bool CltProcessInfo::has_uprate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltProcessInfo::set_has_uprate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltProcessInfo::clear_has_uprate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltProcessInfo::clear_uprate() {
  uprate_ = 0;
  clear_has_uprate();
}
inline ::google::protobuf::int32 CltProcessInfo::uprate() const {
  return uprate_;
}
inline void CltProcessInfo::set_uprate(::google::protobuf::int32 value) {
  set_has_uprate();
  uprate_ = value;
}

// optional int32 downRate = 8;
inline bool CltProcessInfo::has_downrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltProcessInfo::set_has_downrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltProcessInfo::clear_has_downrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltProcessInfo::clear_downrate() {
  downrate_ = 0;
  clear_has_downrate();
}
inline ::google::protobuf::int32 CltProcessInfo::downrate() const {
  return downrate_;
}
inline void CltProcessInfo::set_downrate(::google::protobuf::int32 value) {
  set_has_downrate();
  downrate_ = value;
}

// optional int32 upCount = 9;
inline bool CltProcessInfo::has_upcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltProcessInfo::set_has_upcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltProcessInfo::clear_has_upcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltProcessInfo::clear_upcount() {
  upcount_ = 0;
  clear_has_upcount();
}
inline ::google::protobuf::int32 CltProcessInfo::upcount() const {
  return upcount_;
}
inline void CltProcessInfo::set_upcount(::google::protobuf::int32 value) {
  set_has_upcount();
  upcount_ = value;
}

// optional int32 downCount = 10;
inline bool CltProcessInfo::has_downcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CltProcessInfo::set_has_downcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CltProcessInfo::clear_has_downcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CltProcessInfo::clear_downcount() {
  downcount_ = 0;
  clear_has_downcount();
}
inline ::google::protobuf::int32 CltProcessInfo::downcount() const {
  return downcount_;
}
inline void CltProcessInfo::set_downcount(::google::protobuf::int32 value) {
  set_has_downcount();
  downcount_ = value;
}

// optional int32 contCount = 11;
inline bool CltProcessInfo::has_contcount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CltProcessInfo::set_has_contcount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CltProcessInfo::clear_has_contcount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CltProcessInfo::clear_contcount() {
  contcount_ = 0;
  clear_has_contcount();
}
inline ::google::protobuf::int32 CltProcessInfo::contcount() const {
  return contcount_;
}
inline void CltProcessInfo::set_contcount(::google::protobuf::int32 value) {
  set_has_contcount();
  contcount_ = value;
}

// -------------------------------------------------------------------

// CltProcessList

// repeated .isafetec.CltProcessInfo list = 1;
inline int CltProcessList::list_size() const {
  return list_.size();
}
inline void CltProcessList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltProcessInfo& CltProcessList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltProcessInfo* CltProcessList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltProcessInfo* CltProcessList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltProcessList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltProcessInfo* CltProcessList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltProcessInfo >&
CltProcessList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltProcessInfo >*
CltProcessList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltUser

// optional string name = 1;
inline bool CltUser::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltUser::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltUser::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CltUser::name() const {
  return *name_;
}
inline void CltUser::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltUser::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltUser::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CltUser::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 2;
inline bool CltUser::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltUser::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltUser::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltUser::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& CltUser::desc() const {
  return *desc_;
}
inline void CltUser::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CltUser::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CltUser::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* CltUser::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string full_name = 3;
inline bool CltUser::has_full_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltUser::set_has_full_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltUser::clear_has_full_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltUser::clear_full_name() {
  if (full_name_ != &::google::protobuf::internal::kEmptyString) {
    full_name_->clear();
  }
  clear_has_full_name();
}
inline const ::std::string& CltUser::full_name() const {
  return *full_name_;
}
inline void CltUser::set_full_name(const ::std::string& value) {
  set_has_full_name();
  if (full_name_ == &::google::protobuf::internal::kEmptyString) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(value);
}
inline void CltUser::set_full_name(const char* value) {
  set_has_full_name();
  if (full_name_ == &::google::protobuf::internal::kEmptyString) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(value);
}
inline void CltUser::set_full_name(const char* value, size_t size) {
  set_has_full_name();
  if (full_name_ == &::google::protobuf::internal::kEmptyString) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_full_name() {
  set_has_full_name();
  if (full_name_ == &::google::protobuf::internal::kEmptyString) {
    full_name_ = new ::std::string;
  }
  return full_name_;
}
inline ::std::string* CltUser::release_full_name() {
  clear_has_full_name();
  if (full_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = full_name_;
    full_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string profile = 4;
inline bool CltUser::has_profile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltUser::set_has_profile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltUser::clear_has_profile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltUser::clear_profile() {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    profile_->clear();
  }
  clear_has_profile();
}
inline const ::std::string& CltUser::profile() const {
  return *profile_;
}
inline void CltUser::set_profile(const ::std::string& value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void CltUser::set_profile(const char* value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void CltUser::set_profile(const char* value, size_t size) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_profile() {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  return profile_;
}
inline ::std::string* CltUser::release_profile() {
  clear_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profile_;
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string group = 5;
inline bool CltUser::has_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltUser::set_has_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltUser::clear_has_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltUser::clear_group() {
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    group_->clear();
  }
  clear_has_group();
}
inline const ::std::string& CltUser::group() const {
  return *group_;
}
inline void CltUser::set_group(const ::std::string& value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void CltUser::set_group(const char* value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void CltUser::set_group(const char* value, size_t size) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_group() {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  return group_;
}
inline ::std::string* CltUser::release_group() {
  clear_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_;
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 lock = 6;
inline bool CltUser::has_lock() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltUser::set_has_lock() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltUser::clear_has_lock() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltUser::clear_lock() {
  lock_ = 0;
  clear_has_lock();
}
inline ::google::protobuf::int32 CltUser::lock() const {
  return lock_;
}
inline void CltUser::set_lock(::google::protobuf::int32 value) {
  set_has_lock();
  lock_ = value;
}

// optional int32 disable = 7;
inline bool CltUser::has_disable() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltUser::set_has_disable() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltUser::clear_has_disable() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltUser::clear_disable() {
  disable_ = 0;
  clear_has_disable();
}
inline ::google::protobuf::int32 CltUser::disable() const {
  return disable_;
}
inline void CltUser::set_disable(::google::protobuf::int32 value) {
  set_has_disable();
  disable_ = value;
}

// optional string userpsw = 8;
inline bool CltUser::has_userpsw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltUser::set_has_userpsw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltUser::clear_has_userpsw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltUser::clear_userpsw() {
  if (userpsw_ != &::google::protobuf::internal::kEmptyString) {
    userpsw_->clear();
  }
  clear_has_userpsw();
}
inline const ::std::string& CltUser::userpsw() const {
  return *userpsw_;
}
inline void CltUser::set_userpsw(const ::std::string& value) {
  set_has_userpsw();
  if (userpsw_ == &::google::protobuf::internal::kEmptyString) {
    userpsw_ = new ::std::string;
  }
  userpsw_->assign(value);
}
inline void CltUser::set_userpsw(const char* value) {
  set_has_userpsw();
  if (userpsw_ == &::google::protobuf::internal::kEmptyString) {
    userpsw_ = new ::std::string;
  }
  userpsw_->assign(value);
}
inline void CltUser::set_userpsw(const char* value, size_t size) {
  set_has_userpsw();
  if (userpsw_ == &::google::protobuf::internal::kEmptyString) {
    userpsw_ = new ::std::string;
  }
  userpsw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltUser::mutable_userpsw() {
  set_has_userpsw();
  if (userpsw_ == &::google::protobuf::internal::kEmptyString) {
    userpsw_ = new ::std::string;
  }
  return userpsw_;
}
inline ::std::string* CltUser::release_userpsw() {
  clear_has_userpsw();
  if (userpsw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userpsw_;
    userpsw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CltUserList

// repeated .isafetec.CltUser list = 1;
inline int CltUserList::list_size() const {
  return list_.size();
}
inline void CltUserList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltUser& CltUserList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltUser* CltUserList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltUser* CltUserList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltUserList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltUser* CltUserList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltUser >&
CltUserList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltUser >*
CltUserList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltGroup

// optional string name = 1;
inline bool CltGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltGroup::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CltGroup::name() const {
  return *name_;
}
inline void CltGroup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltGroup::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltGroup::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltGroup::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CltGroup::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 2;
inline bool CltGroup::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltGroup::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltGroup::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltGroup::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& CltGroup::desc() const {
  return *desc_;
}
inline void CltGroup::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CltGroup::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CltGroup::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltGroup::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* CltGroup::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CltGroupList

// repeated .isafetec.CltGroup list = 1;
inline int CltGroupList::list_size() const {
  return list_.size();
}
inline void CltGroupList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltGroup& CltGroupList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltGroup* CltGroupList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltGroup* CltGroupList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltGroupList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltGroup* CltGroupList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltGroup >&
CltGroupList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltGroup >*
CltGroupList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltShareInfo

// optional string netname = 1;
inline bool CltShareInfo::has_netname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltShareInfo::set_has_netname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltShareInfo::clear_has_netname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltShareInfo::clear_netname() {
  if (netname_ != &::google::protobuf::internal::kEmptyString) {
    netname_->clear();
  }
  clear_has_netname();
}
inline const ::std::string& CltShareInfo::netname() const {
  return *netname_;
}
inline void CltShareInfo::set_netname(const ::std::string& value) {
  set_has_netname();
  if (netname_ == &::google::protobuf::internal::kEmptyString) {
    netname_ = new ::std::string;
  }
  netname_->assign(value);
}
inline void CltShareInfo::set_netname(const char* value) {
  set_has_netname();
  if (netname_ == &::google::protobuf::internal::kEmptyString) {
    netname_ = new ::std::string;
  }
  netname_->assign(value);
}
inline void CltShareInfo::set_netname(const char* value, size_t size) {
  set_has_netname();
  if (netname_ == &::google::protobuf::internal::kEmptyString) {
    netname_ = new ::std::string;
  }
  netname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltShareInfo::mutable_netname() {
  set_has_netname();
  if (netname_ == &::google::protobuf::internal::kEmptyString) {
    netname_ = new ::std::string;
  }
  return netname_;
}
inline ::std::string* CltShareInfo::release_netname() {
  clear_has_netname();
  if (netname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netname_;
    netname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 type = 2;
inline bool CltShareInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltShareInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltShareInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltShareInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CltShareInfo::type() const {
  return type_;
}
inline void CltShareInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string remark = 3;
inline bool CltShareInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltShareInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltShareInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltShareInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& CltShareInfo::remark() const {
  return *remark_;
}
inline void CltShareInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void CltShareInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void CltShareInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltShareInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* CltShareInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 current_uses = 4;
inline bool CltShareInfo::has_current_uses() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltShareInfo::set_has_current_uses() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltShareInfo::clear_has_current_uses() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltShareInfo::clear_current_uses() {
  current_uses_ = 0;
  clear_has_current_uses();
}
inline ::google::protobuf::int32 CltShareInfo::current_uses() const {
  return current_uses_;
}
inline void CltShareInfo::set_current_uses(::google::protobuf::int32 value) {
  set_has_current_uses();
  current_uses_ = value;
}

// optional string path = 5;
inline bool CltShareInfo::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltShareInfo::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltShareInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltShareInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CltShareInfo::path() const {
  return *path_;
}
inline void CltShareInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CltShareInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CltShareInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltShareInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* CltShareInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CltShareList

// repeated .isafetec.CltShareInfo list = 1;
inline int CltShareList::list_size() const {
  return list_.size();
}
inline void CltShareList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltShareInfo& CltShareList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltShareInfo* CltShareList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltShareInfo* CltShareList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltShareList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltShareInfo* CltShareList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltShareInfo >&
CltShareList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltShareInfo >*
CltShareList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltStartItem

// optional string name = 1;
inline bool CltStartItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltStartItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltStartItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltStartItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CltStartItem::name() const {
  return *name_;
}
inline void CltStartItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltStartItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltStartItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltStartItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CltStartItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string val = 2;
inline bool CltStartItem::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltStartItem::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltStartItem::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltStartItem::clear_val() {
  if (val_ != &::google::protobuf::internal::kEmptyString) {
    val_->clear();
  }
  clear_has_val();
}
inline const ::std::string& CltStartItem::val() const {
  return *val_;
}
inline void CltStartItem::set_val(const ::std::string& value) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void CltStartItem::set_val(const char* value) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void CltStartItem::set_val(const char* value, size_t size) {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltStartItem::mutable_val() {
  set_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    val_ = new ::std::string;
  }
  return val_;
}
inline ::std::string* CltStartItem::release_val() {
  clear_has_val();
  if (val_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = val_;
    val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string path = 3;
inline bool CltStartItem::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltStartItem::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltStartItem::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltStartItem::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CltStartItem::path() const {
  return *path_;
}
inline void CltStartItem::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CltStartItem::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CltStartItem::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltStartItem::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* CltStartItem::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CltStartList

// repeated .isafetec.CltStartItem list = 1;
inline int CltStartList::list_size() const {
  return list_.size();
}
inline void CltStartList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltStartItem& CltStartList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltStartItem* CltStartList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltStartItem* CltStartList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltStartList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltStartItem* CltStartList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltStartItem >&
CltStartList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltStartItem >*
CltStartList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// CltDiskInfo

// optional string name = 1;
inline bool CltDiskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CltDiskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CltDiskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CltDiskInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CltDiskInfo::name() const {
  return *name_;
}
inline void CltDiskInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltDiskInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CltDiskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDiskInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CltDiskInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string total_size = 2;
inline bool CltDiskInfo::has_total_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CltDiskInfo::set_has_total_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CltDiskInfo::clear_has_total_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CltDiskInfo::clear_total_size() {
  if (total_size_ != &::google::protobuf::internal::kEmptyString) {
    total_size_->clear();
  }
  clear_has_total_size();
}
inline const ::std::string& CltDiskInfo::total_size() const {
  return *total_size_;
}
inline void CltDiskInfo::set_total_size(const ::std::string& value) {
  set_has_total_size();
  if (total_size_ == &::google::protobuf::internal::kEmptyString) {
    total_size_ = new ::std::string;
  }
  total_size_->assign(value);
}
inline void CltDiskInfo::set_total_size(const char* value) {
  set_has_total_size();
  if (total_size_ == &::google::protobuf::internal::kEmptyString) {
    total_size_ = new ::std::string;
  }
  total_size_->assign(value);
}
inline void CltDiskInfo::set_total_size(const char* value, size_t size) {
  set_has_total_size();
  if (total_size_ == &::google::protobuf::internal::kEmptyString) {
    total_size_ = new ::std::string;
  }
  total_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDiskInfo::mutable_total_size() {
  set_has_total_size();
  if (total_size_ == &::google::protobuf::internal::kEmptyString) {
    total_size_ = new ::std::string;
  }
  return total_size_;
}
inline ::std::string* CltDiskInfo::release_total_size() {
  clear_has_total_size();
  if (total_size_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_size_;
    total_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string free_size = 3;
inline bool CltDiskInfo::has_free_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CltDiskInfo::set_has_free_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CltDiskInfo::clear_has_free_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CltDiskInfo::clear_free_size() {
  if (free_size_ != &::google::protobuf::internal::kEmptyString) {
    free_size_->clear();
  }
  clear_has_free_size();
}
inline const ::std::string& CltDiskInfo::free_size() const {
  return *free_size_;
}
inline void CltDiskInfo::set_free_size(const ::std::string& value) {
  set_has_free_size();
  if (free_size_ == &::google::protobuf::internal::kEmptyString) {
    free_size_ = new ::std::string;
  }
  free_size_->assign(value);
}
inline void CltDiskInfo::set_free_size(const char* value) {
  set_has_free_size();
  if (free_size_ == &::google::protobuf::internal::kEmptyString) {
    free_size_ = new ::std::string;
  }
  free_size_->assign(value);
}
inline void CltDiskInfo::set_free_size(const char* value, size_t size) {
  set_has_free_size();
  if (free_size_ == &::google::protobuf::internal::kEmptyString) {
    free_size_ = new ::std::string;
  }
  free_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDiskInfo::mutable_free_size() {
  set_has_free_size();
  if (free_size_ == &::google::protobuf::internal::kEmptyString) {
    free_size_ = new ::std::string;
  }
  return free_size_;
}
inline ::std::string* CltDiskInfo::release_free_size() {
  clear_has_free_size();
  if (free_size_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = free_size_;
    free_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 type = 4;
inline bool CltDiskInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CltDiskInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CltDiskInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CltDiskInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CltDiskInfo::type() const {
  return type_;
}
inline void CltDiskInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string vol_name = 5;
inline bool CltDiskInfo::has_vol_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CltDiskInfo::set_has_vol_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CltDiskInfo::clear_has_vol_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CltDiskInfo::clear_vol_name() {
  if (vol_name_ != &::google::protobuf::internal::kEmptyString) {
    vol_name_->clear();
  }
  clear_has_vol_name();
}
inline const ::std::string& CltDiskInfo::vol_name() const {
  return *vol_name_;
}
inline void CltDiskInfo::set_vol_name(const ::std::string& value) {
  set_has_vol_name();
  if (vol_name_ == &::google::protobuf::internal::kEmptyString) {
    vol_name_ = new ::std::string;
  }
  vol_name_->assign(value);
}
inline void CltDiskInfo::set_vol_name(const char* value) {
  set_has_vol_name();
  if (vol_name_ == &::google::protobuf::internal::kEmptyString) {
    vol_name_ = new ::std::string;
  }
  vol_name_->assign(value);
}
inline void CltDiskInfo::set_vol_name(const char* value, size_t size) {
  set_has_vol_name();
  if (vol_name_ == &::google::protobuf::internal::kEmptyString) {
    vol_name_ = new ::std::string;
  }
  vol_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDiskInfo::mutable_vol_name() {
  set_has_vol_name();
  if (vol_name_ == &::google::protobuf::internal::kEmptyString) {
    vol_name_ = new ::std::string;
  }
  return vol_name_;
}
inline ::std::string* CltDiskInfo::release_vol_name() {
  clear_has_vol_name();
  if (vol_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vol_name_;
    vol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string file_type = 6;
inline bool CltDiskInfo::has_file_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CltDiskInfo::set_has_file_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CltDiskInfo::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CltDiskInfo::clear_file_type() {
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    file_type_->clear();
  }
  clear_has_file_type();
}
inline const ::std::string& CltDiskInfo::file_type() const {
  return *file_type_;
}
inline void CltDiskInfo::set_file_type(const ::std::string& value) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(value);
}
inline void CltDiskInfo::set_file_type(const char* value) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(value);
}
inline void CltDiskInfo::set_file_type(const char* value, size_t size) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CltDiskInfo::mutable_file_type() {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  return file_type_;
}
inline ::std::string* CltDiskInfo::release_file_type() {
  clear_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_type_;
    file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 file_sno = 7;
inline bool CltDiskInfo::has_file_sno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CltDiskInfo::set_has_file_sno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CltDiskInfo::clear_has_file_sno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CltDiskInfo::clear_file_sno() {
  file_sno_ = 0u;
  clear_has_file_sno();
}
inline ::google::protobuf::uint32 CltDiskInfo::file_sno() const {
  return file_sno_;
}
inline void CltDiskInfo::set_file_sno(::google::protobuf::uint32 value) {
  set_has_file_sno();
  file_sno_ = value;
}

// optional uint32 file_max = 8;
inline bool CltDiskInfo::has_file_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CltDiskInfo::set_has_file_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CltDiskInfo::clear_has_file_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CltDiskInfo::clear_file_max() {
  file_max_ = 0u;
  clear_has_file_max();
}
inline ::google::protobuf::uint32 CltDiskInfo::file_max() const {
  return file_max_;
}
inline void CltDiskInfo::set_file_max(::google::protobuf::uint32 value) {
  set_has_file_max();
  file_max_ = value;
}

// optional uint32 file_flag = 9;
inline bool CltDiskInfo::has_file_flag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CltDiskInfo::set_has_file_flag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CltDiskInfo::clear_has_file_flag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CltDiskInfo::clear_file_flag() {
  file_flag_ = 0u;
  clear_has_file_flag();
}
inline ::google::protobuf::uint32 CltDiskInfo::file_flag() const {
  return file_flag_;
}
inline void CltDiskInfo::set_file_flag(::google::protobuf::uint32 value) {
  set_has_file_flag();
  file_flag_ = value;
}

// -------------------------------------------------------------------

// CltDiskList

// repeated .isafetec.CltDiskInfo list = 1;
inline int CltDiskList::list_size() const {
  return list_.size();
}
inline void CltDiskList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CltDiskInfo& CltDiskList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CltDiskInfo* CltDiskList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CltDiskInfo* CltDiskList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void CltDiskList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CltDiskInfo* CltDiskList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CltDiskInfo >&
CltDiskList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CltDiskInfo >*
CltDiskList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// DeviceControlInfo

// optional int32 index = 1;
inline bool DeviceControlInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceControlInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceControlInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceControlInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 DeviceControlInfo::index() const {
  return index_;
}
inline void DeviceControlInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 enabled = 2;
inline bool DeviceControlInfo::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceControlInfo::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceControlInfo::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceControlInfo::clear_enabled() {
  enabled_ = 0;
  clear_has_enabled();
}
inline ::google::protobuf::int32 DeviceControlInfo::enabled() const {
  return enabled_;
}
inline void DeviceControlInfo::set_enabled(::google::protobuf::int32 value) {
  set_has_enabled();
  enabled_ = value;
}

// optional string deviceDesc = 3;
inline bool DeviceControlInfo::has_devicedesc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceControlInfo::set_has_devicedesc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceControlInfo::clear_has_devicedesc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceControlInfo::clear_devicedesc() {
  if (devicedesc_ != &::google::protobuf::internal::kEmptyString) {
    devicedesc_->clear();
  }
  clear_has_devicedesc();
}
inline const ::std::string& DeviceControlInfo::devicedesc() const {
  return *devicedesc_;
}
inline void DeviceControlInfo::set_devicedesc(const ::std::string& value) {
  set_has_devicedesc();
  if (devicedesc_ == &::google::protobuf::internal::kEmptyString) {
    devicedesc_ = new ::std::string;
  }
  devicedesc_->assign(value);
}
inline void DeviceControlInfo::set_devicedesc(const char* value) {
  set_has_devicedesc();
  if (devicedesc_ == &::google::protobuf::internal::kEmptyString) {
    devicedesc_ = new ::std::string;
  }
  devicedesc_->assign(value);
}
inline void DeviceControlInfo::set_devicedesc(const char* value, size_t size) {
  set_has_devicedesc();
  if (devicedesc_ == &::google::protobuf::internal::kEmptyString) {
    devicedesc_ = new ::std::string;
  }
  devicedesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceControlInfo::mutable_devicedesc() {
  set_has_devicedesc();
  if (devicedesc_ == &::google::protobuf::internal::kEmptyString) {
    devicedesc_ = new ::std::string;
  }
  return devicedesc_;
}
inline ::std::string* DeviceControlInfo::release_devicedesc() {
  clear_has_devicedesc();
  if (devicedesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicedesc_;
    devicedesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 4;
inline bool DeviceControlInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceControlInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceControlInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceControlInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 DeviceControlInfo::status() const {
  return status_;
}
inline void DeviceControlInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// DeviceControlClassInfo

// optional string className = 1;
inline bool DeviceControlClassInfo::has_classname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceControlClassInfo::set_has_classname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceControlClassInfo::clear_has_classname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceControlClassInfo::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& DeviceControlClassInfo::classname() const {
  return *classname_;
}
inline void DeviceControlClassInfo::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void DeviceControlClassInfo::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void DeviceControlClassInfo::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceControlClassInfo::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* DeviceControlClassInfo::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guid = 2;
inline bool DeviceControlClassInfo::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceControlClassInfo::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceControlClassInfo::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceControlClassInfo::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& DeviceControlClassInfo::guid() const {
  return *guid_;
}
inline void DeviceControlClassInfo::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void DeviceControlClassInfo::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void DeviceControlClassInfo::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceControlClassInfo::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* DeviceControlClassInfo::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 imageIndex = 3;
inline bool DeviceControlClassInfo::has_imageindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceControlClassInfo::set_has_imageindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceControlClassInfo::clear_has_imageindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceControlClassInfo::clear_imageindex() {
  imageindex_ = 0;
  clear_has_imageindex();
}
inline ::google::protobuf::int32 DeviceControlClassInfo::imageindex() const {
  return imageindex_;
}
inline void DeviceControlClassInfo::set_imageindex(::google::protobuf::int32 value) {
  set_has_imageindex();
  imageindex_ = value;
}

// repeated .isafetec.DeviceControlInfo DeviceInfolist = 4;
inline int DeviceControlClassInfo::deviceinfolist_size() const {
  return deviceinfolist_.size();
}
inline void DeviceControlClassInfo::clear_deviceinfolist() {
  deviceinfolist_.Clear();
}
inline const ::isafetec::DeviceControlInfo& DeviceControlClassInfo::deviceinfolist(int index) const {
  return deviceinfolist_.Get(index);
}
inline ::isafetec::DeviceControlInfo* DeviceControlClassInfo::mutable_deviceinfolist(int index) {
  return deviceinfolist_.Mutable(index);
}
inline ::isafetec::DeviceControlInfo* DeviceControlClassInfo::deviceinfolist_ReleaseAt(int index) {
  return deviceinfolist_.ReleaseAt(index);
}
inline void DeviceControlClassInfo::deviceinfolist_RemoveAt(int index) {
  deviceinfolist_.RemoveAt(index);
}
inline ::isafetec::DeviceControlInfo* DeviceControlClassInfo::add_deviceinfolist() {
  return deviceinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DeviceControlInfo >&
DeviceControlClassInfo::deviceinfolist() const {
  return deviceinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DeviceControlInfo >*
DeviceControlClassInfo::mutable_deviceinfolist() {
  return &deviceinfolist_;
}

// -------------------------------------------------------------------

// DeviceControlClassList

// optional string computerName = 1;
inline bool DeviceControlClassList::has_computername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceControlClassList::set_has_computername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceControlClassList::clear_has_computername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceControlClassList::clear_computername() {
  if (computername_ != &::google::protobuf::internal::kEmptyString) {
    computername_->clear();
  }
  clear_has_computername();
}
inline const ::std::string& DeviceControlClassList::computername() const {
  return *computername_;
}
inline void DeviceControlClassList::set_computername(const ::std::string& value) {
  set_has_computername();
  if (computername_ == &::google::protobuf::internal::kEmptyString) {
    computername_ = new ::std::string;
  }
  computername_->assign(value);
}
inline void DeviceControlClassList::set_computername(const char* value) {
  set_has_computername();
  if (computername_ == &::google::protobuf::internal::kEmptyString) {
    computername_ = new ::std::string;
  }
  computername_->assign(value);
}
inline void DeviceControlClassList::set_computername(const char* value, size_t size) {
  set_has_computername();
  if (computername_ == &::google::protobuf::internal::kEmptyString) {
    computername_ = new ::std::string;
  }
  computername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceControlClassList::mutable_computername() {
  set_has_computername();
  if (computername_ == &::google::protobuf::internal::kEmptyString) {
    computername_ = new ::std::string;
  }
  return computername_;
}
inline ::std::string* DeviceControlClassList::release_computername() {
  clear_has_computername();
  if (computername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = computername_;
    computername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .isafetec.DeviceControlClassInfo DeviceClasslist = 2;
inline int DeviceControlClassList::deviceclasslist_size() const {
  return deviceclasslist_.size();
}
inline void DeviceControlClassList::clear_deviceclasslist() {
  deviceclasslist_.Clear();
}
inline const ::isafetec::DeviceControlClassInfo& DeviceControlClassList::deviceclasslist(int index) const {
  return deviceclasslist_.Get(index);
}
inline ::isafetec::DeviceControlClassInfo* DeviceControlClassList::mutable_deviceclasslist(int index) {
  return deviceclasslist_.Mutable(index);
}
inline ::isafetec::DeviceControlClassInfo* DeviceControlClassList::deviceclasslist_ReleaseAt(int index) {
  return deviceclasslist_.ReleaseAt(index);
}
inline void DeviceControlClassList::deviceclasslist_RemoveAt(int index) {
  deviceclasslist_.RemoveAt(index);
}
inline ::isafetec::DeviceControlClassInfo* DeviceControlClassList::add_deviceclasslist() {
  return deviceclasslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DeviceControlClassInfo >&
DeviceControlClassList::deviceclasslist() const {
  return deviceclasslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DeviceControlClassInfo >*
DeviceControlClassList::mutable_deviceclasslist() {
  return &deviceclasslist_;
}

// -------------------------------------------------------------------

// FireWallInfo

// optional int32 enabled = 1;
inline bool FireWallInfo::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FireWallInfo::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FireWallInfo::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FireWallInfo::clear_enabled() {
  enabled_ = 0;
  clear_has_enabled();
}
inline ::google::protobuf::int32 FireWallInfo::enabled() const {
  return enabled_;
}
inline void FireWallInfo::set_enabled(::google::protobuf::int32 value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// DataBaseInfo

// optional string package_code = 1;
inline bool DataBaseInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataBaseInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataBaseInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataBaseInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& DataBaseInfo::package_code() const {
  return *package_code_;
}
inline void DataBaseInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DataBaseInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void DataBaseInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataBaseInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* DataBaseInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool DataBaseInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataBaseInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataBaseInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataBaseInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 DataBaseInfo::checktype() const {
  return checktype_;
}
inline void DataBaseInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool DataBaseInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataBaseInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataBaseInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataBaseInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double DataBaseInfo::scan_time() const {
  return scan_time_;
}
inline void DataBaseInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool DataBaseInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataBaseInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataBaseInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataBaseInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double DataBaseInfo::addtime() const {
  return addtime_;
}
inline void DataBaseInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional string status = 4;
inline bool DataBaseInfo::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataBaseInfo::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataBaseInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataBaseInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& DataBaseInfo::status() const {
  return *status_;
}
inline void DataBaseInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void DataBaseInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void DataBaseInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataBaseInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* DataBaseInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 5;
inline bool DataBaseInfo::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataBaseInfo::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataBaseInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataBaseInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DataBaseInfo::version() const {
  return *version_;
}
inline void DataBaseInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DataBaseInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void DataBaseInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataBaseInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* DataBaseInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DataBaseInfoList

// repeated .isafetec.DataBaseInfo list = 1;
inline int DataBaseInfoList::list_size() const {
  return list_.size();
}
inline void DataBaseInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::DataBaseInfo& DataBaseInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::DataBaseInfo* DataBaseInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::DataBaseInfo* DataBaseInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void DataBaseInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::DataBaseInfo* DataBaseInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DataBaseInfo >&
DataBaseInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DataBaseInfo >*
DataBaseInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool DataBaseInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataBaseInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataBaseInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataBaseInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 DataBaseInfoList::alarmed() const {
  return alarmed_;
}
inline void DataBaseInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool DataBaseInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataBaseInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataBaseInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataBaseInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& DataBaseInfoList::winuser() const {
  return *winuser_;
}
inline void DataBaseInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DataBaseInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void DataBaseInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataBaseInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* DataBaseInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ODBCSourceInfo

// optional string package_code = 1;
inline bool ODBCSourceInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ODBCSourceInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ODBCSourceInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ODBCSourceInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& ODBCSourceInfo::package_code() const {
  return *package_code_;
}
inline void ODBCSourceInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ODBCSourceInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ODBCSourceInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ODBCSourceInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* ODBCSourceInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool ODBCSourceInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ODBCSourceInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ODBCSourceInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ODBCSourceInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 ODBCSourceInfo::checktype() const {
  return checktype_;
}
inline void ODBCSourceInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool ODBCSourceInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ODBCSourceInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ODBCSourceInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ODBCSourceInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double ODBCSourceInfo::scan_time() const {
  return scan_time_;
}
inline void ODBCSourceInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool ODBCSourceInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ODBCSourceInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ODBCSourceInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ODBCSourceInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double ODBCSourceInfo::addtime() const {
  return addtime_;
}
inline void ODBCSourceInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// -------------------------------------------------------------------

// ODBCSourceInfoList

// repeated .isafetec.ODBCSourceInfo list = 1;
inline int ODBCSourceInfoList::list_size() const {
  return list_.size();
}
inline void ODBCSourceInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::ODBCSourceInfo& ODBCSourceInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::ODBCSourceInfo* ODBCSourceInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::ODBCSourceInfo* ODBCSourceInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void ODBCSourceInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::ODBCSourceInfo* ODBCSourceInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::ODBCSourceInfo >&
ODBCSourceInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::ODBCSourceInfo >*
ODBCSourceInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool ODBCSourceInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ODBCSourceInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ODBCSourceInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ODBCSourceInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 ODBCSourceInfoList::alarmed() const {
  return alarmed_;
}
inline void ODBCSourceInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool ODBCSourceInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ODBCSourceInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ODBCSourceInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ODBCSourceInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& ODBCSourceInfoList::winuser() const {
  return *winuser_;
}
inline void ODBCSourceInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ODBCSourceInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ODBCSourceInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ODBCSourceInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* ODBCSourceInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ODBCDriverInfo

// optional string package_code = 1;
inline bool ODBCDriverInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ODBCDriverInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ODBCDriverInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ODBCDriverInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& ODBCDriverInfo::package_code() const {
  return *package_code_;
}
inline void ODBCDriverInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ODBCDriverInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void ODBCDriverInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ODBCDriverInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* ODBCDriverInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool ODBCDriverInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ODBCDriverInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ODBCDriverInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ODBCDriverInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 ODBCDriverInfo::checktype() const {
  return checktype_;
}
inline void ODBCDriverInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool ODBCDriverInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ODBCDriverInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ODBCDriverInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ODBCDriverInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double ODBCDriverInfo::scan_time() const {
  return scan_time_;
}
inline void ODBCDriverInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool ODBCDriverInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ODBCDriverInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ODBCDriverInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ODBCDriverInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double ODBCDriverInfo::addtime() const {
  return addtime_;
}
inline void ODBCDriverInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// -------------------------------------------------------------------

// ODBCDriverInfoList

// repeated .isafetec.ODBCDriverInfo list = 1;
inline int ODBCDriverInfoList::list_size() const {
  return list_.size();
}
inline void ODBCDriverInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::ODBCDriverInfo& ODBCDriverInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::ODBCDriverInfo* ODBCDriverInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::ODBCDriverInfo* ODBCDriverInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void ODBCDriverInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::ODBCDriverInfo* ODBCDriverInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::ODBCDriverInfo >&
ODBCDriverInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::ODBCDriverInfo >*
ODBCDriverInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool ODBCDriverInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ODBCDriverInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ODBCDriverInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ODBCDriverInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 ODBCDriverInfoList::alarmed() const {
  return alarmed_;
}
inline void ODBCDriverInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool ODBCDriverInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ODBCDriverInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ODBCDriverInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ODBCDriverInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& ODBCDriverInfoList::winuser() const {
  return *winuser_;
}
inline void ODBCDriverInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ODBCDriverInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void ODBCDriverInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ODBCDriverInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* ODBCDriverInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AntiVirusSoftWareInfo

// optional string package_code = 1;
inline bool AntiVirusSoftWareInfo::has_package_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_package_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntiVirusSoftWareInfo::clear_has_package_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntiVirusSoftWareInfo::clear_package_code() {
  if (package_code_ != &::google::protobuf::internal::kEmptyString) {
    package_code_->clear();
  }
  clear_has_package_code();
}
inline const ::std::string& AntiVirusSoftWareInfo::package_code() const {
  return *package_code_;
}
inline void AntiVirusSoftWareInfo::set_package_code(const ::std::string& value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_package_code(const char* value) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_package_code(const char* value, size_t size) {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  package_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntiVirusSoftWareInfo::mutable_package_code() {
  set_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    package_code_ = new ::std::string;
  }
  return package_code_;
}
inline ::std::string* AntiVirusSoftWareInfo::release_package_code() {
  clear_has_package_code();
  if (package_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_code_;
    package_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checktype = 2;
inline bool AntiVirusSoftWareInfo::has_checktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_checktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntiVirusSoftWareInfo::clear_has_checktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntiVirusSoftWareInfo::clear_checktype() {
  checktype_ = 0;
  clear_has_checktype();
}
inline ::google::protobuf::int32 AntiVirusSoftWareInfo::checktype() const {
  return checktype_;
}
inline void AntiVirusSoftWareInfo::set_checktype(::google::protobuf::int32 value) {
  set_has_checktype();
  checktype_ = value;
}

// optional double scan_time = 3;
inline bool AntiVirusSoftWareInfo::has_scan_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_scan_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntiVirusSoftWareInfo::clear_has_scan_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntiVirusSoftWareInfo::clear_scan_time() {
  scan_time_ = 0;
  clear_has_scan_time();
}
inline double AntiVirusSoftWareInfo::scan_time() const {
  return scan_time_;
}
inline void AntiVirusSoftWareInfo::set_scan_time(double value) {
  set_has_scan_time();
  scan_time_ = value;
}

// optional double addtime = 50;
inline bool AntiVirusSoftWareInfo::has_addtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_addtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AntiVirusSoftWareInfo::clear_has_addtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AntiVirusSoftWareInfo::clear_addtime() {
  addtime_ = 0;
  clear_has_addtime();
}
inline double AntiVirusSoftWareInfo::addtime() const {
  return addtime_;
}
inline void AntiVirusSoftWareInfo::set_addtime(double value) {
  set_has_addtime();
  addtime_ = value;
}

// optional string versionNumber = 4;
inline bool AntiVirusSoftWareInfo::has_versionnumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_versionnumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AntiVirusSoftWareInfo::clear_has_versionnumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AntiVirusSoftWareInfo::clear_versionnumber() {
  if (versionnumber_ != &::google::protobuf::internal::kEmptyString) {
    versionnumber_->clear();
  }
  clear_has_versionnumber();
}
inline const ::std::string& AntiVirusSoftWareInfo::versionnumber() const {
  return *versionnumber_;
}
inline void AntiVirusSoftWareInfo::set_versionnumber(const ::std::string& value) {
  set_has_versionnumber();
  if (versionnumber_ == &::google::protobuf::internal::kEmptyString) {
    versionnumber_ = new ::std::string;
  }
  versionnumber_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_versionnumber(const char* value) {
  set_has_versionnumber();
  if (versionnumber_ == &::google::protobuf::internal::kEmptyString) {
    versionnumber_ = new ::std::string;
  }
  versionnumber_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_versionnumber(const char* value, size_t size) {
  set_has_versionnumber();
  if (versionnumber_ == &::google::protobuf::internal::kEmptyString) {
    versionnumber_ = new ::std::string;
  }
  versionnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntiVirusSoftWareInfo::mutable_versionnumber() {
  set_has_versionnumber();
  if (versionnumber_ == &::google::protobuf::internal::kEmptyString) {
    versionnumber_ = new ::std::string;
  }
  return versionnumber_;
}
inline ::std::string* AntiVirusSoftWareInfo::release_versionnumber() {
  clear_has_versionnumber();
  if (versionnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versionnumber_;
    versionnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string path = 5;
inline bool AntiVirusSoftWareInfo::has_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AntiVirusSoftWareInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AntiVirusSoftWareInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& AntiVirusSoftWareInfo::path() const {
  return *path_;
}
inline void AntiVirusSoftWareInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void AntiVirusSoftWareInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntiVirusSoftWareInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* AntiVirusSoftWareInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 6;
inline bool AntiVirusSoftWareInfo::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AntiVirusSoftWareInfo::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AntiVirusSoftWareInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AntiVirusSoftWareInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 AntiVirusSoftWareInfo::status() const {
  return status_;
}
inline void AntiVirusSoftWareInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// AntiVirusSoftWareInfoList

// repeated .isafetec.AntiVirusSoftWareInfo list = 1;
inline int AntiVirusSoftWareInfoList::list_size() const {
  return list_.size();
}
inline void AntiVirusSoftWareInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::AntiVirusSoftWareInfo& AntiVirusSoftWareInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::AntiVirusSoftWareInfo* AntiVirusSoftWareInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::AntiVirusSoftWareInfo* AntiVirusSoftWareInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void AntiVirusSoftWareInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::AntiVirusSoftWareInfo* AntiVirusSoftWareInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::AntiVirusSoftWareInfo >&
AntiVirusSoftWareInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::AntiVirusSoftWareInfo >*
AntiVirusSoftWareInfoList::mutable_list() {
  return &list_;
}

// optional int32 alarmed = 2;
inline bool AntiVirusSoftWareInfoList::has_alarmed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AntiVirusSoftWareInfoList::set_has_alarmed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AntiVirusSoftWareInfoList::clear_has_alarmed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AntiVirusSoftWareInfoList::clear_alarmed() {
  alarmed_ = 0;
  clear_has_alarmed();
}
inline ::google::protobuf::int32 AntiVirusSoftWareInfoList::alarmed() const {
  return alarmed_;
}
inline void AntiVirusSoftWareInfoList::set_alarmed(::google::protobuf::int32 value) {
  set_has_alarmed();
  alarmed_ = value;
}

// optional string winuser = 3;
inline bool AntiVirusSoftWareInfoList::has_winuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AntiVirusSoftWareInfoList::set_has_winuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AntiVirusSoftWareInfoList::clear_has_winuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AntiVirusSoftWareInfoList::clear_winuser() {
  if (winuser_ != &::google::protobuf::internal::kEmptyString) {
    winuser_->clear();
  }
  clear_has_winuser();
}
inline const ::std::string& AntiVirusSoftWareInfoList::winuser() const {
  return *winuser_;
}
inline void AntiVirusSoftWareInfoList::set_winuser(const ::std::string& value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void AntiVirusSoftWareInfoList::set_winuser(const char* value) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(value);
}
inline void AntiVirusSoftWareInfoList::set_winuser(const char* value, size_t size) {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  winuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AntiVirusSoftWareInfoList::mutable_winuser() {
  set_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    winuser_ = new ::std::string;
  }
  return winuser_;
}
inline ::std::string* AntiVirusSoftWareInfoList::release_winuser() {
  clear_has_winuser();
  if (winuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winuser_;
    winuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DisposeSoftInfo

// optional int32 id = 1;
inline bool DisposeSoftInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisposeSoftInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisposeSoftInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisposeSoftInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DisposeSoftInfo::id() const {
  return id_;
}
inline void DisposeSoftInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string zipPackname = 2;
inline bool DisposeSoftInfo::has_zippackname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisposeSoftInfo::set_has_zippackname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisposeSoftInfo::clear_has_zippackname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisposeSoftInfo::clear_zippackname() {
  if (zippackname_ != &::google::protobuf::internal::kEmptyString) {
    zippackname_->clear();
  }
  clear_has_zippackname();
}
inline const ::std::string& DisposeSoftInfo::zippackname() const {
  return *zippackname_;
}
inline void DisposeSoftInfo::set_zippackname(const ::std::string& value) {
  set_has_zippackname();
  if (zippackname_ == &::google::protobuf::internal::kEmptyString) {
    zippackname_ = new ::std::string;
  }
  zippackname_->assign(value);
}
inline void DisposeSoftInfo::set_zippackname(const char* value) {
  set_has_zippackname();
  if (zippackname_ == &::google::protobuf::internal::kEmptyString) {
    zippackname_ = new ::std::string;
  }
  zippackname_->assign(value);
}
inline void DisposeSoftInfo::set_zippackname(const char* value, size_t size) {
  set_has_zippackname();
  if (zippackname_ == &::google::protobuf::internal::kEmptyString) {
    zippackname_ = new ::std::string;
  }
  zippackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisposeSoftInfo::mutable_zippackname() {
  set_has_zippackname();
  if (zippackname_ == &::google::protobuf::internal::kEmptyString) {
    zippackname_ = new ::std::string;
  }
  return zippackname_;
}
inline ::std::string* DisposeSoftInfo::release_zippackname() {
  clear_has_zippackname();
  if (zippackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zippackname_;
    zippackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string unzipPath = 3;
inline bool DisposeSoftInfo::has_unzippath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisposeSoftInfo::set_has_unzippath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisposeSoftInfo::clear_has_unzippath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisposeSoftInfo::clear_unzippath() {
  if (unzippath_ != &::google::protobuf::internal::kEmptyString) {
    unzippath_->clear();
  }
  clear_has_unzippath();
}
inline const ::std::string& DisposeSoftInfo::unzippath() const {
  return *unzippath_;
}
inline void DisposeSoftInfo::set_unzippath(const ::std::string& value) {
  set_has_unzippath();
  if (unzippath_ == &::google::protobuf::internal::kEmptyString) {
    unzippath_ = new ::std::string;
  }
  unzippath_->assign(value);
}
inline void DisposeSoftInfo::set_unzippath(const char* value) {
  set_has_unzippath();
  if (unzippath_ == &::google::protobuf::internal::kEmptyString) {
    unzippath_ = new ::std::string;
  }
  unzippath_->assign(value);
}
inline void DisposeSoftInfo::set_unzippath(const char* value, size_t size) {
  set_has_unzippath();
  if (unzippath_ == &::google::protobuf::internal::kEmptyString) {
    unzippath_ = new ::std::string;
  }
  unzippath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisposeSoftInfo::mutable_unzippath() {
  set_has_unzippath();
  if (unzippath_ == &::google::protobuf::internal::kEmptyString) {
    unzippath_ = new ::std::string;
  }
  return unzippath_;
}
inline ::std::string* DisposeSoftInfo::release_unzippath() {
  clear_has_unzippath();
  if (unzippath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unzippath_;
    unzippath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string runFileName = 4;
inline bool DisposeSoftInfo::has_runfilename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DisposeSoftInfo::set_has_runfilename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DisposeSoftInfo::clear_has_runfilename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DisposeSoftInfo::clear_runfilename() {
  if (runfilename_ != &::google::protobuf::internal::kEmptyString) {
    runfilename_->clear();
  }
  clear_has_runfilename();
}
inline const ::std::string& DisposeSoftInfo::runfilename() const {
  return *runfilename_;
}
inline void DisposeSoftInfo::set_runfilename(const ::std::string& value) {
  set_has_runfilename();
  if (runfilename_ == &::google::protobuf::internal::kEmptyString) {
    runfilename_ = new ::std::string;
  }
  runfilename_->assign(value);
}
inline void DisposeSoftInfo::set_runfilename(const char* value) {
  set_has_runfilename();
  if (runfilename_ == &::google::protobuf::internal::kEmptyString) {
    runfilename_ = new ::std::string;
  }
  runfilename_->assign(value);
}
inline void DisposeSoftInfo::set_runfilename(const char* value, size_t size) {
  set_has_runfilename();
  if (runfilename_ == &::google::protobuf::internal::kEmptyString) {
    runfilename_ = new ::std::string;
  }
  runfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DisposeSoftInfo::mutable_runfilename() {
  set_has_runfilename();
  if (runfilename_ == &::google::protobuf::internal::kEmptyString) {
    runfilename_ = new ::std::string;
  }
  return runfilename_;
}
inline ::std::string* DisposeSoftInfo::release_runfilename() {
  clear_has_runfilename();
  if (runfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = runfilename_;
    runfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DisposeSoftInfoList

// repeated .isafetec.DisposeSoftInfo list = 1;
inline int DisposeSoftInfoList::list_size() const {
  return list_.size();
}
inline void DisposeSoftInfoList::clear_list() {
  list_.Clear();
}
inline const ::isafetec::DisposeSoftInfo& DisposeSoftInfoList::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::DisposeSoftInfo* DisposeSoftInfoList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::DisposeSoftInfo* DisposeSoftInfoList::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void DisposeSoftInfoList::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::DisposeSoftInfo* DisposeSoftInfoList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::DisposeSoftInfo >&
DisposeSoftInfoList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::DisposeSoftInfo >*
DisposeSoftInfoList::mutable_list() {
  return &list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace isafetec

// @@protoc_insertion_point(global_scope)
