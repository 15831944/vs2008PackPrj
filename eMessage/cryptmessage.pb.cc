// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cryptmessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace isafetec {

namespace {

const ::google::protobuf::Descriptor* CryptSoftware_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptSoftware_reflection_ = NULL;
const ::google::protobuf::Descriptor* SorenPolicy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SorenPolicy_reflection_ = NULL;
const ::google::protobuf::Descriptor* CryptAlgInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptAlgInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CryptAlgType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CryptAlgType_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_cryptmessage_2eproto() {
  protobuf_AddDesc_cryptmessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cryptmessage.proto");
  GOOGLE_CHECK(file != NULL);
  CryptSoftware_descriptor_ = file->message_type(0);
  static const int CryptSoftware_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, filter_ext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, nofilter_ext_),
  };
  CryptSoftware_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptSoftware_descriptor_,
      CryptSoftware::default_instance_,
      CryptSoftware_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptSoftware, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptSoftware));
  SorenPolicy_descriptor_ = file->message_type(1);
  static const int SorenPolicy_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, last_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, timelist_),
  };
  SorenPolicy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SorenPolicy_descriptor_,
      SorenPolicy::default_instance_,
      SorenPolicy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SorenPolicy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SorenPolicy));
  CryptAlgInfo_descriptor_ = file->message_type(2);
  static const int CryptAlgInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgInfo, alg_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgInfo, key_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgInfo, key_data_),
  };
  CryptAlgInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptAlgInfo_descriptor_,
      CryptAlgInfo::default_instance_,
      CryptAlgInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptAlgInfo));
  CryptAlgType_descriptor_ = file->message_type(3);
  static const int CryptAlgType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgType, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgType, crypt_),
  };
  CryptAlgType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CryptAlgType_descriptor_,
      CryptAlgType::default_instance_,
      CryptAlgType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CryptAlgType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CryptAlgType));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cryptmessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptSoftware_descriptor_, &CryptSoftware::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SorenPolicy_descriptor_, &SorenPolicy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptAlgInfo_descriptor_, &CryptAlgInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CryptAlgType_descriptor_, &CryptAlgType::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cryptmessage_2eproto() {
  delete CryptSoftware::default_instance_;
  delete CryptSoftware_reflection_;
  delete SorenPolicy::default_instance_;
  delete SorenPolicy_reflection_;
  delete CryptAlgInfo::default_instance_;
  delete CryptAlgInfo_reflection_;
  delete CryptAlgType::default_instance_;
  delete CryptAlgType_reflection_;
}

void protobuf_AddDesc_cryptmessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::isafetec::protobuf_AddDesc_cmmmessage_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\022cryptmessage.proto\022\010isafetec\032\020cmmmessa"
    "ge.proto\"g\n\rCryptSoftware\022\014\n\004name\030\001 \002(\t\022"
    "\r\n\005image\030\002 \001(\t\022\017\n\007version\030\003 \001(\t\022\022\n\nfilte"
    "r_ext\030\004 \001(\t\022\024\n\014nofilter_ext\030\005 \001(\t\"\213\001\n\013So"
    "renPolicy\022\n\n\002id\030\001 \002(\005\022\014\n\004type\030\002 \002(\005\022\021\n\tl"
    "ast_time\030\003 \002(\001\022%\n\004list\030\004 \003(\0132\027.isafetec."
    "CryptSoftware\022(\n\010timelist\030\005 \001(\0132\026.isafet"
    "ec.TimeSpanList\"C\n\014CryptAlgInfo\022\020\n\010alg_c"
    "ode\030\001 \002(\005\022\017\n\007key_len\030\002 \002(\005\022\020\n\010key_data\030\003"
    " \002(\t\"C\n\014CryptAlgType\022\014\n\004type\030\001 \002(\005\022%\n\005cr"
    "ypt\030\002 \002(\0132\026.isafetec.CryptAlgInfo", 433);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cryptmessage.proto", &protobuf_RegisterTypes);
  CryptSoftware::default_instance_ = new CryptSoftware();
  SorenPolicy::default_instance_ = new SorenPolicy();
  CryptAlgInfo::default_instance_ = new CryptAlgInfo();
  CryptAlgType::default_instance_ = new CryptAlgType();
  CryptSoftware::default_instance_->InitAsDefaultInstance();
  SorenPolicy::default_instance_->InitAsDefaultInstance();
  CryptAlgInfo::default_instance_->InitAsDefaultInstance();
  CryptAlgType::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cryptmessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cryptmessage_2eproto {
  StaticDescriptorInitializer_cryptmessage_2eproto() {
    protobuf_AddDesc_cryptmessage_2eproto();
  }
} static_descriptor_initializer_cryptmessage_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int CryptSoftware::kNameFieldNumber;
const int CryptSoftware::kImageFieldNumber;
const int CryptSoftware::kVersionFieldNumber;
const int CryptSoftware::kFilterExtFieldNumber;
const int CryptSoftware::kNofilterExtFieldNumber;
#endif  // !_MSC_VER

CryptSoftware::CryptSoftware()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptSoftware::InitAsDefaultInstance() {
}

CryptSoftware::CryptSoftware(const CryptSoftware& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptSoftware::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  filter_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nofilter_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptSoftware::~CryptSoftware() {
  SharedDtor();
}

void CryptSoftware::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (filter_ext_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_ext_;
  }
  if (nofilter_ext_ != &::google::protobuf::internal::kEmptyString) {
    delete nofilter_ext_;
  }
  if (this != default_instance_) {
  }
}

void CryptSoftware::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptSoftware::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptSoftware_descriptor_;
}

const CryptSoftware& CryptSoftware::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cryptmessage_2eproto();  return *default_instance_;
}

CryptSoftware* CryptSoftware::default_instance_ = NULL;

CryptSoftware* CryptSoftware::New() const {
  return new CryptSoftware;
}

void CryptSoftware::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_image()) {
      if (image_ != &::google::protobuf::internal::kEmptyString) {
        image_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_filter_ext()) {
      if (filter_ext_ != &::google::protobuf::internal::kEmptyString) {
        filter_ext_->clear();
      }
    }
    if (has_nofilter_ext()) {
      if (nofilter_ext_ != &::google::protobuf::internal::kEmptyString) {
        nofilter_ext_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptSoftware::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_image;
        break;
      }
      
      // optional string image = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->image().data(), this->image().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }
      
      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_filter_ext;
        break;
      }
      
      // optional string filter_ext = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_ext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_ext()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_ext().data(), this->filter_ext().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_nofilter_ext;
        break;
      }
      
      // optional string nofilter_ext = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nofilter_ext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nofilter_ext()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->nofilter_ext().data(), this->nofilter_ext().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptSoftware::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // optional string image = 2;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->image(), output);
  }
  
  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }
  
  // optional string filter_ext = 4;
  if (has_filter_ext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_ext().data(), this->filter_ext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->filter_ext(), output);
  }
  
  // optional string nofilter_ext = 5;
  if (has_nofilter_ext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nofilter_ext().data(), this->nofilter_ext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->nofilter_ext(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptSoftware::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // optional string image = 2;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->image(), target);
  }
  
  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }
  
  // optional string filter_ext = 4;
  if (has_filter_ext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_ext().data(), this->filter_ext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->filter_ext(), target);
  }
  
  // optional string nofilter_ext = 5;
  if (has_nofilter_ext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->nofilter_ext().data(), this->nofilter_ext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->nofilter_ext(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptSoftware::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional string image = 2;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->image());
    }
    
    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // optional string filter_ext = 4;
    if (has_filter_ext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_ext());
    }
    
    // optional string nofilter_ext = 5;
    if (has_nofilter_ext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nofilter_ext());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptSoftware::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptSoftware* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptSoftware*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptSoftware::MergeFrom(const CryptSoftware& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_filter_ext()) {
      set_filter_ext(from.filter_ext());
    }
    if (from.has_nofilter_ext()) {
      set_nofilter_ext(from.nofilter_ext());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptSoftware::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptSoftware::CopyFrom(const CryptSoftware& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptSoftware::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void CryptSoftware::Swap(CryptSoftware* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(image_, other->image_);
    std::swap(version_, other->version_);
    std::swap(filter_ext_, other->filter_ext_);
    std::swap(nofilter_ext_, other->nofilter_ext_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptSoftware::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptSoftware_descriptor_;
  metadata.reflection = CryptSoftware_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SorenPolicy::kIdFieldNumber;
const int SorenPolicy::kTypeFieldNumber;
const int SorenPolicy::kLastTimeFieldNumber;
const int SorenPolicy::kListFieldNumber;
const int SorenPolicy::kTimelistFieldNumber;
#endif  // !_MSC_VER

SorenPolicy::SorenPolicy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SorenPolicy::InitAsDefaultInstance() {
  timelist_ = const_cast< ::isafetec::TimeSpanList*>(&::isafetec::TimeSpanList::default_instance());
}

SorenPolicy::SorenPolicy(const SorenPolicy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SorenPolicy::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  last_time_ = 0;
  timelist_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SorenPolicy::~SorenPolicy() {
  SharedDtor();
}

void SorenPolicy::SharedDtor() {
  if (this != default_instance_) {
    delete timelist_;
  }
}

void SorenPolicy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SorenPolicy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SorenPolicy_descriptor_;
}

const SorenPolicy& SorenPolicy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cryptmessage_2eproto();  return *default_instance_;
}

SorenPolicy* SorenPolicy::default_instance_ = NULL;

SorenPolicy* SorenPolicy::New() const {
  return new SorenPolicy;
}

void SorenPolicy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    type_ = 0;
    last_time_ = 0;
    if (has_timelist()) {
      if (timelist_ != NULL) timelist_->::isafetec::TimeSpanList::Clear();
    }
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SorenPolicy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // required int32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_last_time;
        break;
      }
      
      // required double last_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_last_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &last_time_)));
          set_has_last_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_list;
        break;
      }
      
      // repeated .isafetec.CryptSoftware list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_list;
        if (input->ExpectTag(42)) goto parse_timelist;
        break;
      }
      
      // optional .isafetec.TimeSpanList timelist = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_timelist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timelist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SorenPolicy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }
  
  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }
  
  // required double last_time = 3;
  if (has_last_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->last_time(), output);
  }
  
  // repeated .isafetec.CryptSoftware list = 4;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->list(i), output);
  }
  
  // optional .isafetec.TimeSpanList timelist = 5;
  if (has_timelist()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->timelist(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SorenPolicy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }
  
  // required double last_time = 3;
  if (has_last_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->last_time(), target);
  }
  
  // repeated .isafetec.CryptSoftware list = 4;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->list(i), target);
  }
  
  // optional .isafetec.TimeSpanList timelist = 5;
  if (has_timelist()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->timelist(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SorenPolicy::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }
    
    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // required double last_time = 3;
    if (has_last_time()) {
      total_size += 1 + 8;
    }
    
    // optional .isafetec.TimeSpanList timelist = 5;
    if (has_timelist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timelist());
    }
    
  }
  // repeated .isafetec.CryptSoftware list = 4;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SorenPolicy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SorenPolicy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SorenPolicy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SorenPolicy::MergeFrom(const SorenPolicy& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_last_time()) {
      set_last_time(from.last_time());
    }
    if (from.has_timelist()) {
      mutable_timelist()->::isafetec::TimeSpanList::MergeFrom(from.timelist());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SorenPolicy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SorenPolicy::CopyFrom(const SorenPolicy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SorenPolicy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void SorenPolicy::Swap(SorenPolicy* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(last_time_, other->last_time_);
    list_.Swap(&other->list_);
    std::swap(timelist_, other->timelist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SorenPolicy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SorenPolicy_descriptor_;
  metadata.reflection = SorenPolicy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CryptAlgInfo::kAlgCodeFieldNumber;
const int CryptAlgInfo::kKeyLenFieldNumber;
const int CryptAlgInfo::kKeyDataFieldNumber;
#endif  // !_MSC_VER

CryptAlgInfo::CryptAlgInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptAlgInfo::InitAsDefaultInstance() {
}

CryptAlgInfo::CryptAlgInfo(const CryptAlgInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptAlgInfo::SharedCtor() {
  _cached_size_ = 0;
  alg_code_ = 0;
  key_len_ = 0;
  key_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptAlgInfo::~CryptAlgInfo() {
  SharedDtor();
}

void CryptAlgInfo::SharedDtor() {
  if (key_data_ != &::google::protobuf::internal::kEmptyString) {
    delete key_data_;
  }
  if (this != default_instance_) {
  }
}

void CryptAlgInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptAlgInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptAlgInfo_descriptor_;
}

const CryptAlgInfo& CryptAlgInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cryptmessage_2eproto();  return *default_instance_;
}

CryptAlgInfo* CryptAlgInfo::default_instance_ = NULL;

CryptAlgInfo* CryptAlgInfo::New() const {
  return new CryptAlgInfo;
}

void CryptAlgInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    alg_code_ = 0;
    key_len_ = 0;
    if (has_key_data()) {
      if (key_data_ != &::google::protobuf::internal::kEmptyString) {
        key_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptAlgInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 alg_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &alg_code_)));
          set_has_alg_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_key_len;
        break;
      }
      
      // required int32 key_len = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_key_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &key_len_)));
          set_has_key_len();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key_data;
        break;
      }
      
      // required string key_data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key_data()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key_data().data(), this->key_data().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptAlgInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 alg_code = 1;
  if (has_alg_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->alg_code(), output);
  }
  
  // required int32 key_len = 2;
  if (has_key_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->key_len(), output);
  }
  
  // required string key_data = 3;
  if (has_key_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_data().data(), this->key_data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->key_data(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptAlgInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 alg_code = 1;
  if (has_alg_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->alg_code(), target);
  }
  
  // required int32 key_len = 2;
  if (has_key_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->key_len(), target);
  }
  
  // required string key_data = 3;
  if (has_key_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_data().data(), this->key_data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->key_data(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptAlgInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 alg_code = 1;
    if (has_alg_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->alg_code());
    }
    
    // required int32 key_len = 2;
    if (has_key_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->key_len());
    }
    
    // required string key_data = 3;
    if (has_key_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key_data());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptAlgInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptAlgInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptAlgInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptAlgInfo::MergeFrom(const CryptAlgInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_alg_code()) {
      set_alg_code(from.alg_code());
    }
    if (from.has_key_len()) {
      set_key_len(from.key_len());
    }
    if (from.has_key_data()) {
      set_key_data(from.key_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptAlgInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptAlgInfo::CopyFrom(const CryptAlgInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptAlgInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void CryptAlgInfo::Swap(CryptAlgInfo* other) {
  if (other != this) {
    std::swap(alg_code_, other->alg_code_);
    std::swap(key_len_, other->key_len_);
    std::swap(key_data_, other->key_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptAlgInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptAlgInfo_descriptor_;
  metadata.reflection = CryptAlgInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CryptAlgType::kTypeFieldNumber;
const int CryptAlgType::kCryptFieldNumber;
#endif  // !_MSC_VER

CryptAlgType::CryptAlgType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CryptAlgType::InitAsDefaultInstance() {
  crypt_ = const_cast< ::isafetec::CryptAlgInfo*>(&::isafetec::CryptAlgInfo::default_instance());
}

CryptAlgType::CryptAlgType(const CryptAlgType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CryptAlgType::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  crypt_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CryptAlgType::~CryptAlgType() {
  SharedDtor();
}

void CryptAlgType::SharedDtor() {
  if (this != default_instance_) {
    delete crypt_;
  }
}

void CryptAlgType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CryptAlgType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptAlgType_descriptor_;
}

const CryptAlgType& CryptAlgType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cryptmessage_2eproto();  return *default_instance_;
}

CryptAlgType* CryptAlgType::default_instance_ = NULL;

CryptAlgType* CryptAlgType::New() const {
  return new CryptAlgType;
}

void CryptAlgType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_crypt()) {
      if (crypt_ != NULL) crypt_->::isafetec::CryptAlgInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CryptAlgType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_crypt;
        break;
      }
      
      // required .isafetec.CryptAlgInfo crypt = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_crypt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_crypt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CryptAlgType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }
  
  // required .isafetec.CryptAlgInfo crypt = 2;
  if (has_crypt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->crypt(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CryptAlgType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }
  
  // required .isafetec.CryptAlgInfo crypt = 2;
  if (has_crypt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->crypt(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CryptAlgType::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // required .isafetec.CryptAlgInfo crypt = 2;
    if (has_crypt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->crypt());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CryptAlgType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CryptAlgType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CryptAlgType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CryptAlgType::MergeFrom(const CryptAlgType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_crypt()) {
      mutable_crypt()->::isafetec::CryptAlgInfo::MergeFrom(from.crypt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CryptAlgType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CryptAlgType::CopyFrom(const CryptAlgType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptAlgType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_crypt()) {
    if (!this->crypt().IsInitialized()) return false;
  }
  return true;
}

void CryptAlgType::Swap(CryptAlgType* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(crypt_, other->crypt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CryptAlgType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CryptAlgType_descriptor_;
  metadata.reflection = CryptAlgType_reflection_;
  return metadata;
}

// CryptSoftware

// required string name = 1;
inline bool CryptSoftware::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptSoftware::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptSoftware::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptSoftware::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CryptSoftware::name() const {
  return *name_;
}
inline void CryptSoftware::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CryptSoftware::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CryptSoftware::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSoftware::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CryptSoftware::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string image = 2;
inline bool CryptSoftware::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptSoftware::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptSoftware::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptSoftware::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& CryptSoftware::image() const {
  return *image_;
}
inline void CryptSoftware::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CryptSoftware::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void CryptSoftware::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSoftware::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* CryptSoftware::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string version = 3;
inline bool CryptSoftware::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CryptSoftware::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CryptSoftware::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CryptSoftware::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CryptSoftware::version() const {
  return *version_;
}
inline void CryptSoftware::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CryptSoftware::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CryptSoftware::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSoftware::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CryptSoftware::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filter_ext = 4;
inline bool CryptSoftware::has_filter_ext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CryptSoftware::set_has_filter_ext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CryptSoftware::clear_has_filter_ext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CryptSoftware::clear_filter_ext() {
  if (filter_ext_ != &::google::protobuf::internal::kEmptyString) {
    filter_ext_->clear();
  }
  clear_has_filter_ext();
}
inline const ::std::string& CryptSoftware::filter_ext() const {
  return *filter_ext_;
}
inline void CryptSoftware::set_filter_ext(const ::std::string& value) {
  set_has_filter_ext();
  if (filter_ext_ == &::google::protobuf::internal::kEmptyString) {
    filter_ext_ = new ::std::string;
  }
  filter_ext_->assign(value);
}
inline void CryptSoftware::set_filter_ext(const char* value) {
  set_has_filter_ext();
  if (filter_ext_ == &::google::protobuf::internal::kEmptyString) {
    filter_ext_ = new ::std::string;
  }
  filter_ext_->assign(value);
}
inline void CryptSoftware::set_filter_ext(const char* value, size_t size) {
  set_has_filter_ext();
  if (filter_ext_ == &::google::protobuf::internal::kEmptyString) {
    filter_ext_ = new ::std::string;
  }
  filter_ext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSoftware::mutable_filter_ext() {
  set_has_filter_ext();
  if (filter_ext_ == &::google::protobuf::internal::kEmptyString) {
    filter_ext_ = new ::std::string;
  }
  return filter_ext_;
}
inline ::std::string* CryptSoftware::release_filter_ext() {
  clear_has_filter_ext();
  if (filter_ext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_ext_;
    filter_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nofilter_ext = 5;
inline bool CryptSoftware::has_nofilter_ext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CryptSoftware::set_has_nofilter_ext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CryptSoftware::clear_has_nofilter_ext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CryptSoftware::clear_nofilter_ext() {
  if (nofilter_ext_ != &::google::protobuf::internal::kEmptyString) {
    nofilter_ext_->clear();
  }
  clear_has_nofilter_ext();
}
inline const ::std::string& CryptSoftware::nofilter_ext() const {
  return *nofilter_ext_;
}
inline void CryptSoftware::set_nofilter_ext(const ::std::string& value) {
  set_has_nofilter_ext();
  if (nofilter_ext_ == &::google::protobuf::internal::kEmptyString) {
    nofilter_ext_ = new ::std::string;
  }
  nofilter_ext_->assign(value);
}
inline void CryptSoftware::set_nofilter_ext(const char* value) {
  set_has_nofilter_ext();
  if (nofilter_ext_ == &::google::protobuf::internal::kEmptyString) {
    nofilter_ext_ = new ::std::string;
  }
  nofilter_ext_->assign(value);
}
inline void CryptSoftware::set_nofilter_ext(const char* value, size_t size) {
  set_has_nofilter_ext();
  if (nofilter_ext_ == &::google::protobuf::internal::kEmptyString) {
    nofilter_ext_ = new ::std::string;
  }
  nofilter_ext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptSoftware::mutable_nofilter_ext() {
  set_has_nofilter_ext();
  if (nofilter_ext_ == &::google::protobuf::internal::kEmptyString) {
    nofilter_ext_ = new ::std::string;
  }
  return nofilter_ext_;
}
inline ::std::string* CryptSoftware::release_nofilter_ext() {
  clear_has_nofilter_ext();
  if (nofilter_ext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nofilter_ext_;
    nofilter_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SorenPolicy

// required int32 id = 1;
inline bool SorenPolicy::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SorenPolicy::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SorenPolicy::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SorenPolicy::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SorenPolicy::id() const {
  return id_;
}
inline void SorenPolicy::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 type = 2;
inline bool SorenPolicy::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SorenPolicy::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SorenPolicy::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SorenPolicy::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SorenPolicy::type() const {
  return type_;
}
inline void SorenPolicy::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required double last_time = 3;
inline bool SorenPolicy::has_last_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SorenPolicy::set_has_last_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SorenPolicy::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SorenPolicy::clear_last_time() {
  last_time_ = 0;
  clear_has_last_time();
}
inline double SorenPolicy::last_time() const {
  return last_time_;
}
inline void SorenPolicy::set_last_time(double value) {
  set_has_last_time();
  last_time_ = value;
}

// repeated .isafetec.CryptSoftware list = 4;
inline int SorenPolicy::list_size() const {
  return list_.size();
}
inline void SorenPolicy::clear_list() {
  list_.Clear();
}
inline const ::isafetec::CryptSoftware& SorenPolicy::list(int index) const {
  return list_.Get(index);
}
inline ::isafetec::CryptSoftware* SorenPolicy::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::isafetec::CryptSoftware* SorenPolicy::list_ReleaseAt(int index) {
  return list_.ReleaseAt(index);
}
inline void SorenPolicy::list_RemoveAt(int index) {
  list_.RemoveAt(index);
}
inline ::isafetec::CryptSoftware* SorenPolicy::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::isafetec::CryptSoftware >&
SorenPolicy::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::isafetec::CryptSoftware >*
SorenPolicy::mutable_list() {
  return &list_;
}

// optional .isafetec.TimeSpanList timelist = 5;
inline bool SorenPolicy::has_timelist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SorenPolicy::set_has_timelist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SorenPolicy::clear_has_timelist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SorenPolicy::clear_timelist() {
  if (timelist_ != NULL) timelist_->::isafetec::TimeSpanList::Clear();
  clear_has_timelist();
}
inline const ::isafetec::TimeSpanList& SorenPolicy::timelist() const {
  return timelist_ != NULL ? *timelist_ : *default_instance_->timelist_;
}
inline ::isafetec::TimeSpanList* SorenPolicy::mutable_timelist() {
  set_has_timelist();
  if (timelist_ == NULL) timelist_ = new ::isafetec::TimeSpanList;
  return timelist_;
}
inline ::isafetec::TimeSpanList* SorenPolicy::release_timelist() {
  clear_has_timelist();
  ::isafetec::TimeSpanList* temp = timelist_;
  timelist_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CryptAlgInfo

// required int32 alg_code = 1;
inline bool CryptAlgInfo::has_alg_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptAlgInfo::set_has_alg_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptAlgInfo::clear_has_alg_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptAlgInfo::clear_alg_code() {
  alg_code_ = 0;
  clear_has_alg_code();
}
inline ::google::protobuf::int32 CryptAlgInfo::alg_code() const {
  return alg_code_;
}
inline void CryptAlgInfo::set_alg_code(::google::protobuf::int32 value) {
  set_has_alg_code();
  alg_code_ = value;
}

// required int32 key_len = 2;
inline bool CryptAlgInfo::has_key_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptAlgInfo::set_has_key_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptAlgInfo::clear_has_key_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptAlgInfo::clear_key_len() {
  key_len_ = 0;
  clear_has_key_len();
}
inline ::google::protobuf::int32 CryptAlgInfo::key_len() const {
  return key_len_;
}
inline void CryptAlgInfo::set_key_len(::google::protobuf::int32 value) {
  set_has_key_len();
  key_len_ = value;
}

// required string key_data = 3;
inline bool CryptAlgInfo::has_key_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CryptAlgInfo::set_has_key_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CryptAlgInfo::clear_has_key_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CryptAlgInfo::clear_key_data() {
  if (key_data_ != &::google::protobuf::internal::kEmptyString) {
    key_data_->clear();
  }
  clear_has_key_data();
}
inline const ::std::string& CryptAlgInfo::key_data() const {
  return *key_data_;
}
inline void CryptAlgInfo::set_key_data(const ::std::string& value) {
  set_has_key_data();
  if (key_data_ == &::google::protobuf::internal::kEmptyString) {
    key_data_ = new ::std::string;
  }
  key_data_->assign(value);
}
inline void CryptAlgInfo::set_key_data(const char* value) {
  set_has_key_data();
  if (key_data_ == &::google::protobuf::internal::kEmptyString) {
    key_data_ = new ::std::string;
  }
  key_data_->assign(value);
}
inline void CryptAlgInfo::set_key_data(const char* value, size_t size) {
  set_has_key_data();
  if (key_data_ == &::google::protobuf::internal::kEmptyString) {
    key_data_ = new ::std::string;
  }
  key_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CryptAlgInfo::mutable_key_data() {
  set_has_key_data();
  if (key_data_ == &::google::protobuf::internal::kEmptyString) {
    key_data_ = new ::std::string;
  }
  return key_data_;
}
inline ::std::string* CryptAlgInfo::release_key_data() {
  clear_has_key_data();
  if (key_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_data_;
    key_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CryptAlgType

// required int32 type = 1;
inline bool CryptAlgType::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptAlgType::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptAlgType::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptAlgType::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CryptAlgType::type() const {
  return type_;
}
inline void CryptAlgType::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required .isafetec.CryptAlgInfo crypt = 2;
inline bool CryptAlgType::has_crypt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptAlgType::set_has_crypt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CryptAlgType::clear_has_crypt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CryptAlgType::clear_crypt() {
  if (crypt_ != NULL) crypt_->::isafetec::CryptAlgInfo::Clear();
  clear_has_crypt();
}
inline const ::isafetec::CryptAlgInfo& CryptAlgType::crypt() const {
  return crypt_ != NULL ? *crypt_ : *default_instance_->crypt_;
}
inline ::isafetec::CryptAlgInfo* CryptAlgType::mutable_crypt() {
  set_has_crypt();
  if (crypt_ == NULL) crypt_ = new ::isafetec::CryptAlgInfo;
  return crypt_;
}
inline ::isafetec::CryptAlgInfo* CryptAlgType::release_crypt() {
  clear_has_crypt();
  ::isafetec::CryptAlgInfo* temp = crypt_;
  crypt_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace isafetec

// @@protoc_insertion_point(global_scope)
